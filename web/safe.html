<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Web安全 | 无所不能的前端--十万个为什么</title>
    <meta name="description" content="Hello world">
    
    
    <link rel="preload" href="/assets/css/0.styles.617c345f.css" as="style"><link rel="preload" href="/assets/js/app.d2cc9f89.js" as="script"><link rel="preload" href="/assets/js/2.397e6419.js" as="script"><link rel="preload" href="/assets/js/49.0340ff29.js" as="script"><link rel="prefetch" href="/assets/js/10.bb868db5.js"><link rel="prefetch" href="/assets/js/11.4b9af4bc.js"><link rel="prefetch" href="/assets/js/12.c4499f48.js"><link rel="prefetch" href="/assets/js/13.d1872e02.js"><link rel="prefetch" href="/assets/js/14.142a03af.js"><link rel="prefetch" href="/assets/js/15.4a5cbaf1.js"><link rel="prefetch" href="/assets/js/16.f8dbbc61.js"><link rel="prefetch" href="/assets/js/17.82a379c6.js"><link rel="prefetch" href="/assets/js/18.715eafe3.js"><link rel="prefetch" href="/assets/js/19.3ccb129c.js"><link rel="prefetch" href="/assets/js/20.cae30be8.js"><link rel="prefetch" href="/assets/js/21.13af9b85.js"><link rel="prefetch" href="/assets/js/22.37452818.js"><link rel="prefetch" href="/assets/js/23.42d1270e.js"><link rel="prefetch" href="/assets/js/24.ab12fe9d.js"><link rel="prefetch" href="/assets/js/25.c0481126.js"><link rel="prefetch" href="/assets/js/26.11ac2dd4.js"><link rel="prefetch" href="/assets/js/27.739ff2af.js"><link rel="prefetch" href="/assets/js/28.ba55abf0.js"><link rel="prefetch" href="/assets/js/29.b9c0eeba.js"><link rel="prefetch" href="/assets/js/3.addf54d7.js"><link rel="prefetch" href="/assets/js/30.25a4547a.js"><link rel="prefetch" href="/assets/js/31.67514c9b.js"><link rel="prefetch" href="/assets/js/32.70396374.js"><link rel="prefetch" href="/assets/js/33.c599a93b.js"><link rel="prefetch" href="/assets/js/34.7b65401c.js"><link rel="prefetch" href="/assets/js/35.31b0aeaa.js"><link rel="prefetch" href="/assets/js/36.c93744e9.js"><link rel="prefetch" href="/assets/js/37.3163d65d.js"><link rel="prefetch" href="/assets/js/38.939dfb29.js"><link rel="prefetch" href="/assets/js/39.05749514.js"><link rel="prefetch" href="/assets/js/4.7d932259.js"><link rel="prefetch" href="/assets/js/40.d517694b.js"><link rel="prefetch" href="/assets/js/41.a7178842.js"><link rel="prefetch" href="/assets/js/42.d2067a3d.js"><link rel="prefetch" href="/assets/js/43.99404503.js"><link rel="prefetch" href="/assets/js/44.64ecbf2b.js"><link rel="prefetch" href="/assets/js/45.df22fe66.js"><link rel="prefetch" href="/assets/js/46.5233a8b7.js"><link rel="prefetch" href="/assets/js/47.e49bafbe.js"><link rel="prefetch" href="/assets/js/48.b77136bc.js"><link rel="prefetch" href="/assets/js/5.8ee7bf61.js"><link rel="prefetch" href="/assets/js/50.3d8cedd0.js"><link rel="prefetch" href="/assets/js/6.e9a729c7.js"><link rel="prefetch" href="/assets/js/7.4b0de641.js"><link rel="prefetch" href="/assets/js/8.c896fb93.js"><link rel="prefetch" href="/assets/js/9.eca79ebb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.617c345f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无所不能的前端--十万个为什么</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Web工程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web/backend.html" class="sidebar-link">后端架构</a></li><li><a href="/web/database.html" class="sidebar-link">数据库相关</a></li><li><a href="/web/deploy.html" class="sidebar-link">服务</a></li><li><a href="/web/fed.html" class="sidebar-link">前端架构</a></li><li><a href="/web/safe.html" class="active sidebar-link">Web安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/safe.html#网络安全" class="sidebar-link">网络安全</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/safe.html#cdn劫持如何防护？" class="sidebar-link">CDN劫持如何防护？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#xss和csrf了解吗？为什么既要有cookie又要有token？" class="sidebar-link">XSS和CSRF了解吗？为什么既要有cookie又要有token？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#csrf还有哪些防护手段？" class="sidebar-link">CSRF还有哪些防护手段？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#https中间人攻击是什么？如何防护？" class="sidebar-link">Https中间人攻击是什么？如何防护？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#xss是什么，攻击原理，怎么预防？" class="sidebar-link">XSS是什么，攻击原理，怎么预防？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#什么是点击劫持-如何防范点击劫持" class="sidebar-link">什么是点击劫持?如何防范点击劫持?</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#sql-注入攻击" class="sidebar-link">SQL 注入攻击?</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#什么是web应用防火墙？" class="sidebar-link">什么是web应用防火墙？</a></li></ul></li><li class="sidebar-sub-header"><a href="/web/safe.html#密码学" class="sidebar-link">密码学</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web/safe.html#数字签名是什么？什么原理？用在哪里？" class="sidebar-link">数字签名是什么？什么原理？用在哪里？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#数字证书有什么用？" class="sidebar-link">数字证书有什么用？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#非对称加密、对称加密和单向散列加密的区别？" class="sidebar-link">非对称加密、对称加密和单向散列加密的区别？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#了不了解密钥轮替，有什么意义？" class="sidebar-link">了不了解密钥轮替，有什么意义？</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#列举下常见的加密算法和各自的使用场景" class="sidebar-link">列举下常见的加密算法和各自的使用场景</a></li><li class="sidebar-sub-header"><a href="/web/safe.html#综合各方面，考虑一个性能和安全都比较好的加密方式" class="sidebar-link">综合各方面，考虑一个性能和安全都比较好的加密方式</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>企业</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="web安全"><a href="#web安全" aria-hidden="true" class="header-anchor">#</a> Web安全</h1> <h2 id="网络安全"><a href="#网络安全" aria-hidden="true" class="header-anchor">#</a> 网络安全</h2> <h3 id="cdn劫持如何防护？"><a href="#cdn劫持如何防护？" aria-hidden="true" class="header-anchor">#</a> CDN劫持如何防护？</h3> <p><a href="https://github.com/omnipotent-front-end/blog/issues/1" target="_blank" rel="noopener noreferrer">使用SRI解决CDN劫持问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="xss和csrf了解吗？为什么既要有cookie又要有token？"><a href="#xss和csrf了解吗？为什么既要有cookie又要有token？" aria-hidden="true" class="header-anchor">#</a> XSS和CSRF了解吗？为什么既要有cookie又要有token？</h3> <p>首先了解token和cookie的区别。</p> <p>cookie：</p> <p>登陆后后端生成一个sessionid放在cookie中返回给客户端，并且服务端一直记录着这个sessionid，客户端以后每次请求都会带上这个sessionid，<strong>服务端通过这个sessionid来验证身份之类的操作</strong>。所以<strong>别人拿到了cookie拿到了sessionid后，就可以完全替代你</strong>。</p> <p>token：</p> <p>登陆后后端返回一个token给客户端，客户端将这个token存储起来，然后每次客户端请求都需要开发者手动<strong>将token放在header中带过去</strong>，服务端每次只需要对这个token进行验证就能使用token中的信息来进行下一步操作了。</p> <p>XSS攻击：</p> <p>用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。</p> <p>CSRF操作：</p> <p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行</p> <p>以一个CSRF例子来说明：</p> <p>假如一家银行用以运行转账操作的URL地址如下：</p> <p><code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code></p> <p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;&lt;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&gt;&quot;&gt;</code>
如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p> <p>上面的两种攻击方式，如果被xss攻击了，不管是token还是cookie，都能被拿到，所以对于xss攻击来说，cookie和token没有什么区别。但是对于csrf来说就有区别了。</p> <p>以上面的csrf攻击为例：</p> <p>cookie：用户点击了链接，cookie未失效，导致发起请求后后端以为是用户正常操作，于是进行扣款操作。</p> <p>token：用户点击链接，<strong>由于浏览器不会自动带上token，所以即使发了请求，后端的token验证不会通过，所以不会进行扣款操作</strong>。</p> <p>所以总结下来：</p> <p>1、token不是防止XSS的，而是为了防止CSRF的；</p> <p>2、CSRF攻击的原因是<strong>浏览器会自动带上cookie，而浏览器不会自动带上token</strong></p> <p>参考地址：</p> <p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/31" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <hr> <h3 id="csrf还有哪些防护手段？"><a href="#csrf还有哪些防护手段？" aria-hidden="true" class="header-anchor">#</a> CSRF还有哪些防护手段？</h3> <p>第一种是同源检测的方法，服务器根据 http 请求头中 origin 或者 referer 信息来判断请 求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的 时候，直接阻止。这种方式的缺点是有些情况下 referer 可以被伪造。还有就是我们这种方法 同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面 请求这种请求方式也可能被攻击者给利用。</p> <p>第二种方法是使用 CSRF Token 来进行验证，服务器向用户返回一个随机数 Token ，当网站 再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行 验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存 在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一 个问题是一般不会只有一台网站服务器，如果我们的请求经过负载平衡转移到了其他的服务器， 但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况我们 可以通过改变 token 的构建方式来解决。</p> <p>第三种方式使用双重 Cookie 验证的办法，服务器在用户访问网站页面时，向请求域名注入一 个 Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出 这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比 较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这 种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域 名的隔离。</p> <p>第四种方式是使用在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三 方使用，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模 式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以 被请求是 GET 请求，且会发生页面跳转的请求所使用。</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903689702866952" target="_blank" rel="noopener noreferrer">前端安全系列之二：如何防止CSRF攻击？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="https中间人攻击是什么？如何防护？"><a href="#https中间人攻击是什么？如何防护？" aria-hidden="true" class="header-anchor">#</a> Https中间人攻击是什么？如何防护？</h3> <p>首先需要熟悉<a href="/cp/network.html#https的握手过程是什么样子的？">https的握手原理</a></p> <p>中间人攻击过程如下：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200812171515.png"> <p>1、本地请求被劫持（如DNS劫持等），所有请求均发送到中间人的服务器</p> <p>2、中间人服务器返回中间人自己的证书</p> <p>3、客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输。</p> <p>4、中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密</p> <p>5、中间人以客户端的请求内容再向正规网站发起请求</p> <p>6、因为中间人与服务器的通信过程是合法的，正规网站通过建立的安全通道返回加密后的数据</p> <p>7、中间人凭借与正规网站建立的对称加密算法对内容进行解密</p> <p>8、中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输</p> <p>9、客户端通过与中间人建立的对称加密算法对返回结果数据进行解密</p> <p>防范方法：</p> <p>由于缺少对证书的验证，所以客户端虽然发起的是 HTTPS 请求，但客户端完全不知道自己的网络已被拦截，传输内容被中间人全部窃取。</p> <p>服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性。</p> <h3 id="xss是什么，攻击原理，怎么预防？"><a href="#xss是什么，攻击原理，怎么预防？" aria-hidden="true" class="header-anchor">#</a> XSS是什么，攻击原理，怎么预防？</h3> <p>跨站脚本攻击XSS(cross site scripting)，简单来说，就是用户通过各种方式将恶意代码注入到其他用户的页面中。就可以通过脚本获取信息，发起请求，之类的操作。</p> <p>攻击类型主要有两种：反射型和存储型。</p> <p>存储型XSS，持久化，代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，<strong>如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行</strong>。这种XSS比较危险，容易造成蠕虫，盗窃cookie等。</p> <p>反射型XSS，非持久化，需要欺骗用户自己去点击链接才能触发XSS代码（服务器中没有这样的页面和内容），一般容易出现在搜索页面。</p> <p>简单说了一下如何防御：</p> <ul><li><p>转义
前后端在对应的输入展示处进行转义处理。对诸如<code>&lt;script&gt;、&lt;img&gt;、&lt;a&gt;</code>等标签进行过滤。</p></li> <li><p>cookie安全设置
设置HttpOnly以避免cookie劫持的危险</p></li> <li><p>CSP
CSP(content security policy)，是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。</p></li></ul> <p>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种 是设置 meta 标签的方式 <code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot;&gt;</code></p> <p>参考：</p> <p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener noreferrer">内容安全策略( CSP ) - HTTP | MDN<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="什么是点击劫持-如何防范点击劫持"><a href="#什么是点击劫持-如何防范点击劫持" aria-hidden="true" class="header-anchor">#</a> 什么是点击劫持?如何防范点击劫持?</h3> <p>点击劫持是一种视觉欺骗的攻击手段，攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。</p> <p>我们可以在 http 响应头中设置 X-FRAME-OPTIONS 来防御用 iframe 嵌套的点击劫持攻击。 通过不同的值，可以规定页面在特
定的一些情况才能作为 iframe 来使用。</p> <p>参考：</p> <p><a href="https://www.jianshu.com/p/251704d8ff18" target="_blank" rel="noopener noreferrer">web安全之--点击劫持攻击与防御技术简介 - 简书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="sql-注入攻击"><a href="#sql-注入攻击" aria-hidden="true" class="header-anchor">#</a> SQL 注入攻击?</h3> <p>SQL 注入攻击指的是攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 被一起构
造，破坏原有 SQL 结构，并在数据库中执行，达到编写程序时意料之外结果的攻击行为。</p> <p>防范：</p> <p>使用预编译的PrepareStatement是必须的，但是一般我们会从两个方面同时入手。</p> <p>Web端
有效性检验。</p> <p>限制字符串输入的长度。</p> <p>服务端</p> <p>不用拼接SQL字符串。</p> <p>使用预编译的PrepareStatement。</p> <p>有效性检验。(为什么服务端还要做有效性检验？第一准则，外部都是不可信的，防止攻击者绕过Web端请求)</p> <p>过滤SQL需要的参数中的特殊字符。比如单引号、双引号。</p> <p>参考：</p> <p><a href="http://blog.720ui.com/2016/security_web/" target="_blank" rel="noopener noreferrer">如何防范常见的Web攻击 | 梁桂钊的博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="什么是web应用防火墙？"><a href="#什么是web应用防火墙？" aria-hidden="true" class="header-anchor">#</a> 什么是web应用防火墙？</h3> <p>参考：</p> <p><a href="https://zhuanlan.zhihu.com/p/74387108" target="_blank" rel="noopener noreferrer">什么是Web应用防火墙？ - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>Web应用防护墙(Web Application Firewall，简称WAF)是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品，主要用于防御针对网络应用层的攻击，像SQL注入、跨站脚本攻击、参数篡改、应用平台漏洞攻击、拒绝服务攻击等。</p> <p>WAF通过记录分析黑客攻击样本库及漏洞情况，使用数千台防御设备和骨干网络以及安全替身、攻击溯源等前沿技术，构建网站应用级入侵防御系统，解决网页篡改、数据泄露和访问不稳定等异常问题，保障网站数据安全性和应用程序可用性。</p> <p>WAF部署在web应用程序前面，在用户请求到达web服务器前对用户请求进行扫描和过滤，分析并校验每个用户请求的网络包，确保每个用户请求有效且安全，对无效或有攻击行为的请求进行阻断或隔离。通过检查HTTP流量，可以防止源自web应用程序的安全漏洞(如SQL注入，跨站脚本攻击，文件包含和安全配置错误)的攻击。</p> <hr> <h2 id="密码学"><a href="#密码学" aria-hidden="true" class="header-anchor">#</a> 密码学</h2> <h3 id="数字签名是什么？什么原理？用在哪里？"><a href="#数字签名是什么？什么原理？用在哪里？" aria-hidden="true" class="header-anchor">#</a> 数字签名是什么？什么原理？用在哪里？</h3> <p>数字签名（digital signature）是公钥密码的逆应用：<strong>用私钥加密消息，用公钥解密消息</strong>。</p> <p>信息安全中有三个需要解决的问题：</p> <p>保密性(Confidentiality)：信息在传输时不被泄露</p> <p>完整性（Integrity）：信息在传输时不被篡改</p> <p>有效性（Availability）：信息的使用者是合法的</p> <p>这三要素统称为CIA Triad。</p> <p>公钥密码解决保密性问题</p> <p>数字签名解决完整性问题和有效性问题</p> <p>用私钥加密的消息称为签名，只有拥有私钥的用户可以生成签名。
用公钥解密签名这一步称为验证签名，所有用户都可以验证签名(因为公钥是公开的)</p> <p>原理：</p> <p>数字签名技术是将原文通过特定HASH函数得到的摘要信息<strong>用发送者的私钥加密</strong>，与原文一起传送给接收者。接收者只有<strong>用发送者的公钥才能解密</strong>被加密的摘要信息，然后用HASH函数对收到的原文提炼出一个摘要信息，与解密得到的摘要进行对比。哪怕只是一个字符不相同，用HASH函数生成的摘要就一定不同。如果比对结果一致，则说明收到的信息是完整的，在传输过程中没有被修改，否则信息一定被修改过，因此<strong>数字签名能够验证信息的完整性</strong>。</p> <p>参考：</p> <p><a href="https://zhuanlan.zhihu.com/p/25162134" target="_blank" rel="noopener noreferrer">数字签名原理及作用 - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.jianshu.com/p/9db57e761255" target="_blank" rel="noopener noreferrer">什么是数字签名和证书？ - 简书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="数字证书有什么用？"><a href="#数字证书有什么用？" aria-hidden="true" class="header-anchor">#</a> 数字证书有什么用？</h3> <p>数字证书简称CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的，为什么需要用数字证书呢，难道有了数字签名还不够安全吗？</p> <p>如果有人（张三）用自己的公钥把真实服务器发送给浏览器的公钥替换了，于是张三用自己的私钥执行相同的步骤对文本Hash、数字签名，最后得到的结果都没什么问题，但事实上浏览器看到的东西却不是真实服务器给的，而是被张三从里到外（公钥到私钥）换了一通。那么如何保证你现在使用的公钥就是真实服务器发给你的呢？</p> <p>我们就用数字证书来解决这个问题。数字证书一般由数字证书认证机构（Certificate Authority）颁发，证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密后发给浏览器，浏览器使用数字证书机构的公钥解密后得到真实服务器的公钥。这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。</p> <p>参考：</p> <p><a href="https://www.zhihu.com/question/52493697" target="_blank" rel="noopener noreferrer">数字签名、数字证书与HTTPS是什么关系？ - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="非对称加密、对称加密和单向散列加密的区别？"><a href="#非对称加密、对称加密和单向散列加密的区别？" aria-hidden="true" class="header-anchor">#</a> 非对称加密、对称加密和单向散列加密的区别？</h3> <p><strong>对称加密</strong>：</p> <p>指的就是<strong>加、解密使用的同是一串密钥</strong>，所以被称做对称加密。对称加密只有一个密钥作为私钥。</p> <p>常见的对称加密算法：DES，AES等。</p> <p>优缺点：</p> <p>对称加密相比非对称加密算法来说，加解密的效率要高得多、加密速度快。但是缺陷在于对于密钥的管理和分发上比较困难，不是非常安全，密钥管理负担很重。</p> <p><strong>非对称加密</strong>：</p> <p>指的是<strong>加、解密使用不同的密钥，一把作为公开的公钥，另一把作为私钥。公钥加密的信息，只有私钥才能解密。反之，私钥加密的信息，只有公钥才能解密</strong>。</p> <p>举个例子，你向某公司服务器请求公钥，服务器将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人才能对你的消息解密。与对称加密不同的是，公司服务器不需要将私钥通过网络发送出去，因此安全性大大提高。</p> <p>最常用的非对称加密算法：RSA</p> <p>优缺点：</p> <p>安全性更高，公钥是公开的，密钥是自己保存的，不需要将私钥给别人。缺点：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p> <p><strong>散列</strong></p> <p>也称为散列值或消息摘要 ，是一种与基于密钥（对称密钥或公钥）的加密不同的数据转换类型。</p> <p>散列就是通过把一个叫做散列算法的单向数学函数应用于数据，<strong>将任意长度的一块数据转换为一个定长的、不可逆转的数字，其长度通常在128～256位之间</strong>。所产生的散列值的长度应足够长，因此使找到两块具有相同散列值的数据的机会很少。</p> <p>如发件人生成邮件的散列值并加密它，然后将它与邮件本身一起发送。而收件人同时解密邮件和散列值，并由接收到的邮件产生另外一个散列值，然后将两个散列值进行比较。如果两者相同，邮件极有可能在传输期间没有发生任何改变。</p> <p>优缺点：</p> <p>散列算法处理数据的速度比公钥算法快得多。散列数据还缩短了要签名的数据的长度，因而加快了签名过程。但不可逆转，无法解密。</p> <p>参考：</p> <p><a href="https://juejin.im/post/5abb6c8651882555784e051d" target="_blank" rel="noopener noreferrer">对称加密、非对称加密、RSA(总结) - 掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="了不了解密钥轮替，有什么意义？"><a href="#了不了解密钥轮替，有什么意义？" aria-hidden="true" class="header-anchor">#</a> 了不了解密钥轮替，有什么意义？</h3> <p>轮替密钥不会停用或销毁以前的密钥版本。以前的密钥版本将不再是主密钥版本，但仍可用于解密数据。</p> <p>通过轮替密钥可以轻松地遵循标准安全做法，例如支付卡行业数据安全标准 (PCI DSS) 要求。定期轮替密钥是安全性方面的一种最佳做法，原因如下：</p> <p>为了限制可用于对特定密钥版本进行密码分析的加密消息数。同样，为了限制可用于对特定密钥版本进行密码分析的加密字节总数。密钥生命周期建议是特定于算法的，并且基于生成的消息数或加密的总字节数。例如，伽罗瓦/计数器模式 (GCM) 中的对称密钥的推荐密钥生命周期基于加密消息的数量，如 https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-38d.pdf 中所述。</p> <p>为了确保系统已准备好应对需要转为使用更强大的算法的情况。如果正在进行的操作不包含密钥轮替，则系统将依赖于特定密钥，从而难以在突发事件发生后启动密钥轮替。</p> <p>同样，为了确保系统已准备好应对密钥泄露的情况。不应在突发事件实时恢复期间首次尝试密钥轮替。</p> <p>为了减少密钥版本被破解时不受保护的密文量。</p> <p>为了防止使用被破解或疑似被破解的密钥版本。</p> <p><strong>使用场景比如koa的app.keys，egg在对cookie进行加密时，就使用了密钥轮替，从而保证密钥替换后，老的cookie用户，不会导致校验失败</strong>。</p> <p><a href="https://github.com/FunnyLiu/egg-cookies/tree/readsource" target="_blank" rel="noopener noreferrer">egg-cookies源码分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>参考：</p> <p><a href="https://cloud.google.com/kms/docs/key-rotation" target="_blank" rel="noopener noreferrer">密钥轮替  |  Cloud KMS  |  Google Cloud<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="列举下常见的加密算法和各自的使用场景"><a href="#列举下常见的加密算法和各自的使用场景" aria-hidden="true" class="header-anchor">#</a> 列举下常见的加密算法和各自的使用场景</h3> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20191128103951.png"> <h4 id="md5"><a href="#md5" aria-hidden="true" class="header-anchor">#</a> md5</h4> <p>MD5是一种基于哈希函数的单向加密算法，只能加密、无法解密，它是把一个任意长度的字节串变换成一定长的大整数。请注意我使用了&quot;字节串&quot;而不是&quot;字符串&quot;这个词，是因为这种变换只与字节的值有关，与字符集或编码方式无关。MD5将任意长度的&quot;字节串&quot;变换成一个128bit的大整数，并且它是一个不可逆的字符串变换算法，换句话说就是，即使你看到源程序和算法描述，也无法将一个MD5的值变换回原始的字符串，从数学原理上说，是因为原始的字符串有无穷多个，这有点象不存在反函数的数学函数。<strong>MD5是不可逆的只有加密没有解密</strong>。</p> <p>加强加密性</p> <p>单纯的 MD5加密是不安全的，可通过撞库的方式来暴力破解出来的，因此可以通过多种方式来进行加强</p> <p>1、加盐</p> <p>最好配合 MD5加盐的方式来对密文进行再次处理，即往明文中插入或拼接一个随机的字符串，然后再进行加密。</p> <p>盐值加如的代码例子如下</p> <p>password = [passwordstringByAppendingString:salt];</p> <p>2、乱序</p> <p>先对明文进行md5加密，然后对密文进行乱序</p> <h4 id="base64"><a href="#base64" aria-hidden="true" class="header-anchor">#</a> base64</h4> <p>Base64编码的思想是：采用64个基本的ASCII码字符对数据进行重新编码。它将需要编码的数据拆分成字节数组，以3个字节为一组，按顺序排列24位数据，再把这24位数据分成4组，即每组6位；再在每组的的最高位前补两个0凑足一个字节，这样就把一个3字节为一组的数据重新编码成了4个字节；当所要编码的数据的字节数不是3的整倍数，也就是说在分组时最后一组不够3个字节，这时在最后一组填充1到2个0字节，并在最后编码完成后在结尾添加1到2个=号。</p> <p>特点：</p> <p>-数据加密之后，数据量会变大，变大1/3左右。</p> <p>-可进行反向解密。</p> <p>-编码后有个非常显著的特点，末尾有个=号。</p> <h4 id="des"><a href="#des" aria-hidden="true" class="header-anchor">#</a> DES</h4> <p>数据加密标准算法(Data Encryption Standard)，和BASE64最明显的区别就是有一个公有密钥，该密钥既用于加密、也用于解密，并且要求密钥是一个长度至少大于8位的字符串。使用DES加密、解密的核心是确保工作密钥的安全性。</p> <h4 id="aes"><a href="#aes" aria-hidden="true" class="header-anchor">#</a> AES</h4> <p>高级加密标准Advanced Encryption Standard简称：AES，在密码学中又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准。它是一种对称加密算法，这个标准也替代原先的DES标准，已经被多方分析且广为全世界所使用。AES设计有三个密钥长度:128、192、256位，相对而言，AES的128密钥比DES的56密钥强1021倍。AES算法主要包括三个方面：轮变化、圈数和密钥扩展。</p> <p>特点</p> <p>AES作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活，在软件及硬件上都能快速地加解密且只需要很少的存储资源等优点。</p> <h4 id="rsa"><a href="#rsa" aria-hidden="true" class="header-anchor">#</a> RSA</h4> <p>RSA是目前最有影响力的公钥加密算法，它能够抵抗到目前为止已知的绝大多数密码攻击，已被ISO推荐为公钥数据加密标准。RSA的公开密钥密码体制就是使用不同的加密密钥与解密密钥，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。通常是先生成一对RSA密钥，其中之一是保密密钥，由用户保存；另一个为公开密钥，可对外公开，甚至可在网络服务器中注册。为提高保密强度，RSA密钥至少为500位长，一般推荐使用1024位，这就使加密的计算量很大。RSA算法是一种非对称密码算法，所谓非对称，就是指该算法需要一对密钥，使用其中一个加密，则需要用另一个才能解密。</p> <p>RSA算法是非对称加密算法的典型代表，既能加密、又能解密。和对称加密算法比如DES的明显区别在于用于加密、解密的密钥是不同的。使用RSA算法，只要密钥足够长(一般要求1024bit)，加密的信息是不能被破解的。用户通过https协议访问服务器时，就是使用非对称加密算法进行数据的加密、解密操作的。</p> <p>服务器发送数据给客户端时使用私钥（private key）进行加密，并且使用加密之后的数据和私钥生成数字签名（digitalsignature）并发送给客户端。客户端接收到服务器发送的数据会使用公钥（public key）对数据来进行解密，并且根据加密数据和公钥验证数字签名的有效性，防止加密数据在传输过程中被第三方进行了修改。</p> <p>客户端发送数据给服务器时使用公钥进行加密，服务器接收到加密数据之后使用私钥进行解密。</p> <p>特点</p> <ul><li><p>密钥管理的方便，计算量很大速度相对比较慢。</p></li> <li><p>安全性很高，能够抵抗到目前为止已知的绝大多数密码攻击。</p></li></ul> <p>参考：</p> <p><a href="https://www.jianshu.com/p/ea229b329347" target="_blank" rel="noopener noreferrer">常用的加解密算法的优缺点、应用场景总结 - 简书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="综合各方面，考虑一个性能和安全都比较好的加密方式"><a href="#综合各方面，考虑一个性能和安全都比较好的加密方式" aria-hidden="true" class="header-anchor">#</a> 综合各方面，考虑一个性能和安全都比较好的加密方式</h3> <p>基于md5和aes的超强度加密算法：</p> <p>用户的密码是一定的,但是每次发送给网络的密码都不同。相同的密码相同的加密算法,每次获得的值不同。</p> <p>客户端和服务器端要求时间一致，时间精度越高，越安全</p> <p>假如约定网络请求延时3秒</p> <p>客户端：</p> <p>a. 对请求参数one进行一次AES对称加密(或者其他的对称加密)，后形成密文two。</p> <p>b.对当前时间进行一次md5加密后形成three时间密文</p> <p>c.将密文two与密文three进行拼接(或其他算法)，再进行一次AES对称加密(或者其他对称加密)形成four密文。</p> <p>d.将密文four发送给服务器。</p> <p>服务端：</p> <p>a.对收到的密文four进行一次AES对称解密得到two+three的密文结合体。</p> <p>b.以收到的时间为基准与前3秒时间遍历成md5密文，并与结合体进行对比，假如匹配上了，就将two密文解密出来。</p> <p>c.对two密文进行最后的AES对称加密然后就得出正确的请求参数</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/web/fed.html" class="prev">
          前端架构
        </a></span> <span class="next"><a href="/practice/english.html">
          english
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2cc9f89.js" defer></script><script src="/assets/js/2.397e6419.js" defer></script><script src="/assets/js/49.0340ff29.js" defer></script>
  </body>
</html>
