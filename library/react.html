<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React | 无所不能的前端--十万个为什么</title>
    <meta name="description" content="Hello world">
    
    
    <link rel="preload" href="/assets/css/0.styles.617c345f.css" as="style"><link rel="preload" href="/assets/js/app.d2cc9f89.js" as="script"><link rel="preload" href="/assets/js/2.397e6419.js" as="script"><link rel="preload" href="/assets/js/30.25a4547a.js" as="script"><link rel="prefetch" href="/assets/js/10.bb868db5.js"><link rel="prefetch" href="/assets/js/11.4b9af4bc.js"><link rel="prefetch" href="/assets/js/12.c4499f48.js"><link rel="prefetch" href="/assets/js/13.d1872e02.js"><link rel="prefetch" href="/assets/js/14.142a03af.js"><link rel="prefetch" href="/assets/js/15.4a5cbaf1.js"><link rel="prefetch" href="/assets/js/16.f8dbbc61.js"><link rel="prefetch" href="/assets/js/17.82a379c6.js"><link rel="prefetch" href="/assets/js/18.715eafe3.js"><link rel="prefetch" href="/assets/js/19.3ccb129c.js"><link rel="prefetch" href="/assets/js/20.cae30be8.js"><link rel="prefetch" href="/assets/js/21.13af9b85.js"><link rel="prefetch" href="/assets/js/22.37452818.js"><link rel="prefetch" href="/assets/js/23.42d1270e.js"><link rel="prefetch" href="/assets/js/24.ab12fe9d.js"><link rel="prefetch" href="/assets/js/25.c0481126.js"><link rel="prefetch" href="/assets/js/26.11ac2dd4.js"><link rel="prefetch" href="/assets/js/27.739ff2af.js"><link rel="prefetch" href="/assets/js/28.ba55abf0.js"><link rel="prefetch" href="/assets/js/29.b9c0eeba.js"><link rel="prefetch" href="/assets/js/3.addf54d7.js"><link rel="prefetch" href="/assets/js/31.67514c9b.js"><link rel="prefetch" href="/assets/js/32.70396374.js"><link rel="prefetch" href="/assets/js/33.c599a93b.js"><link rel="prefetch" href="/assets/js/34.7b65401c.js"><link rel="prefetch" href="/assets/js/35.31b0aeaa.js"><link rel="prefetch" href="/assets/js/36.c93744e9.js"><link rel="prefetch" href="/assets/js/37.3163d65d.js"><link rel="prefetch" href="/assets/js/38.939dfb29.js"><link rel="prefetch" href="/assets/js/39.05749514.js"><link rel="prefetch" href="/assets/js/4.7d932259.js"><link rel="prefetch" href="/assets/js/40.d517694b.js"><link rel="prefetch" href="/assets/js/41.a7178842.js"><link rel="prefetch" href="/assets/js/42.d2067a3d.js"><link rel="prefetch" href="/assets/js/43.99404503.js"><link rel="prefetch" href="/assets/js/44.64ecbf2b.js"><link rel="prefetch" href="/assets/js/45.df22fe66.js"><link rel="prefetch" href="/assets/js/46.5233a8b7.js"><link rel="prefetch" href="/assets/js/47.e49bafbe.js"><link rel="prefetch" href="/assets/js/48.b77136bc.js"><link rel="prefetch" href="/assets/js/49.0340ff29.js"><link rel="prefetch" href="/assets/js/5.8ee7bf61.js"><link rel="prefetch" href="/assets/js/50.3d8cedd0.js"><link rel="prefetch" href="/assets/js/6.e9a729c7.js"><link rel="prefetch" href="/assets/js/7.4b0de641.js"><link rel="prefetch" href="/assets/js/8.c896fb93.js"><link rel="prefetch" href="/assets/js/9.eca79ebb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.617c345f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无所不能的前端--十万个为什么</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/library/axios.html" class="sidebar-link">Axios</a></li><li><a href="/library/babel.html" class="sidebar-link">Babel</a></li><li><a href="/library/docker.html" class="sidebar-link">Docker</a></li><li><a href="/library/egg.html" class="sidebar-link">Egg</a></li><li><a href="/library/express.html" class="sidebar-link">express</a></li><li><a href="/library/koa.html" class="sidebar-link">koa</a></li><li><a href="/library/nest.html" class="sidebar-link">NestJS</a></li><li><a href="/library/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/library/pm2.html" class="sidebar-link">PM2</a></li><li><a href="/library/react.html" class="active sidebar-link">React</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/react.html#应用" class="sidebar-link">应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/react.html#react中的key是用来做什么的？（todo）" class="sidebar-link">React中的key是用来做什么的？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/react.html#使用jsx时有那些基本技巧？" class="sidebar-link">使用JSX时有那些基本技巧？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react有哪些生命周期？" class="sidebar-link">React有哪些生命周期？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#ajax-请求放在-componentdidmount-里进行处理还是放在componentwillmount-里进行处理比较合适？（todo）" class="sidebar-link">Ajax 请求放在 componentDidMount 里进行处理还是放在componentWillMount 里进行处理比较合适？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/react.html#函数组件和类组件有什么区别？" class="sidebar-link">函数组件和类组件有什么区别？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#为什么要使用hooks，解决了class什么问题？" class="sidebar-link">为什么要使用Hooks，解决了class什么问题？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react中高阶组件的应用场景" class="sidebar-link">React中高阶组件的应用场景</a></li><li class="sidebar-sub-header"><a href="/library/react.html#使用-react-hooks-的同时为什么需要使用高阶组件？（todo）" class="sidebar-link">使用 React Hooks 的同时为什么需要使用高阶组件？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/react.html#完全用-hooks-的写法是否可以摒弃高阶组件的写法？（todo）" class="sidebar-link">完全用 Hooks 的写法是否可以摒弃高阶组件的写法？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/react.html#怎么使用-hooks-替代高阶组件？（todo）" class="sidebar-link">怎么使用 Hooks 替代高阶组件？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/react.html#useeffect对标哪些生命周期？" class="sidebar-link">useEffect对标哪些生命周期？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react合成事件和原生事件的区别是？" class="sidebar-link">React合成事件和原生事件的区别是？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react中state和props的区别？" class="sidebar-link">React中state和props的区别？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-中的-setstate-是同步还是异步？" class="sidebar-link">React 中的 setState 是同步还是异步？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-中-setstate-后想要拿到更新的state值应该怎么处理？" class="sidebar-link">React 中 setState 后想要拿到更新的state值应该怎么处理？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#setstate为何设计成异步的？如何实现的？" class="sidebar-link">setState为何设计成异步的？如何实现的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-中受控组件和非受控组件的区别？" class="sidebar-link">React 中受控组件和非受控组件的区别？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#在哪些场景应该使用非受控组件？" class="sidebar-link">在哪些场景应该使用非受控组件？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react组件之间怎么通信？" class="sidebar-link">React组件之间怎么通信？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#在-react-中，refs-的作用是什么？" class="sidebar-link">在 React 中，refs 的作用是什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#是否了解shouldcomponentupdate，做什么的？" class="sidebar-link">是否了解shouldComponentUpdate，做什么的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#hook函数式组件怎么实现shouldcomponentupdate？" class="sidebar-link">hook函数式组件怎么实现shouldComponentUpdate？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#class组件怎么使用hooks？" class="sidebar-link">class组件怎么使用hooks？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#hook遇到不更新的问题吗？怎么解决？" class="sidebar-link">hook遇到不更新的问题吗？怎么解决？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react怎么控制渲染顺序？" class="sidebar-link">React怎么控制渲染顺序？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#做过哪些react方面的性能优化？" class="sidebar-link">做过哪些React方面的性能优化？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#uselayouteffect和useeffect的区别是？" class="sidebar-link">useLayoutEffect和useEffect的区别是？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react组件什么情况下会重新re-render？" class="sidebar-link">react组件什么情况下会重新re-render？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#如何排查react组件re-render？" class="sidebar-link">如何排查react组件re-render？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#如何避免父组件-re-render-导致的-re-render？" class="sidebar-link">如何避免父组件 re-render 导致的 re-render？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#为什么react-memo不是默认行为？" class="sidebar-link">为什么React.memo不是默认行为？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#如何降低re-render的范围？" class="sidebar-link">如何降低re-render的范围？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#什么时候该用usecallback和usememo？" class="sidebar-link">什么时候该用useCallback和useMemo？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#如何规避函数参数每次生成一个新的匿名函数？" class="sidebar-link">如何规避函数参数每次生成一个新的匿名函数？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#usecallback用过没？使用场景是？" class="sidebar-link">useCallback用过没？使用场景是？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#usememo用过没？使用场景是？" class="sidebar-link">useMemo用过没？使用场景是？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#usereducer用过没？比redux好在哪里？" class="sidebar-link">useReducer用过没？比Redux好在哪里？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react中state有层级很深，比如a-b-c-d，如果只更新c属性有哪些办法？" class="sidebar-link">react中state有层级很深，比如a.b.c.d，如果只更新c属性有哪些办法？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react中怎么处理异常？" class="sidebar-link">react中怎么处理异常？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#错误边界怎么捕获异步错误" class="sidebar-link">错误边界怎么捕获异步错误</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react可以写命令行？体验怎么样？" class="sidebar-link">react可以写命令行？体验怎么样？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#使用react操作cli的工具ink的原理是什么？" class="sidebar-link">使用react操作cli的工具ink的原理是什么？</a></li></ul></li><li class="sidebar-sub-header"><a href="/library/react.html#原理" class="sidebar-link">原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/react.html#react和react-dom的区别是什么？" class="sidebar-link">react和react-dom的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react整体的工作流程和架构是什么样？" class="sidebar-link">React整体的工作流程和架构是什么样？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-createelement是做什么？" class="sidebar-link">React.createElement是做什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#jsx-reactelement-fiber-dom之间的关系是什么？" class="sidebar-link">JSX/ReactElement/Fiber/Dom之间的关系是什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react15的stackreconciler和react16的fiberreconciler有什么区别？" class="sidebar-link">React15的StackReconciler和React16的FiberReconciler有什么区别？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#reconciler主要是做什么的？" class="sidebar-link">Reconciler主要是做什么的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#fiber是什么？数据结构是怎么样？" class="sidebar-link">Fiber是什么？数据结构是怎么样？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#fiber是怎么工作的？" class="sidebar-link">Fiber是怎么工作的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react16的的render阶段做了什么事情？" class="sidebar-link">React16的的render阶段做了什么事情？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#render阶段的beginwork究竟做了什么？" class="sidebar-link">render阶段的beginWork究竟做了什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#render阶段的completework究竟做了什么？" class="sidebar-link">render阶段的completeWork究竟做了什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#diff算法到底是做什么的？" class="sidebar-link">Diff算法到底是做什么的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#diff算法怎么优化复杂度？" class="sidebar-link">Diff算法怎么优化复杂度？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#diff算法具体怎么实现？" class="sidebar-link">Diff算法具体怎么实现？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react的diff为什么用不了双指针优化？" class="sidebar-link">React的diff为什么用不了双指针优化？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react组件什么时候会重新渲染？" class="sidebar-link">React组件什么时候会重新渲染？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react如何避免重复渲染？" class="sidebar-link">React如何避免重复渲染？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#fiber原理" class="sidebar-link">Fiber原理</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-hooks的原理" class="sidebar-link">React Hooks的原理</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-hooks为什么不能在循环、条件或者嵌套函数中调用" class="sidebar-link">React Hooks为什么不能在循环、条件或者嵌套函数中调用</a></li><li class="sidebar-sub-header"><a href="/library/react.html#hooks为什么用单链表存储而不是数组？" class="sidebar-link">hooks为什么用单链表存储而不是数组？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#hook为什么不能在条件判断中使用？" class="sidebar-link">hook为什么不能在条件判断中使用？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react在批量处理事件时，是否需要开发者手动进行事件代理？为什么？" class="sidebar-link">React在批量处理事件时，是否需要开发者手动进行事件代理？为什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-memo做了什么？怎么做的？" class="sidebar-link">React.memo做了什么？怎么做的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-memo和purecomponent有什么区别？" class="sidebar-link">React.memo和PureComponent有什么区别？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#react-lazy做了什么？怎么做的？" class="sidebar-link">React.lazy做了什么？怎么做的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#class组件为什么需要绑定this" class="sidebar-link">class组件为什么需要绑定this</a></li><li class="sidebar-sub-header"><a href="/library/react.html#怎么解决this丢失问题" class="sidebar-link">怎么解决this丢失问题</a></li><li class="sidebar-sub-header"><a href="/library/react.html#为什么用箭头函数可以解决？" class="sidebar-link">为什么用箭头函数可以解决？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#concurrent-mode是什么？" class="sidebar-link">Concurrent Mode是什么？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#scheduler（调度器）是做什么的？" class="sidebar-link">Scheduler（调度器）是做什么的？</a></li><li class="sidebar-sub-header"><a href="/library/react.html#时间切片的原理" class="sidebar-link">时间切片的原理</a></li><li class="sidebar-sub-header"><a href="/library/react.html#优先级调度的原理" class="sidebar-link">优先级调度的原理</a></li></ul></li><li class="sidebar-sub-header"><a href="/library/react.html#编码" class="sidebar-link">编码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/react.html#实现一个自定义hook（todo）？" class="sidebar-link">实现一个自定义hook（todo）？</a></li></ul></li></ul></li><li><a href="/library/react_native.html" class="sidebar-link">React Native</a></li><li><a href="/library/redux.html" class="sidebar-link">redux</a></li><li><a href="/library/rollup.html" class="sidebar-link">Rollup</a></li><li><a href="/library/taro.html" class="sidebar-link">Taro</a></li><li><a href="/library/typescript.html" class="sidebar-link">Typescript</a></li><li><a href="/library/vue.html" class="sidebar-link">Vue</a></li><li><a href="/library/webpack.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web工程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>企业</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="react"><a href="#react" aria-hidden="true" class="header-anchor">#</a> React</h1> <h2 id="应用"><a href="#应用" aria-hidden="true" class="header-anchor">#</a> 应用</h2> <h3 id="react中的key是用来做什么的？（todo）"><a href="#react中的key是用来做什么的？（todo）" aria-hidden="true" class="header-anchor">#</a> React中的key是用来做什么的？（todo）</h3> <h3 id="使用jsx时有那些基本技巧？"><a href="#使用jsx时有那些基本技巧？" aria-hidden="true" class="header-anchor">#</a> 使用JSX时有那些基本技巧？</h3> <h4 id="传递多参数"><a href="#传递多参数" aria-hidden="true" class="header-anchor">#</a> 传递多参数</h4> <p>利用解构、剩余参数和展开运算符</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> name<span class="token punctuation">,</span> <span class="token operator">...</span>platformProps <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div <span class="token punctuation">{</span><span class="token operator">...</span>platformProps<span class="token punctuation">}</span><span class="token operator">&gt;</span>Hi <span class="token punctuation">{</span>name<span class="token punctuation">}</span><span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="合并参数"><a href="#合并参数" aria-hidden="true" class="header-anchor">#</a> 合并参数</h4> <p>利用默认参数、展开运算符，
在操作className时非常常见</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">MyButton</span><span class="token punctuation">(</span><span class="token punctuation">{</span> className <span class="token operator">=</span> <span class="token string">&quot;&quot;</span><span class="token punctuation">,</span> <span class="token operator">...</span>props <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> classNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;btn&quot;</span><span class="token punctuation">,</span> className<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button className<span class="token operator">=</span><span class="token punctuation">{</span>classNames<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="条件判断"><a href="#条件判断" aria-hidden="true" class="header-anchor">#</a> 条件判断</h4> <p>if：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  condition <span class="token operator">&amp;&amp;</span> <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Rendered when <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">truthy</span><span class="token template-punctuation string">`</span></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>unless：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  condition <span class="token operator">||</span> <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Rendered when <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">falsy</span><span class="token template-punctuation string">`</span></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>if-else</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  condition <span class="token operator">?</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Rendered when <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">truthy</span><span class="token template-punctuation string">`</span></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>Rendered when <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">falsy</span><span class="token template-punctuation string">`</span></span><span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="children内容"><a href="#children内容" aria-hidden="true" class="header-anchor">#</a> children内容</h4> <p>可以为字符串，也可以是数组：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Hello World<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">&quot;Hello &quot;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>World<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token string">&quot;!&quot;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
</code></pre></div><h4 id="list"><a href="#list" aria-hidden="true" class="header-anchor">#</a> list</h4> <p>使用map</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span>
  <span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token string">&quot;first&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;second&quot;</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
<span class="token comment">//等同于</span>
<span class="token operator">&lt;</span>ul<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token punctuation">[</span><span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>first<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token operator">&lt;</span>li<span class="token operator">&gt;</span>second<span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">&gt;</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>ul<span class="token operator">&gt;</span>
</code></pre></div><h3 id="react有哪些生命周期？"><a href="#react有哪些生命周期？" aria-hidden="true" class="header-anchor">#</a> React有哪些生命周期？</h3> <p>目前React 16.8 +的生命周期分为三个阶段,分别是挂载阶段、更新阶段、卸载阶段</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211104161247.png"> <p>挂载阶段:</p> <p>constructor: 构造函数，最先被执行,我们通常在构造函数里初始化state对象或者给自定义方法绑定this</p> <p>getDerivedStateFromProps: static getDerivedStateFromProps(nextProps, prevState),这是个静态方法,当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps</p> <p>render: render函数是纯函数，只返回需要渲染的东西，不应该包含其它的业务逻辑,可以返回原生的DOM、React组件、Fragment、Portals、字符串和数字、Boolean和null等内容</p> <p>componentDidMount: 组件装载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnMount中取消订阅</p> <p>更新阶段:</p> <p>getDerivedStateFromProps: 此方法在更新个挂载阶段都可能会调用</p> <p>shouldComponentUpdate: shouldComponentUpdate(nextProps, nextState),有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true,我们通常利用此生命周期来优化React程序性能
render: 更新阶段也会触发此生命周期</p> <p>getSnapshotBeforeUpdate: getSnapshotBeforeUpdate(prevProps, prevState),这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，可以返回null，此生命周期必须与componentDidUpdate搭配使用</p> <p>componentDidUpdate: componentDidUpdate(prevProps, prevState, snapshot),该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的,如果触发某些回调函数时需要用到 DOM 元素的状态，则将对比或计算的过程迁移至 getSnapshotBeforeUpdate，然后在 componentDidUpdate 中统一触发回调或更新状态。</p> <p>卸载阶段:</p> <p>componentWillUnmount: 当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903922453200904#heading-3" target="_blank" rel="noopener noreferrer">2019年17道高频React面试题及详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="ajax-请求放在-componentdidmount-里进行处理还是放在componentwillmount-里进行处理比较合适？（todo）"><a href="#ajax-请求放在-componentdidmount-里进行处理还是放在componentwillmount-里进行处理比较合适？（todo）" aria-hidden="true" class="header-anchor">#</a> Ajax 请求放在 componentDidMount 里进行处理还是放在componentWillMount 里进行处理比较合适？（todo）</h3> <p>React的异步请求到底应该放在哪个生命周期里,有人认为在componentWillMount中可以提前进行异步请求,避免白屏,其实这个观点是有问题的.
由于JavaScript中异步事件的性质，当您启动API调用时，浏览器会在此期间返回执行其他工作。当React渲染一个组件时，它不会等待componentWillMount它完成任何事情 - React继续前进并继续render,没有办法“暂停”渲染以等待数据到达。</p> <p>而且在componentWillMount请求会有一系列潜在的问题,首先,在服务器渲染时,如果在 componentWillMount 里获取数据，fetch data会执行两次，一次在服务端一次在客户端，这造成了多余的请求,其次,在React 16进行React Fiber重写后,componentWillMount可能在一次渲染中多次调用.</p> <p>目前官方推荐的异步请求是在componentDidmount中进行.</p> <p>如果有特殊需求需要提前请求,也可以在特殊情况下在constructor中请求:</p> <p>react 17之后componentWillMount会被废弃,仅仅保留UNSAFE_componentWillMount</p> <p>参考</p> <p><a href="https://juejin.cn/post/6844903922453200904#heading-3" target="_blank" rel="noopener noreferrer">2019年17道高频React面试题及详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="函数组件和类组件有什么区别？"><a href="#函数组件和类组件有什么区别？" aria-hidden="true" class="header-anchor">#</a> 函数组件和类组件有什么区别？</h3> <p>class组件特点：</p> <p>有组件实例</p> <p>有生命周期</p> <p>有 state 和 setState</p> <p>函数组件特点：</p> <p>没有组件实例</p> <p>没有生命周期</p> <p>没有 state 和 setState，只能接收 props</p> <p>函数组件是一个纯函数，执行完即销毁，无法存储 state</p> <p>class 组件存在的问题：</p> <p>大型组件很难拆分和重构，变得难以测试</p> <p>相同业务逻辑分散到各个方法中，可能会变得混乱</p> <p>复用逻辑可能变得复杂，如 HOC 、Render Props</p> <p>React 中更提倡函数式编程，因为函数更灵活，更易拆分，但函数组件太简单，所以出现了hook，hook就是用来增强函数组件功能的。</p> <p>参考：</p> <p><a href="https://zhuanlan.zhihu.com/p/339547131" target="_blank" rel="noopener noreferrer">React 函数组件和class组件区别 - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="为什么要使用hooks，解决了class什么问题？"><a href="#为什么要使用hooks，解决了class什么问题？" aria-hidden="true" class="header-anchor">#</a> 为什么要使用Hooks，解决了class什么问题？</h3> <p>class组件经历了<code>React.createClass</code>，<code>React.Component</code>,也经历了constructor的super，bind this到class filed的坑。</p> <p>生命周期的设计也越来越复杂多变，<strong>为了复用生命周期的逻辑，class组件是通过HOC来完成</strong>。但是HOC的滥用会带来额外的维护性，和不可理解性。</p> <p>而hooks的扁平处理可以完美解决这些问题。</p> <p>参考：</p> <p><a href="https://dev.to/tylermcginnis/why-react-hooks-51lj" target="_blank" rel="noopener noreferrer">Why React Hooks? - DEV Community<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://www.youtube.com/embed/eX_L39UvZes" target="_blank" rel="noopener noreferrer">Why React Hooks? - YouTube<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react中高阶组件的应用场景"><a href="#react中高阶组件的应用场景" aria-hidden="true" class="header-anchor">#</a> React中高阶组件的应用场景</h3> <p>1、权限控制</p> <p>利用高阶组件的 条件渲染 特性可以对页面进行权限控制，权限控制一般分为两个维度：页面级别 和 页面元素级别。这里以页面级别来举一个栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// HOC.js</span>
<span class="token keyword">function</span> <span class="token function">withAdminAuth</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
        state <span class="token operator">=</span> <span class="token punctuation">{</span>
            isAdmin<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">async</span> <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> currentRole <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getCurrentUserRole</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                isAdmin<span class="token punctuation">:</span> currentRole <span class="token operator">===</span> <span class="token string">'Admin'</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>isAdmin<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>您没有权限查看该页面，请联系管理员！<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>2、组件渲染性能追踪</p> <p>借助父组件子组件生命周期规则捕获子组件的生命周期，可以方便的对某个组件的渲染时间进行记录：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Home</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello World<span class="token punctuation">.</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">withTiming</span><span class="token punctuation">(</span><span class="token parameter">WrappedComponent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> WrappedComponent <span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span>componentWillMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>start <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">super</span><span class="token punctuation">.</span>componentDidMount <span class="token operator">&amp;&amp;</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>WrappedComponent<span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> 组件渲染时间为 </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>end <span class="token operator">-</span> <span class="token keyword">this</span><span class="token punctuation">.</span>start<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> ms</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withTiming</span><span class="token punctuation">(</span>Home<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>withTiming 是利用 反向继承 实现的一个高阶组件，功能是计算被包裹组件（这里是 Home 组件）的渲染时间。</p> <p>3、页面复用</p> <p>部分公共逻辑的抽取，比如fetch：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">withFetching</span> <span class="token operator">=</span> <span class="token parameter">fetching</span> <span class="token operator">=&gt;</span> <span class="token parameter">WrappedComponent</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">class</span> <span class="token class-name">extends</span> React<span class="token punctuation">.</span>Component <span class="token punctuation">{</span>
        state <span class="token operator">=</span> <span class="token punctuation">{</span>
            data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">async</span> <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetching</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
                data<span class="token punctuation">,</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>WrappedComponent data<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>data<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>this<span class="token punctuation">.</span>props<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// pages/page-a.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'science-fiction'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pages/page-b.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'action'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// pages/page-other.js</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token function">withFetching</span><span class="token punctuation">(</span><span class="token function">fetching</span><span class="token punctuation">(</span><span class="token string">'some-other-type'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>MovieList<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>参考：</p> <p><a href="https://juejin.cn/post/6844903782355042312#heading-23" target="_blank" rel="noopener noreferrer">React 中的高阶组件及其应用场景<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="使用-react-hooks-的同时为什么需要使用高阶组件？（todo）"><a href="#使用-react-hooks-的同时为什么需要使用高阶组件？（todo）" aria-hidden="true" class="header-anchor">#</a> 使用 React Hooks 的同时为什么需要使用高阶组件？（todo）</h3> <h3 id="完全用-hooks-的写法是否可以摒弃高阶组件的写法？（todo）"><a href="#完全用-hooks-的写法是否可以摒弃高阶组件的写法？（todo）" aria-hidden="true" class="header-anchor">#</a> 完全用 Hooks 的写法是否可以摒弃高阶组件的写法？（todo）</h3> <h3 id="怎么使用-hooks-替代高阶组件？（todo）"><a href="#怎么使用-hooks-替代高阶组件？（todo）" aria-hidden="true" class="header-anchor">#</a> 怎么使用 Hooks 替代高阶组件？（todo）</h3> <h3 id="useeffect对标哪些生命周期？"><a href="#useeffect对标哪些生命周期？" aria-hidden="true" class="header-anchor">#</a> useEffect对标哪些生命周期？</h3> <p>你可以把 useEffect Hook 看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。</p> <p>具体的对应表可以参考：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210510111644.png"> <p>具体的实例：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useState<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useRef<span class="token punctuation">,</span> memo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react'</span><span class="token punctuation">;</span>

<span class="token comment">// 使用 React.memo 实现类似 shouldComponentUpdate 的优化， React.memo 只对 props 进行浅比较</span>
<span class="token keyword">const</span> UseEffectExample <span class="token operator">=</span> <span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;===== UseStateExample render=======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 声明一个叫 “count” 的 state 变量。</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>fatherCount<span class="token punctuation">,</span> setFatherCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>fatherCount<span class="token punctuation">)</span>

    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 模拟 getDerivedStateFromProps</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token comment">// props.fatherCount 有更新，才执行对应的修改，没有更新执行另外的逻辑</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>fatherCount <span class="token operator">==</span> fatherCount <span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;======= 模拟 getDerivedStateFromProps=======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>fatherCount<span class="token punctuation">,</span> fatherCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token function">setFatherCount</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>fatherCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>fatherCount<span class="token punctuation">,</span> fatherCount<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

    <span class="token comment">// 模拟DidMount</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;=======只渲染一次(相当于DidMount)=======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 模拟DidUpdate</span>
    <span class="token keyword">const</span> mounted <span class="token operator">=</span> <span class="token function">useRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mounted<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mounted<span class="token punctuation">.</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            mounted<span class="token punctuation">.</span>current <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;======count 改变时才执行(相当于DidUpdate)=========&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token comment">// 模拟 Didmount和DidUpdate 、 unmount</span>
    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	<span class="token comment">// 在 componentDidMount，以及 count 更改时 componentDidUpdate 执行的内容</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;======初始化、或者 count 改变时才执行(相当于Didmount和DidUpdate)=========&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        	
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;====unmount=======&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span>

    <span class="token keyword">return</span> <span class="token punctuation">(</span>
        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>p<span class="token operator">&gt;</span>You clicked <span class="token punctuation">{</span>count<span class="token punctuation">}</span> times<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
                Click me
            <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>

            <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span>count2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
                Click me2
            <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> UseEffectExample<span class="token punctuation">;</span>

</code></pre></div><p>参考：</p> <p><a href="https://zh-hans.reactjs.org/docs/hooks-effect.html" target="_blank" rel="noopener noreferrer">使用 Effect Hook – React<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/u014607184/article/details/109744910" target="_blank" rel="noopener noreferrer">React Hooks 介绍及与传统 class 组件的生命周期函数对比_诗渊的博客-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react合成事件和原生事件的区别是？"><a href="#react合成事件和原生事件的区别是？" aria-hidden="true" class="header-anchor">#</a> React合成事件和原生事件的区别是？</h3> <p>React事件绑定时，发现React绑定时间有其自身的一套机制，那就是合成事件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;testDom&quot;</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">testDomClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
</code></pre></div><p>React合成事件一套机制：React并不是将click事件直接绑定在dom上面，而是采用事件冒泡的形式冒泡到document上面，然后React将事件封装给正式的函数处理运行和处理。</p> <p>React合成事件理解</p> <p>如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。</p> <p>当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。
而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）
所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。</p> <p>参考：</p> <p><a href="https://www.jianshu.com/p/8d8f9aa4b033" target="_blank" rel="noopener noreferrer">React 合成事件和原生事件的区别 - 简书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react中state和props的区别？"><a href="#react中state和props的区别？" aria-hidden="true" class="header-anchor">#</a> React中state和props的区别？</h3> <p>Props是一个从外部传进组件的参数，主要作用就是父组件向子组件传递数据，但是props对于使用它的组件来说是只读的，一旦赋值不能修改，只能通过外部组件主动传入新的props来重新渲染子组件</p> <p>State一个组件的显示形态可以由数据状态和外部参数决定，外部参数是props，数据状态就是state，首先，在组件初始化的时候，用this.state给组件设定一个初始的state，在第一次渲染的时候就会用这个数据来渲染组件，state不同于props一点时，state可以修改，通过this.setState()方法来修改state</p> <h3 id="react-中的-setstate-是同步还是异步？"><a href="#react-中的-setstate-是同步还是异步？" aria-hidden="true" class="header-anchor">#</a> React 中的 setState 是同步还是异步？</h3> <p>首先搞懂<a href="/library/react.html#react合成事件和原生事件的区别是？">react合成事件和原生事件的区别是？</a></p> <p>setState只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。</p> <p>setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p> <p>setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903922453200904#heading-3" target="_blank" rel="noopener noreferrer">2019年17道高频React面试题及详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-中-setstate-后想要拿到更新的state值应该怎么处理？"><a href="#react-中-setstate-后想要拿到更新的state值应该怎么处理？" aria-hidden="true" class="header-anchor">#</a> React 中 setState 后想要拿到更新的state值应该怎么处理？</h3> <p>可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。</p> <h3 id="setstate为何设计成异步的？如何实现的？"><a href="#setstate为何设计成异步的？如何实现的？" aria-hidden="true" class="header-anchor">#</a> setState为何设计成异步的？如何实现的？</h3> <p>为什么react大部分情况setState是异步的呢？假如所有setState是同步的，意味着每执行一次setState时（有可能一个同步代码中，多次setState），都重新vnode diff + dom修改，这对性能来说是极为不好的。如果是异步，则可以把一个同步代码中的多个setState合并成一次组件更新。</p> <p>具体实现可以参考：<a href="https://github.com/FunnyLiu/react-1/tree/readsource#thissetstate%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88" target="_blank" rel="noopener noreferrer">FunnyLiu/react-1 at readsource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>核心代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">ReactComponent</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">partialState<span class="token punctuation">,</span> callback</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueSetState</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>updater<span class="token punctuation">.</span><span class="token function">enqueueCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token string">'setState'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token function-variable function">enqueueSetState</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">publicInstance<span class="token punctuation">,</span> partialState</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找到需渲染组件</span>
    <span class="token keyword">var</span> internalInstance <span class="token operator">=</span> <span class="token function">getInternalInstanceReadyForUpdate</span><span class="token punctuation">(</span>
      publicInstance<span class="token punctuation">,</span>
      <span class="token string">'setState'</span><span class="token punctuation">,</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>internalInstance<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 每次都把新的state，push到队列中。</span>
    <span class="token comment">// 方便后面一次性更新组件时，聚合成最新的state</span>
    <span class="token keyword">var</span> queue <span class="token operator">=</span>
      internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">||</span>
      <span class="token punctuation">(</span>internalInstance<span class="token punctuation">.</span>_pendingStateQueue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>partialState<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 更新</span>
    <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>internalInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//代码位于ReactUpdateQueue.js</span>
<span class="token keyword">function</span> <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token parameter">internalInstance</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ReactUpdates<span class="token punctuation">.</span><span class="token function">enqueueUpdate</span><span class="token punctuation">(</span>internalInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//代码位于ReactUpdates.js</span>
<span class="token keyword">function</span> <span class="token function">enqueueUpdate</span><span class="token punctuation">(</span><span class="token parameter">component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">ensureInjected</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 未开启事务流程：开启事务 + 更新组件</span>
  <span class="token comment">// 在生命周期以及合成事件情况下，isBatchingUpdates=true</span>
  <span class="token comment">// 在setTimeout以及原生DOM事件情况下，isBatchingUpdates=false</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>batchingStrategy<span class="token punctuation">.</span>isBatchingUpdates<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    batchingStrategy<span class="token punctuation">.</span><span class="token function">batchedUpdates</span><span class="token punctuation">(</span>enqueueUpdate<span class="token punctuation">,</span> component<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 已开启事务流程：放到脏数组中（组件不更新 + this.state不变），等待更新</span>
  dirtyComponents<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    component<span class="token punctuation">.</span>_updateBatchNumber <span class="token operator">=</span> updateBatchNumber <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>以上是setState的关键代码，batchingStrategy.batchedUpdates里面用到了事务机制。 setState 本身的方法调用是同步的，但是调用了setState不标志这react的 state 立即更新，这个更新是要根据当前环境执行上下文来判断的，如果处于batchedUpdate的情况下，那么state的不是当前立马更新的，而不处于batchedUpdate的情况下，那么他就有可能立马更新的。</p> <p>参考：</p> <p><a href="https://lq782655835.github.io/blogs/react/react-code-3.setState.html" target="_blank" rel="noopener noreferrer">React setState是异步吗 | springleo's blog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-中受控组件和非受控组件的区别？"><a href="#react-中受控组件和非受控组件的区别？" aria-hidden="true" class="header-anchor">#</a> React 中受控组件和非受控组件的区别？</h3> <p>在一个受控组件中，表单数据是由 React 组件来管理的。另一种替代方案是使用非受控组件，这时表单数据将交由 DOM 节点来处理。</p> <p>举个例子，非受控组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Form</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token comment">/** 提交时候获取数据 */</span>  
  <span class="token function-variable function">handleSubmitClick</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
    <span class="token comment">// 检测数据提示然后</span>
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span>  <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> ref<span class="token operator">=</span><span class="token punctuation">{</span><span class="token parameter">input</span> <span class="token operator">=&gt;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_name <span class="token operator">=</span> input<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmitClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>Sign up<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>受控组件：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">NameForm</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>value<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">this</span><span class="token punctuation">.</span>handleChange <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleChange</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">handleSubmit</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleChange</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>value<span class="token punctuation">:</span> event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">handleSubmit</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">'提交的名字: '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    event<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>form onSubmit<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleSubmit<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>label<span class="token operator">&gt;</span>
          名字<span class="token punctuation">:</span>
          <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;text&quot;</span> value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>value<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>label<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">&quot;submit&quot;</span> value<span class="token operator">=</span><span class="token string">&quot;提交&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>form<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>非受控组件更方便快捷，代码量小，但是控制能力比较弱。受控组件的控制能力强，但是代码量会比较多，在开发中应该权衡需求，进度进行相应的选择。</p> <p>参考：</p> <p><a href="https://segmentfault.com/a/1190000022925043" target="_blank" rel="noopener noreferrer">漫谈受控与非受控组件 - SegmentFault 思否<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://zh-hans.reactjs.org/docs/forms.html#controlled-components" target="_blank" rel="noopener noreferrer">表单 – React<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://zh-hans.reactjs.org/docs/uncontrolled-components.html" target="_blank" rel="noopener noreferrer">非受控组件 – React<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="在哪些场景应该使用非受控组件？"><a href="#在哪些场景应该使用非受控组件？" aria-hidden="true" class="header-anchor">#</a> 在哪些场景应该使用非受控组件？</h3> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210510110650.png"> <p>非受控组件更方便快捷，代码量小，但是控制能力比较弱，一些简单的功能场景下可以使用，但是还是建议使用受控组件。</p> <p>参考</p> <p><a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/?spm=a2c6h.12873639.0.0.1a7665266cJt7d" target="_blank" rel="noopener noreferrer">Controlled and uncontrolled form inputs in React don't have to be complicated - Gosha Arinich<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react组件之间怎么通信？"><a href="#react组件之间怎么通信？" aria-hidden="true" class="header-anchor">#</a> React组件之间怎么通信？</h3> <p>父组件向子组件通讯: 父组件可以向子组件通过传 props 的方式，向子组件进行通讯</p> <p>子组件向父组件通讯: props+回调的方式,父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中</p> <p>兄弟组件通信: 找到这两个兄弟节点共同的父节点,结合上面两种方式由父节点转发信息进行通信</p> <p>跨层级通信: Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言,对于跨越多层的全局数据通过Context通信再适合不过</p> <p>发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引入event模块进行通信</p> <p>全局状态管理工具: 借助Redux或者Mobx等全局状态管理工具进行通信,这种工具会维护一个全局状态中心Store,并根据不同的事件产生新的状态</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903922453200904#heading-3" target="_blank" rel="noopener noreferrer">2019年17道高频React面试题及详解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="在-react-中，refs-的作用是什么？"><a href="#在-react-中，refs-的作用是什么？" aria-hidden="true" class="header-anchor">#</a> 在 React 中，refs 的作用是什么？</h3> <p>Refs 可以用于获取一个 DOM 节点或者 React 组件的引用。何时使用 refs 的好的示例有管理焦点/文本选择，触发命令动画，或者和第三方 DOM 库集成。你应该避免使用String 类型的 Refs 和内联的 ref 回调。Refs 回调是 React 所推荐的</p> <h3 id="是否了解shouldcomponentupdate，做什么的？"><a href="#是否了解shouldcomponentupdate，做什么的？" aria-hidden="true" class="header-anchor">#</a> 是否了解shouldComponentUpdate，做什么的？</h3> <p>在class组件中，我们可以通过shouldComponentUpdate阻止不必要的re-render：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">DemoLoader</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>

  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> nextProps<span class="token punctuation">.</span>demoUrl <span class="token operator">!==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>demoUrl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> domoUrl <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;demoloader&quot;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token punctuation">{</span>demoUrl<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>在更新数据的时候用setState修改整个数据，数据变了之后，遍历的时候所有内容都要被重新渲染，数据量少还好，数据量大就会严重影响性能</p> <p>解决办法：</p> <p>1.shouldComponentUpdate 在渲染前进行判断组件是否更新，更新了再渲染</p> <p>2.pureComponent（纯组件）省去了虚拟dom生成和对比的过程  在类组件中使用</p> <p>3.react.memo() 类似于纯组件 在无状态组件中使用</p> <h3 id="hook函数式组件怎么实现shouldcomponentupdate？"><a href="#hook函数式组件怎么实现shouldcomponentupdate？" aria-hidden="true" class="header-anchor">#</a> hook函数式组件怎么实现shouldComponentUpdate？</h3> <p>为了解决函数组件中的优化问题，React在16.6版本增加了React.memo。</p> <p>React.memo是一个高阶组件，类似于React.PureComponent，只不过用于函数组件而非class组件。
如果你的函数组件在相同props下渲染出相同结果，你可以把它包裹在React.memo中来通过缓存渲染结果来实现性能优化。这意味着React会跳过组件渲染，而使用上次渲染结果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> DemoLoader <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token parameter">props</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">{</span> demoUrl <span class="token punctuation">}</span> <span class="token operator">=</span> props<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;demoloader&quot;</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>iframe src<span class="token operator">=</span><span class="token punctuation">{</span>demoUrl<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">prevProps<span class="token punctuation">,</span> nextProps</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> prevProps<span class="token punctuation">.</span>demoUrl <span class="token operator">===</span> nextProps<span class="token punctuation">.</span>demoUrl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>参考：</p> <p><a href="https://juejin.cn/post/6844904006075023367" target="_blank" rel="noopener noreferrer">React.memo: 在函数组件中实现'shouldComponentUpdate'<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="class组件怎么使用hooks？"><a href="#class组件怎么使用hooks？" aria-hidden="true" class="header-anchor">#</a> class组件怎么使用hooks？</h3> <p>class组件使用不了hooks，所以可以通过高阶组件，包一层给class用：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useErrorHandler <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react-error-boundary&quot;</span><span class="token punctuation">;</span>
<span class="token comment">//为了给class用上hook，只能如此</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">withErrorHandler</span><span class="token punctuation">(</span><span class="token parameter">Component</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">WithErrorHandler</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> handleError <span class="token operator">=</span> <span class="token function">useErrorHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>Component <span class="token punctuation">{</span><span class="token operator">...</span>props<span class="token punctuation">}</span> handleError<span class="token operator">=</span><span class="token punctuation">{</span>handleError<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="hook遇到不更新的问题吗？怎么解决？"><a href="#hook遇到不更新的问题吗？怎么解决？" aria-hidden="true" class="header-anchor">#</a> hook遇到不更新的问题吗？怎么解决？</h3> <p>闭包问题经常捕获一个未更新的变量，一个有效的解决闭包问题的方法是在React hooks里设置正确的依赖，或者用函数的方式更新state。</p> <p>先看一个useEffect的问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">WatchCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Increase
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>点击多次后，count 还是0。</p> <p>这个问题的本质可以看看下面的例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span><span class="token parameter">incBy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">+=</span> incBy<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Current value is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
  <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">[</span>increment<span class="token punctuation">,</span> log<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>increment<span class="token punctuation">,</span> log<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 1</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 2</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 3</span>
<span class="token comment">// Does not work!</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// logs &quot;Current value is 0&quot;</span>
</code></pre></div><p>尽管多次调用increment增加vulue的值，message变量也没有保持更新。</p> <p>需要改为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span><span class="token parameter">incBy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    value <span class="token operator">+=</span> incBy<span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> message <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Current value is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> <span class="token punctuation">[</span>increment<span class="token punctuation">,</span> log<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>increment<span class="token punctuation">,</span> log<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createIncrement</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 1</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 2</span>
<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// logs 3</span>
<span class="token comment">// Works!</span>
<span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// logs &quot;Current value is 3&quot;</span>
</code></pre></div><p>所以刚才的useEffect应该改为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">WatchCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> id <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Count is: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>count<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">clearInterval</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Increase
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过依赖计算，来保证其执行。</p> <p>再看看useState遇到同样的问题：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">DelayedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClickAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClickAsync<span class="token punctuation">}</span><span class="token operator">&gt;</span>Increase async<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要改为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">DelayedCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClickAsync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token parameter">count</span> <span class="token operator">=&gt;</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">handleClickSync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span>count<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClickAsync<span class="token punctuation">}</span><span class="token operator">&gt;</span>Increase async<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>handleClickSync<span class="token punctuation">}</span><span class="token operator">&gt;</span>Increase sync<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>参考：</p> <p><a href="https://zhuanlan.zhihu.com/p/351069053" target="_blank" rel="noopener noreferrer">警惕React hooks中的闭包 - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react怎么控制渲染顺序？"><a href="#react怎么控制渲染顺序？" aria-hidden="true" class="header-anchor">#</a> React怎么控制渲染顺序？</h3> <p>第一种方式使用标识位，在父组件进行控制。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210510103900.png"> <p>第二种使用React.lazy在后面的流程中去渲染其他的</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> lazy<span class="token punctuation">,</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> <span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&quot;./OtherComponent&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>Loading<span class="token operator">...</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>OtherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第三种是基于React17的concurrent模式去完成对调度的精细控制。</p> <p>目前是实验版本：</p> <div class="language-js extra-class"><pre class="language-js"><code>ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>unstable_ConcurrentMode<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>unstable_ConcurrentMode<span class="token operator">&gt;</span><span class="token punctuation">,</span>
  rootElement
<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>具体的调度方式待定，由于实验版本就不深究了。</p> <p>参考：</p> <p><a href="https://www.796t.com/post/NjR6NmU=.html" target="_blank" rel="noopener noreferrer">React元件渲染的控制順序 - JAVASCRIPT _程式人生<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903821433372680" target="_blank" rel="noopener noreferrer">精读《Scheduling in React》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="做过哪些react方面的性能优化？"><a href="#做过哪些react方面的性能优化？" aria-hidden="true" class="header-anchor">#</a> 做过哪些React方面的性能优化？</h3> <p>说到性能优化首先需要排查出性能问题。通过开发者工具可以查看组件渲染时间和原因。</p> <p><a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener noreferrer">React Profiler 介绍 – React Blog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>查看某个组件某次渲染的原因以及花费的时间：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210426174108.png"> <p>然后找到需要优化的组件，再做优化：</p> <h4 id="使用-react-memo-来缓存组件"><a href="#使用-react-memo-来缓存组件" aria-hidden="true" class="header-anchor">#</a> 使用 React.Memo 来缓存组件</h4> <p>提升应用程序性能的一种方法是实现 memoization。Memoization 是一种优化技术，主要通过存储昂贵的函数调用的结果，并在再次发生相同的输入时返回缓存的结果，以此来加速程序。<br>
父组件的每次状态更新，都会导致子组件重新渲染，即使传入子组件的状态没有变化，为了减少重复渲染，我们可以使用 React.memo 来缓存组件，这样只有当传入组件的状态值发生变化时才会重新渲染。如果传入相同的值，则返回缓存的组件。示例如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>value<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Memo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//   return &lt;DualCounter /&gt;;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>DualCounter2 <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//这种情况下，每点击一个按钮，都会引起两个组件的重新渲染</span>
<span class="token keyword">function</span> <span class="token function">DualCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//React.memo和useCallback的组合下，就可以达到只渲染自己的目的</span>
<span class="token keyword">const</span> CountButton2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'render'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">DualCounter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment1 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Memo<span class="token punctuation">;</span>


</code></pre></div><h4 id="使用-usememo-缓存大量的计算"><a href="#使用-usememo-缓存大量的计算" aria-hidden="true" class="header-anchor">#</a> 使用 useMemo 缓存大量的计算</h4> <p>参考demo：<a href="https://github.com/FunnyLiu/reactDemo/blob/master/useCallback/components/Memo.jsx#L1" target="_blank" rel="noopener noreferrer">reactDemo/Memo.jsx at master · FunnyLiu/reactDemo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>有时渲染是不可避免的，但如果您的组件是一个功能组件，重新渲染会导致每次都调用大型计算函数，这是非常消耗性能的，我们可以使用新的 useMemo 钩子来 “记忆” 这个计算函数的计算结果。这样只有传入的参数发生变化后，该计算函数才会重新调用计算新的结果。<br>
通过这种方式，您可以使用从先前渲染计算的结果来挽救昂贵的计算耗时。总体目标是减少 JavaScript 在呈现组件期间必须执行的工作量，以便主线程被阻塞的时间更短。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 避免这样做</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> someProp <span class="token operator">=</span> <span class="token function">heavyCalculation</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent someProp<span class="token operator">=</span><span class="token punctuation">{</span>someProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token punctuation">}</span>
  
<span class="token comment">// 只有 `props.item` 改变时someProp的值才会被重新计算</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> someProp <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">heavyCalculation</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>item<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent someProp<span class="token operator">=</span><span class="token punctuation">{</span>someProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span> 
<span class="token punctuation">}</span> 

</code></pre></div><h4 id="使用-react-purecomponent-shouldcomponentupdate"><a href="#使用-react-purecomponent-shouldcomponentupdate" aria-hidden="true" class="header-anchor">#</a> 使用 React.PureComponent , shouldComponentUpdate</h4> <p>父组件状态的每次更新，都会导致子组件的重新渲染，即使是传入相同 props。但是这里的重新渲染不是说会更新 DOM, 而是每次都会调用 diif 算法来判断是否需要更新 DOM。这对于大型组件例如组件树来说是非常消耗性能的。<br>
在这里我们就可以使用 React.PureComponent , shouldComponentUpdate 生命周期来确保只有当组件 props 状态改变时才会重新渲染。如下例子:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">ParentComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>SomeComponent someProp<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>somePropValue<span class="token punctuation">}</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>AnotherComponent someOtherProp<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>someOtherPropValue<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
   <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
 <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">SomeComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>someProp<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 只要props.somePropValue 发生变化，不论props.someOtherPropValue是否发生变化该组件都会发生变化</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">AnotherComponent</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>someOtherProp<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>  
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><p>我们可以使用 React.PureComponent 或 shouldComponentUpdate 进行如下优化：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 第一种优化</span>
<span class="token keyword">class</span> <span class="token class-name">AnotherComponent</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>PureComponent</span> <span class="token punctuation">{</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>someOtherProp<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>   
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//第二种优化</span>
<span class="token keyword">class</span> <span class="token class-name">AnotherComponent</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token parameter">nextProps</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">!==</span> nextProps
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>someOtherProp<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>   
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>PureComponent 会进行浅比较来判断组件是否应该重新渲染，对于传入的基本类型 props，只要值相同，浅比较就会认为相同，对于传入的引用类型 props，浅比较只会认为传入的 props 是不是同一个引用，如果不是，哪怕这两个对象中的内容完全一样，也会被认为是不同的 props。<br>
需要注意的是在对于那些可以忽略渲染时间的组件或者是状态一直变化的组件则要谨慎使用 PureComponent，因为进行浅比较也会花费时间，这种优化更适用于大型的展示组件上。大型组件也可以拆分成多个小组件，并使用 memo 来包裹小组件，也可以提升性能。</p> <h4 id="避免使用内联对象"><a href="#避免使用内联对象" aria-hidden="true" class="header-anchor">#</a> 避免使用内联对象</h4> <p>使用内联对象时，react 会在每次渲染时重新创建对此对象的引用，这会导致接收此对象的组件将其视为不同的对象, 因此，该组件对于 prop 的浅层比较始终返回 false, 导致组件一直重新渲染。<br>
许多人使用的内联样式的间接引用，就会使组件重新渲染，可能会导致性能问题。为了解决这个问题，我们可以保证该对象只初始化一次，指向相同引用。另外一种情况是传递一个对象，同样会在渲染时创建不同的引用，也有可能导致性能问题，我们可以利用 ES6 扩展运算符将传递的对象解构。这样组件接收到的便是基本类型的 props，组件通过浅层比较发现接受的 prop 没有变化，则不会重新渲染。示例如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// Don't do this!</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> aProp <span class="token operator">=</span> <span class="token punctuation">{</span> someProp<span class="token punctuation">:</span> <span class="token string">'someValue'</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">{</span> margin<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">}</span> aProp<span class="token operator">=</span><span class="token punctuation">{</span>aProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// Do this instead :)</span>
<span class="token keyword">const</span> styles <span class="token operator">=</span> <span class="token punctuation">{</span> margin<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> aProp <span class="token operator">=</span> <span class="token punctuation">{</span> someProp<span class="token punctuation">:</span> <span class="token string">'someValue'</span> <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span>styles<span class="token punctuation">}</span> <span class="token punctuation">{</span><span class="token operator">...</span>aProp<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>


</code></pre></div><h4 id="避免使用匿名函数"><a href="#避免使用匿名函数" aria-hidden="true" class="header-anchor">#</a> 避免使用匿名函数</h4> <p>虽然匿名函数是传递函数的好方法（特别是需要用另一个 prop 作为参数调用的函数），但它们在每次渲染上都有不同的引用。这类似于上面描述的内联对象。为了保持对作为 prop 传递给 React 组件的函数的相同引用，您可以将其声明为类方法（如果您使用的是基于类的组件）或使用 useCallback 钩子来帮助您保持相同的引用（如果您使用功能组件）。<br>
当然，有时内联匿名函数是最简单的方法，实际上并不会导致应用程序出现性能问题。这可能是因为在一个非常 “轻量级” 的组件上使用它，或者因为父组件实际上必须在每次 props 更改时重新渲染其所有内容。因此不用关心该函数是否是不同的引用，因为无论如何，组件都会重新渲染。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 避免这样做</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 优化方法一</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handleChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>props<span class="token punctuation">.</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 优化方法二</span>
<span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">handleChange</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
   <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>id<span class="token punctuation">)</span> 
  <span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">&lt;</span>AnotherComponent onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>


</code></pre></div><h4 id="延迟加载不是立即需要的组件"><a href="#延迟加载不是立即需要的组件" aria-hidden="true" class="header-anchor">#</a> 延迟加载不是立即需要的组件</h4> <p>延迟加载实际上不可见（或不是立即需要）的组件，React 加载的组件越少，加载组件的速度就越快。因此，如果您的初始渲染感觉相当粗糙，则可以在初始安装完成后通过在需要时加载组件来减少加载的组件数量。同时，这将允许用户更快地加载您的平台 / 应用程序。最后，通过拆分初始渲染，您将 JS 工作负载拆分为较小的任务，这将为您的页面提供响应的时间。这可以使用新的 React.Lazy 和 React.Suspense 轻松完成。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 延迟加载不是立即需要的组件</span>
<span class="token keyword">const</span> MUITooltip <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@material-ui/core/Tooltip'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Tooltip</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> children<span class="token punctuation">,</span> title <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Suspense fallback<span class="token operator">=</span><span class="token punctuation">{</span>children<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>MUITooltip title<span class="token operator">=</span><span class="token punctuation">{</span>title<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>children<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>MUITooltip<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Suspense<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Tooltip title<span class="token operator">=</span><span class="token punctuation">{</span>props<span class="token punctuation">.</span>title<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>AnotherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>Tooltip<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


</code></pre></div><h4 id="调整-css-而不是强制组件加载和卸载"><a href="#调整-css-而不是强制组件加载和卸载" aria-hidden="true" class="header-anchor">#</a> 调整 CSS 而不是强制组件加载和卸载</h4> <p>渲染成本很高，尤其是在需要更改 DOM 时。每当你有某种手风琴或标签功能，例如想要一次只能看到一个项目时，你可能想要卸载不可见的组件，并在它变得可见时将其重新加载。如果加载 / 卸载的组件 “很重”，则此操作可能非常消耗性能并可能导致延迟。在这些情况下，最好通过 CSS 隐藏它，同时将内容保存到 DOM。<br>
尽管这种方法并不是万能的，因为安装这些组件可能会导致问题（即组件与窗口上的无限分页竞争），但我们应该选择在不是这种情况下使用调整 CSS 的方法。另外一点，将不透明度调整为 0 对浏览器的成本消耗几乎为 0（因为它不会导致重排），并且应尽可能优先于更该 visibility 和 display。<br>
有时在保持组件加载的同时通过 CSS 隐藏可能是有益的，而不是通过卸载来隐藏。对于具有显著的加载 / 卸载时序的重型组件而言，这是有效的性能优化手段。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 避免对大型的组件频繁对加载和卸载</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>view<span class="token punctuation">,</span> setView<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'view1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> view <span class="token operator">===</span> <span class="token string">'view1'</span> <span class="token operator">?</span> <span class="token operator">&lt;</span>SomeComponent <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token punctuation">:</span> <span class="token operator">&lt;</span>AnotherComponent <span class="token operator">/</span><span class="token operator">&gt;</span>  
<span class="token punctuation">}</span>

<span class="token comment">// 使用该方式提升性能和速度</span>
<span class="token keyword">const</span> visibleStyles <span class="token operator">=</span> <span class="token punctuation">{</span> opacity<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> hiddenStyles <span class="token operator">=</span> <span class="token punctuation">{</span> opacity<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>view<span class="token punctuation">,</span> setView<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'view1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>SomeComponent style<span class="token operator">=</span><span class="token punctuation">{</span>view <span class="token operator">===</span> <span class="token string">'view1'</span> <span class="token operator">?</span> visibleStyles <span class="token punctuation">:</span> hiddenStyles<span class="token punctuation">}</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>AnotherComponent style<span class="token operator">=</span><span class="token punctuation">{</span>view <span class="token operator">!==</span> <span class="token string">'view1'</span> <span class="token operator">?</span> visibleStyles <span class="token punctuation">:</span> hiddenStyles<span class="token punctuation">}</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h4 id="使用-react-fragment-避免添加额外的-dom"><a href="#使用-react-fragment-避免添加额外的-dom" aria-hidden="true" class="header-anchor">#</a> 使用 React.Fragment 避免添加额外的 DOM</h4> <p>有些情况下，我们需要在组件中返回多个元素，例如下面的元素，但是在 react 规定组件中必须有一个父元素。</p> <div class="language-html extra-class"><pre class="language-html"><code>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Hello world!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Hello there!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Hello there again!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>


</code></pre></div><p>因此你可能会这样做, 但是这样做的话即使一切正常，也会创建额外的不必要的 div。这会导致整个应用程序内创建许多无用的元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there again<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


</code></pre></div><p>实际上页面上的元素越多，加载所需的时间就越多。为了减少不必要的加载时间，我们可以使 React.Fragment 来避免创建不必要的元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
            <span class="token operator">&lt;</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello world<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>Hello there again<span class="token operator">!</span><span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>React<span class="token punctuation">.</span>Fragment<span class="token operator">&gt;</span>
        <span class="token punctuation">)</span>
<span class="token punctuation">}</span>


</code></pre></div><p>参考：</p> <p><a href="https://juejin.cn/post/6844903924302888973" target="_blank" rel="noopener noreferrer">React性能优化的8种方式了解一下？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="uselayouteffect和useeffect的区别是？"><a href="#uselayouteffect和useeffect的区别是？" aria-hidden="true" class="header-anchor">#</a> useLayoutEffect和useEffect的区别是？</h3> <p>useLayoutEffect是同步调用，发生在浏览器把内容渲染到界面前。</p> <p>useEffect是异步调用，发生在浏览器把内容渲染到界面后。</p> <p>参考：</p> <p><a href="https://pengfeixc.com/blog/605af93600f1525af762a725" target="_blank" rel="noopener noreferrer">useEffect和useLayoutEffect的区别 | 王鹏飞<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react组件什么情况下会重新re-render？"><a href="#react组件什么情况下会重新re-render？" aria-hidden="true" class="header-anchor">#</a> react组件什么情况下会重新re-render？</h3> <p>有四个原因会导致组件 re-render：状态变化、父组件 re-render、Context 变化和 Hooks 变化</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="如何排查react组件re-render？"><a href="#如何排查react组件re-render？" aria-hidden="true" class="header-anchor">#</a> 如何排查react组件re-render？</h3> <p>1）借助 React Devtools Chrome 插件，在「设置 &gt; Profiler」里开启「Record why each component rendered while profiling」，再通过录制的方式排查，就能知道每个 re-render 的原因</p> <p>2）借助外部工具，比如 why-did-you-render 或 tilg。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="如何避免父组件-re-render-导致的-re-render？"><a href="#如何避免父组件-re-render-导致的-re-render？" aria-hidden="true" class="header-anchor">#</a> 如何避免父组件 re-render 导致的 re-render？</h3> <p>React.memo！使用 React.memo 后的组件只有 props 变更才会触发 re-render</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="为什么react-memo不是默认行为？"><a href="#为什么react-memo不是默认行为？" aria-hidden="true" class="header-anchor">#</a> 为什么React.memo不是默认行为？</h3> <p>因为作为开发者，我们往往高估了重新渲染的成本。对于 props 很多且没有很多子组件的组件来说，相比 re-render，检查 props 是否变更带来的消耗可能更大。因此，如果对每个组件都进行 React.memo，可能会产生反效果。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="如何降低re-render的范围？"><a href="#如何降低re-render的范围？" aria-hidden="true" class="header-anchor">#</a> 如何降低re-render的范围？</h3> <p>在使用 React.memo() 之前，还可以考虑两个方法，让 re-render 保持在一个很小的范围之内。</p> <p>1）把状态往下移，把可变的部分拆到平行组件里，比如 <code>&lt;Changed /&gt;&lt;Expansive /&gt;</code>，确保更新只在 <code>&lt;Changed /&gt;</code> 组件里；</p> <p>2）把内容往上提，把可变的部分拆到父级组件里，比如 <code>&lt;Changed&gt;&lt;Expansive /&gt;&lt;/Changed&gt;</code>，在 <code>&lt;Changed /&gt;</code> 变更时只要 props.children 不变化，就不会触发子组件的 re-render。用其他 props 属性可以吗？可以！比如 <code>&lt;Changed left={&lt;Expansive1 /&gt;} right={&lt;Expansive2 /&gt;} /&gt;，&lt;Changed /&gt;</code> re-render 并不会导致 <code>&lt;Expansive /&gt;</code> re-render。这种方法叫「componets as props」。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="什么时候该用usecallback和usememo？"><a href="#什么时候该用usecallback和usememo？" aria-hidden="true" class="header-anchor">#</a> 什么时候该用useCallback和useMemo？</h3> <p>1）React.memo 过的组件的 props 应该用，因为他们只有 props 变更时才会 re-render，所以反之非 React.memo 过的组件的 props 无需使用，因为都会 re-render，用了也白用，</p> <p>2）useEffect、useMemo、useCallback 中非原始值的依赖应该用</p> <p>3）给 Pure Component 的非原始值 props 应该用，</p> <p>4）重消耗（比如生成渲染树）的部分应该用，反之轻消耗不要用，因为 useMemo/useCallback 本身也有消耗。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="如何规避函数参数每次生成一个新的匿名函数？"><a href="#如何规避函数参数每次生成一个新的匿名函数？" aria-hidden="true" class="header-anchor">#</a> 如何规避函数参数每次生成一个新的匿名函数？</h3> <p>使用 useCallback 要小心 dep 更新导致返回的函数更新。举个例子，我们遇到 <code>onClick={() =&gt; setCount(count+1)}</code> 时，由于考虑每次生成一个新的匿名函数，可能会把他改成 <code>useCallback(() =&gt; setCount(count+1), [count])</code>，此时 count 更新会导致 useCallback 返回新的匿名函数，解法是用 Functional Update，用 <code>useCallback(() =&gt; setCount(prevCount =&gt; prevCount + 1), [])</code>。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/BPFJSkvv_UPMux0dSZuh-A" target="_blank" rel="noopener noreferrer">关于 React Re-Render<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="usecallback用过没？使用场景是？"><a href="#usecallback用过没？使用场景是？" aria-hidden="true" class="header-anchor">#</a> useCallback用过没？使用场景是？</h3> <p>useMemo和useCallback都会在组件第一次渲染的时候执行，之后会在其依赖的变量发生改变时再次执行；并且这两个hooks都返回缓存的值，useMemo返回缓存的变量，useCallback返回缓存的函数。</p> <p><code>useCallback(fn, deps)</code>相当于<code>useMemo(() =&gt; fn, deps)</code></p> <h4 id="_1、普通情况下不需要使用"><a href="#_1、普通情况下不需要使用" aria-hidden="true" class="header-anchor">#</a> 1、普通情况下不需要使用</h4> <p>比如以下<a href="https://github.com/FunnyLiu/reactDemo/blob/master/useCallback/components/Simple.jsx#L1" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>


<span class="token keyword">function</span> <span class="token function">Simple</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//这种简单套个壳的意义没有，适得其反</span>
  <span class="token keyword">const</span> onChange <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">evt</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">setVal</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//普通场景下下面的方式性能更好</span>
<span class="token comment">//   const onChange = (evt) =&gt; {</span>
<span class="token comment">//     setVal(evt.target.value);</span>
<span class="token comment">//   };</span>

  <span class="token keyword">return</span> <span class="token operator">&lt;</span>input val<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span> onChange<span class="token operator">=</span><span class="token punctuation">{</span>onChange<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Simple<span class="token punctuation">;</span>

</code></pre></div><p>这种情况下用了反而性能更低</p> <h4 id="_2、解决引用问题"><a href="#_2、解决引用问题" aria-hidden="true" class="header-anchor">#</a> 2、解决引用问题</h4> <p>解决useEffect的依赖项为引用类型时，即使内容没有改变但是依旧触发update的问题。</p> <p>比如以下<a href="https://github.com/FunnyLiu/reactDemo/blob/master/useCallback/components/Effect.jsx#L1" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//   return &lt;Blub /&gt;;</span>
  <span class="token comment">// return &lt;Blub2 /&gt;;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>Blub3 <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//useEffect 将对每次渲染中对 options 进行引用相等性检查，并且由于JavaScript的工作方式，</span>
  <span class="token comment">//每次渲染 options 都是新的，所以当React测试 options 是否在渲染之间发生变化时，</span>
  <span class="token comment">//它将始终计算为 true，意味着每次渲染后都会调用 useEffect 回调，而不是仅在 bar 和 baz 更改时调用</span>
  React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>options<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>foobar<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Blub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">//每一次Foo组件重新渲染，其子组件Child都会重新useEffect</span>
    <span class="token function">setVal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Foo bar<span class="token operator">=</span><span class="token string">&quot;bar value&quot;</span> baz<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span> val<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>click<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//有两种方式解决上面的问题</span>

<span class="token comment">// 第一种方式是</span>
<span class="token keyword">function</span> <span class="token function">Foo2</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//但是有一种情况下：如果 bar 或者 baz 是（非原始值）对象、数组、函数等，这不是一个实际的解决方案</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>bar<span class="token punctuation">,</span> baz<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// we want this to re-run if bar or baz change</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>foobar<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Blub2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">setVal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Foo2 bar<span class="token operator">=</span><span class="token string">&quot;bar value&quot;</span> baz<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span> val<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token comment">/* 但是有一种情况下：如果 bar 或者 baz 是（非原始值）对象、数组、函数等，这不是一个实际的解决方案 */</span><span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token comment">/* &lt;Foo2 bar=&quot;bar value&quot; baz={[3]} val={val} /&gt; */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>click<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//第二种方式就是useMemo和useCallback了</span>
<span class="token keyword">function</span> <span class="token function">Foo3</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  React<span class="token punctuation">.</span><span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token punctuation">{</span> bar<span class="token punctuation">,</span> baz <span class="token punctuation">}</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>bar<span class="token punctuation">,</span> baz<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// we want this to re-run if bar or baz change</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>foobar<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Blub3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setVal<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    num <span class="token operator">=</span> num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">setVal</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token comment">//   const bar = () =&gt; {};</span>
<span class="token comment">//   const baz = [3];</span>
  <span class="token comment">// 通过这种方法解决引用类型的重新渲染问题</span>
  <span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token comment">/* &lt;Foo3 bar=&quot;bar value&quot; baz={3} val={val} /&gt; */</span><span class="token punctuation">}</span>
      <span class="token punctuation">{</span><span class="token comment">/* 故意使用引用类型 */</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>Foo2 bar<span class="token operator">=</span><span class="token punctuation">{</span>bar<span class="token punctuation">}</span> baz<span class="token operator">=</span><span class="token punctuation">{</span>baz<span class="token punctuation">}</span> val<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>click<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Effect<span class="token punctuation">;</span>

</code></pre></div><p>当使用useEffect等hooks的变化依赖是引用类型值时，即使变化的不是依赖项，也会导致重复渲染。可以通过useCallback和useMemo来解决。</p> <h4 id="_3、配合react-memo优化不必要的渲染"><a href="#_3、配合react-memo优化不必要的渲染" aria-hidden="true" class="header-anchor">#</a> 3、配合React.memo优化不必要的渲染</h4> <p>所有依赖本地状态或props来创建函数，需要使用到缓存函数的地方，都是useCallback的应用场景。</p> <p>比如以下<a href="https://github.com/FunnyLiu/reactDemo/blob/master/useCallback/components/Memo.jsx#L1" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Memo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//   return &lt;DualCounter /&gt;;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>DualCounter2 <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//这种情况下，每点击一个按钮，都会引起两个组件的重新渲染</span>
<span class="token keyword">function</span> <span class="token function">DualCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//React.memo和useCallback的组合下，就可以达到只渲染自己的目的</span>
<span class="token keyword">const</span> CountButton2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'render'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">DualCounter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment1 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Memo<span class="token punctuation">;</span>

</code></pre></div><p>使用两个相同组件，count变化后，两个组件都会渲染，其实我们只想渲染其中的一个，这种情况下利用React.memo和useCallback，就可以优化性能。</p> <p>参考：</p> <p><a href="https://jancat.github.io/post/2019/translation-usememo-and-usecallback/" target="_blank" rel="noopener noreferrer">【译】什么时候使用 useMemo 和 useCallback - 键落云起<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="usememo用过没？使用场景是？"><a href="#usememo用过没？使用场景是？" aria-hidden="true" class="header-anchor">#</a> useMemo用过没？使用场景是？</h3> <h4 id="_1、惰性计算"><a href="#_1、惰性计算" aria-hidden="true" class="header-anchor">#</a> 1、惰性计算</h4> <p>部分复杂的计算依赖项变化再执行</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useEffect<span class="token punctuation">,</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">UseMemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>WithMemo <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">WithMemo</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>val<span class="token punctuation">,</span> setValue<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">expensive</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;执行了expensive&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> expensive2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">// 加入此处是一段大量运算的逻辑，实现了只有依赖项count变化时才会重新触发。达 到了性能优化的目的</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;执行了expensive2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> count <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      sum <span class="token operator">+=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token punctuation">{</span><span class="token string">&quot; &quot;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>h4<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span><span class="token function">expensive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>h4<span class="token operator">&gt;</span>
        <span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span><span class="token operator">-</span><span class="token punctuation">{</span>expensive2<span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>h4<span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token string">&quot; &quot;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount</span><span class="token punctuation">(</span>count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token operator">+</span>c1<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span>input
          value<span class="token operator">=</span><span class="token punctuation">{</span>val<span class="token punctuation">}</span>
          onChange<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setValue</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">}</span>
        <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">{</span><span class="token string">&quot; &quot;</span><span class="token punctuation">}</span>
      <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
      用能性化优来用般一
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> UseMemo<span class="token punctuation">;</span>

</code></pre></div><h4 id="_2、配合react-memo优化不必要的渲染"><a href="#_2、配合react-memo优化不必要的渲染" aria-hidden="true" class="header-anchor">#</a> 2、配合React.memo优化不必要的渲染</h4> <p>比如以下<a href="https://github.com/FunnyLiu/reactDemo/blob/master/useCallback/components/Memo.jsx#L1" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> useCallback<span class="token punctuation">,</span> useState<span class="token punctuation">,</span> useEffect <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&quot;react&quot;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">Memo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">//   return &lt;DualCounter /&gt;;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>DualCounter2 <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;render&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//这种情况下，每点击一个按钮，都会引起两个组件的重新渲染</span>
<span class="token keyword">function</span> <span class="token function">DualCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token function-variable function">increment2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//React.memo和useCallback的组合下，就可以达到只渲染自己的目的</span>
<span class="token keyword">const</span> CountButton2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">CountButton</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> onClick<span class="token punctuation">,</span> count <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'render'</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>button onClick<span class="token operator">=</span><span class="token punctuation">{</span>onClick<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">DualCounter2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count1<span class="token punctuation">,</span> setCount1<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment1 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount1</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token punctuation">[</span>count2<span class="token punctuation">,</span> setCount2<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> increment2 <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setCount2</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> c <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count1<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment1<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>CountButton2 count<span class="token operator">=</span><span class="token punctuation">{</span>count2<span class="token punctuation">}</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span>increment2<span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span><span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> Memo<span class="token punctuation">;</span>

</code></pre></div><p>使用两个相同组件，count变化后，两个组件都会渲染，其实我们只想渲染其中的一个，这种情况下利用React.memo和useCallback，就可以优化性能。</p> <p>参考：</p> <p><a href="https://blog.csdn.net/baidu_39067385/article/details/111412255" target="_blank" rel="noopener noreferrer">理解useMemo与useCallback的使用场景_ass_ace-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="usereducer用过没？比redux好在哪里？"><a href="#usereducer用过没？比redux好在哪里？" aria-hidden="true" class="header-anchor">#</a> useReducer用过没？比Redux好在哪里？</h3> <p>从代码量上看，useReducer简洁了很多很多，更易于编写和阅读。同时也减少了方法的定义、减少了命名的次数。</p> <p>可以对比redux：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210519094634.png"> <p>使用redux的步骤：</p> <p>定义reducer</p> <p>引入connect</p> <p>定义mapStateToProps方法，mapDispatchToProps方法(分别用来接收state和dispatch)</p> <p>这种写法并无些麻烦但如果写起大型项目，频繁地connect，频繁地定义mapStateToProps、mapDispatchToProps还是稍有一些麻烦。有一点必须要知道的是，在mapDispatchToProps中我们还要再定义一个方法，包裹那些需要dispatch的动作。</p> <p>再来看看useReducer：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210519094719.png"> <p>使用useReducer的步骤</p> <p>定义reducer</p> <p>useReducer引入reducer和初始值</p> <p>从代码中可以看到我们通过useReducer，一句话的功夫就可以将state和dispatch引出，供view层使用。不需要像redux再引入connect，将组件connect起来，定义mapStateToProps，mapDispatchToProps，再供view层使用。</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844904006020497422" target="_blank" rel="noopener noreferrer">react16.8版本更新中的useReducer想比起redux到底好在哪呢？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react中state有层级很深，比如a-b-c-d，如果只更新c属性有哪些办法？"><a href="#react中state有层级很深，比如a-b-c-d，如果只更新c属性有哪些办法？" aria-hidden="true" class="header-anchor">#</a> react中state有层级很深，比如a.b.c.d，如果只更新c属性有哪些办法？</h3> <p>react推荐浅比较，但是如果非要这种深层次的，则可以通过深拷贝、深层拓展运算符或是immutable等库来解决。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 主要考的是react的immutable, react推崇浅比较</span>
<span class="token comment">// 对于react的PureComponent或者React.memo而言</span>
<span class="token comment">// 如果只是修改了b的title，b引用未修改，那么将无法触发组件render</span>

<span class="token comment">// 深拷贝对象</span>
<span class="token keyword">const</span> oldState <span class="token operator">=</span> <span class="token punctuation">{</span>
   a<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      b<span class="token punctuation">:</span> <span class="token punctuation">{</span>title<span class="token punctuation">:</span> <span class="token string">&quot;old&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> newState <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>oldState<span class="token punctuation">)</span>
newState<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>title <span class="token operator">=</span> <span class="token string">&quot;new&quot;</span>


<span class="token comment">// 生成新的b引用</span>
<span class="token keyword">const</span> oldState <span class="token operator">=</span> <span class="token punctuation">{</span>
   a<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      b<span class="token punctuation">:</span> <span class="token punctuation">{</span>title<span class="token punctuation">:</span> <span class="token string">&quot;old&quot;</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> newState <span class="token operator">=</span> <span class="token punctuation">{</span>
     a<span class="token punctuation">:</span><span class="token punctuation">{</span>
       b<span class="token punctuation">:</span><span class="token punctuation">{</span>
         <span class="token operator">...</span>oldState<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">,</span>
         title<span class="token punctuation">:</span> <span class="token string">&quot;new&quot;</span>
       <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过immutablejs </span>
<span class="token comment">// oldState是不可修改的，所以每次修改值之后</span>
<span class="token comment">// 都会产生新的对象引用</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> Map <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'immutable'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> oldState <span class="token operator">=</span> Immutable<span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    a<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      b<span class="token punctuation">:</span> <span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">&quot;old&quot;</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> newState <span class="token operator">=</span> oldState<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>b<span class="token punctuation">:</span><span class="token punctuation">{</span>title<span class="token punctuation">:</span><span class="token string">&quot;new&quot;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// true</span>
oldState <span class="token operator">!==</span> newState

</code></pre></div><h3 id="react中怎么处理异常？"><a href="#react中怎么处理异常？" aria-hidden="true" class="header-anchor">#</a> react中怎么处理异常？</h3> <p>使用错误边界。</p> <p>这个是React16中新增的概念，错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获并处理发生在其子组件树任何位置的 JavaScript 错误，并且，我们也可以指定渲染出错误显示 UI。</p> <p>错误边界的工作方式类似于 JavaScript 的 catch {}，不同的地方在于错误边界只针对 React 组件。只有 class 组件才可以成为成错误边界组件。大多数情况下, 你只需要声明一次错误边界组件, 并在整个应用中使用它。</p> <p>错误边界无法捕获以下场景中产生的错误：</p> <p>事件处理</p> <p>异步代码</p> <p>服务端渲染</p> <p>错误边界自身抛出来的错误（并非它的子组件）</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> React <span class="token keyword">from</span> <span class="token string">'react'</span>

<span class="token keyword">export</span> <span class="token keyword">interface</span> <span class="token class-name">ErrorBoundaryState</span> <span class="token punctuation">{</span>
    hasError<span class="token punctuation">:</span> boolean<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">ErrorBoundary</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> ErrorBoundaryState<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">false</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token function">getDerivedStateFromError</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> hasError<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">:</span> any<span class="token punctuation">,</span> info<span class="token punctuation">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>info<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>hasError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>出错了<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">.</span>children<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> ErrorBoundary<span class="token punctuation">;</span>
</code></pre></div><p>也可以上报sentry比如：</p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token function">componentDidCatch</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> errorInfo</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Sentry<span class="token punctuation">.</span><span class="token function">withScope</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">scope</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      scope<span class="token punctuation">.</span><span class="token function">setExtras</span><span class="token punctuation">(</span>errorInfo<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> eventId <span class="token operator">=</span> Sentry<span class="token punctuation">.</span><span class="token function">captureException</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span> eventId <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>参考：</p> <p><a href="https://www.jianshu.com/p/456509f44fbd" target="_blank" rel="noopener noreferrer">06-React异常处理 - 简书<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="错误边界怎么捕获异步错误"><a href="#错误边界怎么捕获异步错误" aria-hidden="true" class="header-anchor">#</a> 错误边界怎么捕获异步错误</h3> <p>https://github.com/facebook/react/issues/14981#issuecomment-468460187</p> <p>正常情况是捕获不了的，因为错误边界主要是为了捕获渲染错误。但是可以通过useState来hack：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><p>所以也有类型的库专门干这事：
<a href="https://github.com/bvaughn/react-error-boundary" target="_blank" rel="noopener noreferrer">react-error-boundary<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">useErrorHandler</span><span class="token punctuation">(</span><span class="token parameter">givenError<span class="token operator">?</span><span class="token punctuation">:</span> unknown</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">:</span> unknown</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">void</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>error<span class="token punctuation">,</span> setError<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span>useState<span class="token operator">&lt;</span>unknown<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>givenError <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> givenError
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> error
  <span class="token keyword">return</span> setError
<span class="token punctuation">}</span>
</code></pre></div><h3 id="react可以写命令行？体验怎么样？"><a href="#react可以写命令行？体验怎么样？" aria-hidden="true" class="header-anchor">#</a> react可以写命令行？体验怎么样？</h3> <p>最近有一个库<a href="https://github.com/vadimdemedes/ink" target="_blank" rel="noopener noreferrer">ink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，赋予了react写命令行UI的操作。下面提供一个本人在<a href="https://github.com/Linjovi/yoso" target="_blank" rel="noopener noreferrer">yoso<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>开发时封装的一套流程：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/Jul-09-2019%2010-41-40.gif"> <p>可以看到，非常流畅，这里更不谈其组件化后会有多少种可能性和效率提升。其原理可以参考下面的问题。</p> <h3 id="使用react操作cli的工具ink的原理是什么？"><a href="#使用react操作cli的工具ink的原理是什么？" aria-hidden="true" class="header-anchor">#</a> 使用react操作cli的工具ink的原理是什么？</h3> <p>react在传统的web开发中，通过react，和react-dom两个包来配合使用。在app开发中则是react和react-native来完成。所以自然可以操作各种终端的前端开发。</p> <p><a href="https://github.com/vadimdemedes/ink" target="_blank" rel="noopener noreferrer">ink<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是一款基于react的操作bash的图形化工具。我在参与一个<a href="https://github.com/Linjovi/yoso" target="_blank" rel="noopener noreferrer">开源项目yoso<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的时候用到过。</p> <p>这里简单介绍下它的原理。
首先它内置的部分组件如Color，<a href="https://github.com/vadimdemedes/ink/blob/v2.3.0/src/components/Text.js#L6" target="_blank" rel="noopener noreferrer">Text<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是直接基于<a href="https://www.npmjs.com/package/chalk" target="_blank" rel="noopener noreferrer">chalk<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其他逻辑则是<a href="https://github.com/vadimdemedes/ink/blob/v2.3.0/src/renderer.js#L21" target="_blank" rel="noopener noreferrer">在render时<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，基于<a href="https://github.com/chalk/wrap-ansi" target="_blank" rel="noopener noreferrer">wrap-ansi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来转化为命令行<a href="https://en.wikipedia.org/wiki/ANSI_escape_code#Colors_and_Styles" target="_blank" rel="noopener noreferrer">asni转义码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的。</p> <hr> <h2 id="原理"><a href="#原理" aria-hidden="true" class="header-anchor">#</a> 原理</h2> <h3 id="react和react-dom的区别是什么？"><a href="#react和react-dom的区别是什么？" aria-hidden="true" class="header-anchor">#</a> react和react-dom的区别是什么？</h3> <p>react 包即是抽象逻辑，它包含了 React 的主干逻辑。例如组件实现、更新调度等。</p> <p>react-dom 顾名思义就是一种针对 dom 的平台实现，主要用于在 web 端进行渲染。ReactDom 只做和浏览器或 DOM 相关的操作，例如 ReactDOM.render() 和 ReactDOM.findDOMNode()。如果是服务器端渲染，可以 ReactDOM.renderToString()。除这些以外的其他所有的事情都是 react 做的。</p> <p>参考：</p> <p><a href="https://www.zhihu.com/question/336664883" target="_blank" rel="noopener noreferrer">为什么react和react-dom要分成两个包？ - 知乎<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react整体的工作流程和架构是什么样？"><a href="#react整体的工作流程和架构是什么样？" aria-hidden="true" class="header-anchor">#</a> React整体的工作流程和架构是什么样？</h3> <p>React16架构可以分为三层：</p> <p>Scheduler（调度器）—— 核心职责只有 1 个, 就是执行回调</p> <p>把react-reconciler提供的回调函数, 包装到一个任务对象中.</p> <p>在内部维护一个任务队列, 优先级高的排在最前面.</p> <p>循环消费任务队列, 直到队列清空.</p> <p>Reconciler（协调器）—— 负责找出变化的组件，16版本主要是Fiber，15版本是stack。区别在于增加了优先级系统，通过遍历的方式实现可中断的递归，将fiber树的构造过程包装在一个回调函数中, 并将此回调函数传入到scheduler包等待调度.</p> <p>Renderer（渲染器）—— 负责将变化的组件渲染到页面上，能够将react-reconciler包构造出来的fiber树表现出来, 生成 dom 节点(浏览器中), 生成字符串(ssr)，比如说react-dom、react-native</p> <p>三者关系：</p> <p><img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211109094218.png" alt="img"></p> <p>参考：</p> <p><a href="https://github.com/FunnyLiu/react-1/tree/readsource#react%E6%9E%B6%E6%9E%84%E6%80%8E%E4%B9%88%E5%88%92%E5%88%86" target="_blank" rel="noopener noreferrer">FunnyLiu/react-1 at readsource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-createelement是做什么？"><a href="#react-createelement是做什么？" aria-hidden="true" class="header-anchor">#</a> React.createElement是做什么？</h3> <p>JSX会被编译为React.createElement，让我们看看他做了什么：</p> <p><a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react/src/ReactElement.js#L351" target="_blank" rel="noopener noreferrer">源码实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>我们可以看到，React.createElement最终会调用ReactElement方法返回一个包含组件数据的对象，该对象有个参数$$typeof: REACT_ELEMENT_TYPE标记了该对象是个React Element。</p> <p>换言之，在React中，所有JSX在运行时的返回结果（即React.createElement()的返回值）都是React Element。</p> <h3 id="jsx-reactelement-fiber-dom之间的关系是什么？"><a href="#jsx-reactelement-fiber-dom之间的关系是什么？" aria-hidden="true" class="header-anchor">#</a> JSX/ReactElement/Fiber/Dom之间的关系是什么？</h3> <p>JSX是一种描述当前组件内容的数据结构，他不包含组件schedule、reconcile、render所需的相关信息。</p> <p>所有采用jsx语法书写的节点, 都会被编译器转换, 最终会以React.createElement(...)的方式, 创建出来一个与之对应的ReactElement对象。</p> <p>fiber对象是通过ReactElement对象进行创建的, 多个fiber对象构成了一棵fiber树, fiber树是构造DOM树的数据模型, fiber树的任何改动, 最后都体现到DOM树。</p> <p>DOM将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合, 也就是常说的DOM树. JavaScript可以访问和操作存储在 DOM 中的内容, 也就是操作DOM对象, 进而触发 UI 渲染.</p> <p>参考：</p> <p><a href="https://github.com/FunnyLiu/react-1/tree/readsource#fiberreactelementdom%E4%B8%89%E8%80%85%E5%85%B3%E7%B3%BB" target="_blank" rel="noopener noreferrer">FunnyLiu/react-1 at readsource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react15的stackreconciler和react16的fiberreconciler有什么区别？"><a href="#react15的stackreconciler和react16的fiberreconciler有什么区别？" aria-hidden="true" class="header-anchor">#</a> React15的StackReconciler和React16的FiberReconciler有什么区别？</h3> <p>Fiber Reconciler是从Stack Reconciler重构而来，通过遍历的方式实现可中断的递归。</p> <p>参考：</p> <p><a href="https://github.com/FunnyLiu/react-1/tree/readsource#react15%E5%92%8C16%E7%9A%84reconciler%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">FunnyLiu/react-1 at readsource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://react.iamkasong.com/preparation/newConstructure.html#react16%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener noreferrer">React技术揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="reconciler主要是做什么的？"><a href="#reconciler主要是做什么的？" aria-hidden="true" class="header-anchor">#</a> Reconciler主要是做什么的？</h3> <p>此处先归纳一下react-reconciler包的主要作用, 将主要功能分为 4 个方面:</p> <p>输入: 暴露api函数(如: scheduleUpdateOnFiber), 供给其他包(如react包)调用.</p> <p>注册调度任务: 与调度中心(scheduler包)交互, 注册调度任务task, 等待任务回调.</p> <p>执行任务回调: 在内存中构造出fiber树, 同时与与渲染器(react-dom)交互, 在内存中创建出与fiber对应的DOM节点.</p> <p>输出: 与渲染器(react-dom)交互, 渲染DOM节点.</p> <p><img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211109094806.png" alt=""></p> <p>图中的1,2,3,4步骤可以反映react-reconciler包从输入到输出的运作流程,这是一个固定流程, 每一次更新都会运行.</p> <h3 id="fiber是什么？数据结构是怎么样？"><a href="#fiber是什么？数据结构是怎么样？" aria-hidden="true" class="header-anchor">#</a> Fiber是什么？数据结构是怎么样？</h3> <p>在React15及以前，Reconciler采用递归的方式创建虚拟DOM，递归过程是不能中断的。如果组件树的层级很深，递归会占用线程很多时间，造成卡顿。</p> <p>为了解决这个问题，React16将递归的无法中断的更新重构为异步的可中断更新，由于曾经用于递归的虚拟DOM数据结构已经无法满足需要。于是，全新的Fiber架构应运而生。</p> <p>Fiber包含三层含义：</p> <p>作为架构来说，之前React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。</p> <p>作为静态的数据结构来说，每个Fiber节点对应一个React element，保存了该组件的类型（函数组件/类组件/原生组件...）、对应的DOM节点等信息。</p> <p>作为动态的工作单元来说，每个Fiber节点保存了本次更新中该组件改变的状态、要执行的工作（需要被删除/被插入页面中/被更新...）。</p> <p>数据结构如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">FiberNode</span><span class="token punctuation">(</span>
  <span class="token parameter">tag<span class="token punctuation">:</span> WorkTag<span class="token punctuation">,</span>
  pendingProps<span class="token punctuation">:</span> mixed<span class="token punctuation">,</span>
  key<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token operator">|</span> string<span class="token punctuation">,</span>
  mode<span class="token punctuation">:</span> TypeOfMode<span class="token punctuation">,</span></span>
<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 作为静态数据结构的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>tag <span class="token operator">=</span> tag<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>elementType <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>stateNode <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 用于连接其他Fiber节点形成Fiber树</span>
  <span class="token comment">// 指向父级Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>return <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 指向子Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>child <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token comment">// 指向右边第一个兄弟Fiber节点</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sibling <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>ref <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 作为动态的工作单元的属性</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>pendingProps <span class="token operator">=</span> pendingProps<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedProps <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>updateQueue <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>dependencies <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>mode <span class="token operator">=</span> mode<span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>effectTag <span class="token operator">=</span> NoEffect<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>nextEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">this</span><span class="token punctuation">.</span>firstEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lastEffect <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token comment">// 调度优先级相关</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>lanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>childLanes <span class="token operator">=</span> NoLanes<span class="token punctuation">;</span>

  <span class="token comment">// 指向该fiber在另一次更新时对应的fiber</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>alternate <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="fiber是怎么工作的？"><a href="#fiber是怎么工作的？" aria-hidden="true" class="header-anchor">#</a> Fiber是怎么工作的？</h3> <p>在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。</p> <p>每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。</p> <h3 id="react16的的render阶段做了什么事情？"><a href="#react16的的render阶段做了什么事情？" aria-hidden="true" class="header-anchor">#</a> React16的的render阶段做了什么事情？</h3> <p><strong>先整体介绍</strong>：</p> <p>React 16 之前的渲染流程： jsx 编译出的 render function 执行后产生 vdom，递归渲染 vdom，也就是增删改 dom，实现 render 和 patch</p> <p>React 16 之后的渲染流程： jsx 编译出的 render function 执行后产生 vdom，通过空闲调度来慢慢的把 vdom 转成 fiber，vdom 转 fiber 的过程叫做 reconcile，最后都转完了就一次性渲染 fiber，也就是 commit，这样实现的 render 和 patch。之所以多了一层 vdom 转 fiber，是为了避免递归 patch 的时候需要做对比，而是通过可打断的方式来逐步计算如何修改 dom （是增、是删还是改）记录到 fiber 上，最后直接根据 fiber 直接增删改 dom</p> <p>再详细描述：</p> <p>render阶段，根据组件返回的JSX在内存中依次创建Fiber节点并连接在一起构建Fiber树。</p> <p>“递”阶段</p> <p>首先从rootFiber开始向下深度优先遍历。为遍历到的每个Fiber节点调用beginWork方法。</p> <p>该方法会根据传入的Fiber节点创建子Fiber节点，并将这两个Fiber节点连接起来。</p> <p>当遍历到叶子节点（即没有子组件的组件）时就会进入“归”阶段。</p> <p>“归”阶段</p> <p>在“归”阶段会调用completeWork处理Fiber节点。</p> <p>当某个Fiber节点执行完completeWork，如果其存在兄弟Fiber节点（即fiber.sibling !== null），会进入其兄弟Fiber的“递”阶段。</p> <p>如果不存在兄弟Fiber，会进入父级Fiber的“归”阶段。</p> <p>“递”和“归”阶段会交错执行直到“归”到rootFiber。至此，render阶段的工作就结束了。</p> <p>举个例子：</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      i am
      <span class="token operator">&lt;</span>span<span class="token operator">&gt;</span>KaSong<span class="token operator">&lt;</span><span class="token operator">/</span>span<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>App <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;root&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>生成的Fiber树为：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211104154724.png"> <p>其render阶段会执行：</p> <ol><li>rootFiber beginWork</li> <li>App Fiber beginWork</li> <li>div Fiber beginWork</li> <li>&quot;i am&quot; Fiber beginWork</li> <li>&quot;i am&quot; Fiber completeWork</li> <li>span Fiber beginWork</li> <li>span Fiber completeWork</li> <li>div Fiber completeWork</li> <li>App Fiber completeWork</li> <li>rootFiber completeWork</li></ol> <h3 id="render阶段的beginwork究竟做了什么？"><a href="#render阶段的beginwork究竟做了什么？" aria-hidden="true" class="header-anchor">#</a> render阶段的beginWork究竟做了什么？</h3> <p>beginWork的工作是传入当前Fiber节点，创建子Fiber节点。<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3214" target="_blank" rel="noopener noreferrer">源码在此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211104155833.png"> <h3 id="render阶段的completework究竟做了什么？"><a href="#render阶段的completework究竟做了什么？" aria-hidden="true" class="header-anchor">#</a> render阶段的completeWork究竟做了什么？</h3> <p>completeWork属于“归”阶段调用的函数，每次调用appendAllChildren时都会将已生成的子孙DOM节点插入当前生成的DOM节点下。那么当“归”到rootFiber时，我们已经有一个构建好的离屏DOM树。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211104160616.png"> <h3 id="diff算法到底是做什么的？"><a href="#diff算法到底是做什么的？" aria-hidden="true" class="header-anchor">#</a> Diff算法到底是做什么的？</h3> <p>一个DOM节点在某一时刻最多会有4个节点和他相关。</p> <p>1、current Fiber。如果该DOM节点已在页面中，current Fiber代表该DOM节点对应的Fiber节点。</p> <p>2、workInProgress Fiber。如果该DOM节点将在本次更新中渲染到页面中，workInProgress Fiber代表该DOM节点对应的Fiber节点。</p> <p>3、DOM节点本身。</p> <p>4、JSX对象。即ClassComponent的render方法的返回结果，或FunctionComponent的调用结果。JSX对象中包含描述DOM节点的信息。</p> <p>Diff算法的本质是对比1和4，生成2。</p> <h3 id="diff算法怎么优化复杂度？"><a href="#diff算法怎么优化复杂度？" aria-hidden="true" class="header-anchor">#</a> Diff算法怎么优化复杂度？</h3> <p>由于Diff操作本身也会带来性能损耗，React文档中提到，即使在最前沿的算法中，将前后两棵树完全比对的算法的复杂程度为 O(n 3 )，其中n是树中元素的数量。</p> <p>如果在React中使用了该算法，那么展示1000个元素所需要执行的计算量将在十亿的量级范围。这个开销实在是太过高昂。</p> <p>为了降低算法复杂度，React的diff会预设三个限制：</p> <p>1、只对同级元素进行Diff。如果一个DOM节点在前后两次更新中跨越了层级，那么React不会尝试复用他。</p> <p>2、两个不同类型的元素会产生出不同的树。如果元素由div变为p，React会销毁div及其子孙节点，并新建p及其子孙节点。</p> <p>3、开发者可以通过 key prop来暗示哪些子元素在不同的渲染下能保持稳定。考虑如下例子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 更新前</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token string">&quot;ka&quot;</span><span class="token operator">&gt;</span>ka<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>h3 key<span class="token operator">=</span><span class="token string">&quot;song&quot;</span><span class="token operator">&gt;</span>song<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

<span class="token comment">// 更新后</span>
<span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>h3 key<span class="token operator">=</span><span class="token string">&quot;song&quot;</span><span class="token operator">&gt;</span>song<span class="token operator">&lt;</span><span class="token operator">/</span>h3<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>p key<span class="token operator">=</span><span class="token string">&quot;ka&quot;</span><span class="token operator">&gt;</span>ka<span class="token operator">&lt;</span><span class="token operator">/</span>p<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>

</code></pre></div><p>如果没有key，React会认为div的第一个子节点由p变为h3，第二个子节点由h3变为p。这符合限制2的设定，会销毁并新建。</p> <p>但是当我们用key指明了节点前后对应关系后，React知道key === &quot;ka&quot;的p在更新后还存在，所以DOM节点可以复用，只是需要交换下顺序。</p> <p>这就是React为了应对算法性能瓶颈做出的三条限制</p> <h3 id="diff算法具体怎么实现？"><a href="#diff算法具体怎么实现？" aria-hidden="true" class="header-anchor">#</a> Diff算法具体怎么实现？</h3> <p><a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react-reconciler/src/ReactChildFiber.new.js#L1213" target="_blank" rel="noopener noreferrer">源码在此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>前面提到，React为了优化复杂度只对同级元素进行Diff。我们可以从同级的节点数量将Diff分为两类：</p> <p>1、当newChild类型为object、number、string，代表同级只有一个节点</p> <p>2、当newChild类型为Array，同级有多个节点</p> <p>针对同级有单个节点的情况：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211104195437.png"> <p>React通过先判断key是否相同，如果key相同则判断type是否相同，只有都相同时一个DOM节点才能复用。</p> <p>针对同级有多个节点的情况：</p> <p>如果让我设计一个Diff算法，我首先想到的方案是：</p> <p>判断当前节点的更新属于哪种情况</p> <p>如果是新增，执行新增逻辑</p> <p>如果是删除，执行删除逻辑</p> <p>如果是更新，执行更新逻辑</p> <p>按这个方案，其实有个隐含的前提——不同操作的优先级是相同的</p> <p>但是React团队发现，在日常开发中，相较于新增和删除，更新组件发生的频率更高。所以Diff会优先判断当前节点是否属于更新。</p> <p>由于diff主要是对比Fiber（单链表）和jsx的区别，所以双指针优化无法使用。</p> <p>基于以上原因，Diff算法的整体逻辑会经历两轮遍历：</p> <p>第一轮遍历：处理更新的节点。</p> <p>第二轮遍历：处理剩下的不属于更新的节点。</p> <p>第一轮遍历步骤如下：</p> <p>1、let i = 0，遍历newChildren，将newChildren[i]与oldFiber比较，判断DOM节点是否可复用。</p> <p>2、如果可复用，i++，继续比较newChildren[i]与oldFiber.sibling，可以复用则继续遍历。</p> <p>3、如果不可复用，分两种情况：</p> <p>key不同导致不可复用，立即跳出整个遍历，第一轮遍历结束。</p> <p>key相同type不同导致不可复用，会将oldFiber标记为DELETION，并继续遍历</p> <p>4、如果newChildren遍历完（即i === newChildren.length - 1）或者oldFiber遍历完（即oldFiber.sibling === null），跳出遍历，第一轮遍历结束。</p> <p>其他具体参考：https://react.iamkasong.com/diff/multi.html</p> <h3 id="react的diff为什么用不了双指针优化？"><a href="#react的diff为什么用不了双指针优化？" aria-hidden="true" class="header-anchor">#</a> React的diff为什么用不了双指针优化？</h3> <p>在我们做数组相关的算法题时，经常使用双指针从数组头和尾同时遍历以提高效率，但是这里却不行。</p> <p>虽然本次更新的JSX对象 newChildren为数组形式，但是和newChildren中每个组件进行比较的是current fiber，同级的Fiber节点是由sibling指针链接形成的单链表，即不支持双指针遍历。</p> <p>即 newChildren[0]与fiber比较，newChildren[1]与fiber.sibling比较。</p> <p>所以无法使用双指针优化。</p> <h3 id="react组件什么时候会重新渲染？"><a href="#react组件什么时候会重新渲染？" aria-hidden="true" class="header-anchor">#</a> React组件什么时候会重新渲染？</h3> <p>当内部data发生改变，state发生改变(通过调用this.setState()) 以及父组件传过来的props发生改变时，会导致组件重新渲染。</p> <h3 id="react如何避免重复渲染？"><a href="#react如何避免重复渲染？" aria-hidden="true" class="header-anchor">#</a> React如何避免重复渲染？</h3> <p>react生命周期中有这样一个钩子，叫shouldComponentUpdate函数，是重渲染时render()函数调用前被调用的函数，两个参数 nextProps和nextState ，分别表示下一个props和state的值。当函数返回false时，阻止接下来的render()函数的调用，阻止组件重渲染，返回true时，组件照常渲染。 前后不改变state的值的setState和无数据交换的父组件的重渲染都会导致组件的重渲染，但我们可以通过shouldComponentUpdate来阻止这两种情况，shouldComponentUpdate并不是完美的，只能阻止扁平的对象，这时候可以考虑​​Immutable.js​​(Immutable.js 的基本原则是对于不变的对象返回相同的引用，而对于变化的对象，返回新的引用)或者​​PureRenderMixin​​ 插件。</p> <h3 id="fiber原理"><a href="#fiber原理" aria-hidden="true" class="header-anchor">#</a> Fiber原理</h3> <p>Fiber：一种将 recocilation （递归 diff），拆分成无数个小任务的算法；它随时能够停止，恢复。停止恢复的时机取决于当前的一帧（16ms）内，还有没有足够的时间允许计算。</p> <p>在了解Fiber前，需要先了解virtual DOM的相关原理，可以参考<a href="https://omnipotent-front-end.github.io/library/vue.html#vue2-x%E4%B8%AD%E7%9A%84virtual-dom%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" target="_blank" rel="noopener noreferrer">Vue中Virtual DOM到底是什么？如何实现的？<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>然后<a href="https://reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">Fiber要解决的问题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，主要是大量DOM在进行渲染时的卡顿情况。</p> <p>Fiber Tree相比之前的Virtual DOM，不再仅仅是dom的基本属性了，还增加了任务调度相关的信息。</p> <p><strong>整个结构是一个链表树</strong>。每个工作单元（fiber）执行完成后，都会查看是否还继续拥有主线程时间片，如果有继续下一个，如果没有则先处理其他高优先级事务，等主线程空闲下来继续执行。</p> <p>对比图：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710155311.png"> <p>Fiber解决任务调度的方式，主要是使用了<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback" target="_blank" rel="noopener noreferrer">requestIdleCallback<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" target="_blank" rel="noopener noreferrer">requestAnimationFrame<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>两个API。</p> <p>整个Fiber的reconciler过程分为两个阶段：</p> <p>1、（可中断）render/reconciliation 通过构造workInProgress tree得出change</p> <p>2、（不可中断）commit 应用这些DOM change</p> <p>render/reconciliation流程如下：</p> <p>1、如果当前节点不需要更新，直接把子节点clone过来，跳到5；要更新的话打个tag</p> <p>2、更新当前节点状态（props, state, context等）</p> <p>3、调用shouldComponentUpdate()，false的话，跳到5</p> <p>4、调用render()获得新的子节点，并为子节点创建fiber（创建过程会尽量复用现有fiber，子节点增删也发生在这里）</p> <p>5、如果没有产生child fiber，该工作单元结束，把effect list归并到return，并把当前节点的sibling作为下一个工作单元；否则把child作为下一个工作单元</p> <p>6、如果没有剩余可用时间了，等到下一次主线程空闲时才开始下一个工作单元；否则，立即开始做</p> <p>7、如果没有下一个工作单元了（回到了workInProgress tree的根节点），第1阶段结束，进入pendingCommit状态</p> <p>实际上是<strong>1-6的工作循环</strong>，7是出口，工作循环每次只做一件事，做完看要不要喘口气。工作循环结束时，workInProgress tree的根节点身上的effect list就是收集到的所有side effect（因为每做完一个都向上归并）</p> <p>所以，<strong>构建workInProgress tree的过程就是diff的过程</strong>，<strong>通过requestIdleCallback来调度执行一组任务，每完成一个任务后回来看看有没有插队的（更紧急的）</strong>，每完成一组任务，把时间控制权交还给主线程，直到下一次requestIdleCallback回调再继续构建workInProgress tree。</p> <p>commit阶段是一气呵成的，如下流程：</p> <p>1、处理effect list（包括3种处理：更新DOM树、调用组件生命周期函数以及更新ref等内部状态）</p> <p>2、所有更新都commit到DOM树上了</p> <h3 id="react-hooks的原理"><a href="#react-hooks的原理" aria-hidden="true" class="header-anchor">#</a> React Hooks的原理</h3> <p>首先，如果不了解Hooks是什么，先学习<a href="https://reactjs.org/docs/hooks-intro.html" target="_blank" rel="noopener noreferrer">官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，然后我也开发了一个基于Hooks的<a href="https://github.com/FunnyLiu/reactDemo/tree/master/todomvc_hook" target="_blank" rel="noopener noreferrer">todomvc<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>然后再看看Hooks的原理。</p> <p>内容选自<a href="https://github.com/answershuto/Blog/blob/master/blogs/(%E8%AF%91)Reacthooks%EF%BC%9A%E5%AE%83%E4%B8%8D%E6%98%AF%E4%B8%80%E7%A7%8D%E9%AD%94%E6%B3%95%EF%BC%8C%E5%8F%AA%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%9B%BE%E8%A1%A8%E6%8F%AD%E7%A7%98%E6%8F%90%E6%A1%88%E8%A7%84%E5%88%99.MarkDown" target="_blank" rel="noopener noreferrer">一篇染陌同学的译文<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <strong>Hooks的状态管理都是依赖数组的</strong>。但是在React的实现中是<strong>以单链表的数据结构</strong>来完成的。
以一个简单的使用<code>useState()</code>的组件为例：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">RenderFunctionComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> setFirstName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Rudi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>lastName<span class="token punctuation">,</span> setLastName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Yardley&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">&quot;Fred&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Fred<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>React在渲染时做做如下步骤：</p> <p>1、初始化</p> <p>创建两个空数组“setters”与“state”</p> <p>设置指针“cursor”为 0</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705163608.png"> <p>2、首次渲染</p> <p>首次执行组件函数</p> <p>每当 useState() 被调用时，如果它是首次渲染，它会通过 push 将一个 setter 方法（绑定了指针“cursor”位置）放进 setters 数组中，同时，也会将另一个对应的状态放进 state 数组中去。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705163821.png"> <p>3、后续渲染</p> <p>每次的后续渲染都会重置指针“cursor”的位置，并会从每个数组中读取对应的值。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705163903.png"> <p>4、事件处理</p> <p>每个 setter 都会有一个对应的指针位置的引用，因此当触发任何 setter 调用的时候都会触发去改变状态数组中的对应的值。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705164049.png"> <p>代码实现如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 通过闭包来完成对数据的存储，方便在函数中去有状态的使用</span>
<span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> setters <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> firstRun <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">createSetter</span><span class="token punctuation">(</span><span class="token parameter">cursor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">setterWithCursor</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span> <span class="token operator">=</span> newVal<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 译:https://github.com/answershuto */</span>
<span class="token comment">// This is the pseudocode for the useState helper</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token parameter">initVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRun<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    state<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>initVal<span class="token punctuation">)</span><span class="token punctuation">;</span>
    setters<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">createSetter</span><span class="token punctuation">(</span>cursor<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    firstRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> setter <span class="token operator">=</span> setters<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> value <span class="token operator">=</span> state<span class="token punctuation">[</span>cursor<span class="token punctuation">]</span><span class="token punctuation">;</span>

  cursor<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>value<span class="token punctuation">,</span> setter<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/* 译:https://github.com/answershuto */</span>
<span class="token comment">// Our component code that uses hooks</span>
<span class="token keyword">function</span> <span class="token function">RenderFunctionComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> setFirstName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Rudi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cursor: 0</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>lastName<span class="token punctuation">,</span> setLastName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Yardley&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// cursor: 1</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">&quot;Richard&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Richard<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
      <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">&quot;Fred&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Fred<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// This is sort of simulating Reacts rendering cycle</span>
<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cursor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// resetting the cursor</span>
  <span class="token keyword">return</span> <span class="token operator">&lt;</span>RenderFunctionComponent <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// render</span>
<span class="token punctuation">}</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Pre-render: []</span>
<span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// First-render: ['Rudi', 'Yardley']</span>
<span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Subsequent-render: ['Rudi', 'Yardley']</span>

<span class="token comment">// click the 'Fred' button</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// After-click: ['Fred', 'Yardley']</span>
</code></pre></div><h3 id="react-hooks为什么不能在循环、条件或者嵌套函数中调用"><a href="#react-hooks为什么不能在循环、条件或者嵌套函数中调用" aria-hidden="true" class="header-anchor">#</a> React Hooks为什么不能在循环、条件或者嵌套函数中调用</h3> <p>这个问题，如果了解了其原理，就比较容易想得通了。
可以模拟一下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> firstRender <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">RenderFunctionComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> initName<span class="token punctuation">;</span>
  
  <span class="token keyword">if</span><span class="token punctuation">(</span>firstRender<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token punctuation">[</span>initName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Rudi&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    firstRender <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>firstName<span class="token punctuation">,</span> setFirstName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>initName<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>lastName<span class="token punctuation">,</span> setLastName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">&quot;Yardley&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token operator">&lt;</span>Button onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">setFirstName</span><span class="token punctuation">(</span><span class="token string">&quot;Fred&quot;</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token operator">&gt;</span>Fred<span class="token operator">&lt;</span><span class="token operator">/</span>Button<span class="token operator">&gt;</span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们在条件语句中调用了 useState 函数，让我们看看它对整个系统造成的破坏。</p> <p>首次渲染：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705164512.png"> <p>第二次渲染</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190705164558.png"> <p>现在 firstName 与 lastName 这两个变量全部被设置为“Rudi”，与我们实际的存储状态不符。</p> <p>这个例子的用法显然是不正确的，但是它让我们知道了为什么我们必须使用 React 团队规定的规则去使用 Hooks。</p> <h3 id="hooks为什么用单链表存储而不是数组？"><a href="#hooks为什么用单链表存储而不是数组？" aria-hidden="true" class="header-anchor">#</a> hooks为什么用单链表存储而不是数组？</h3> <p>首先说明下，react的hook是单链表的结构，而fre的hook则是数组结构。数组结构和单链表结构可以实现hook。</p> <p>但是我们在选择数据结构的时候需要考虑场景，hook的场景需要的是顺序访问，不需要随机访问；链表面对插入的场景，复杂度更低；数组会存在爆栈的隐患，而链表不会。</p> <p>根据132的介绍，hook用数组更好，effectlist和fiber用链表更好，因为hook不需要插入、也不会出现量大到爆栈的情况，而react团队当年是能不用数组就不用数组的政治正确。</p> <h3 id="hook为什么不能在条件判断中使用？"><a href="#hook为什么不能在条件判断中使用？" aria-hidden="true" class="header-anchor">#</a> hook为什么不能在条件判断中使用？</h3> <p>hook无论用数组还是链表，都无法解决这个问题，因为hook只初始化一次，但需要执行多次。if-else会干扰初始化的顺序。</p> <p>而vue3的就没有这个问题，因为vue3不需要反复执行，所以顺序不会发生变化。</p> <h3 id="react在批量处理事件时，是否需要开发者手动进行事件代理？为什么？"><a href="#react在批量处理事件时，是否需要开发者手动进行事件代理？为什么？" aria-hidden="true" class="header-anchor">#</a> React在批量处理事件时，是否需要开发者手动进行事件代理？为什么？</h3> <p>不需要，因为React自己内部已经做了处理，将所有在JSX上绑定的事件都集中代理到了document上。具体可以参考<a href="https://zh-hans.reactjs.org/docs/events.html" target="_blank" rel="noopener noreferrer">官网<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>这样的好处在于，在底层封装一套event，跨端跨浏览器保持统一的API风格。</p> <h3 id="react-memo做了什么？怎么做的？"><a href="#react-memo做了什么？怎么做的？" aria-hidden="true" class="header-anchor">#</a> React.memo做了什么？怎么做的？</h3> <p>React.memo(...) 对应的是函数组件，React.PureComponent 对应的是类组件。</p> <p>React.memo 会返回了一个纯组件 MemodFuncComponent。 我们将在 JSX 标记中渲染此组件。 每当组件中的 props 和 state 发生变化时，React 将检查 上一个 state 和 props 以及下一个 props 和 state 是否相等，如果不相等则函数组件将重新渲染，如果它们相等则函数组件将不会重新渲染。</p> <p>从实现的角度来看，React.memo方法只是在组件上增加了一个标识位：<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react/src/ReactMemo.js#L27" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code>  <span class="token comment">//相当于带上了一个标识的type</span>
  <span class="token keyword">const</span> elementType <span class="token operator">=</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token constant">REACT_MEMO_TYPE</span><span class="token punctuation">,</span>
    type<span class="token punctuation">,</span>
    compare<span class="token punctuation">:</span> compare <span class="token operator">===</span> <span class="token keyword">undefined</span> <span class="token operator">?</span> <span class="token keyword">null</span> <span class="token punctuation">:</span> compare<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>然后在Fiber阶段会针对这个类似额外做适配<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L3603" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token keyword">case</span> MemoComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>

      <span class="token comment">//Memo组件会去走这个逻辑</span>
      <span class="token keyword">return</span> <span class="token function">updateMemoComponent</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        type<span class="token punctuation">,</span>
        resolvedProps<span class="token punctuation">,</span>
        updateLanes<span class="token punctuation">,</span>
        renderLanes<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>该方法会进行compare比较<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L490" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">// 如果两次props相等</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compare</span><span class="token punctuation">(</span>prevProps<span class="token punctuation">,</span> nextProps<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> current<span class="token punctuation">.</span>ref <span class="token operator">===</span> workInProgress<span class="token punctuation">.</span>ref<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//直接返回，不再进行下面的fiber操作。</span>
      <span class="token keyword">return</span> <span class="token function">bailoutOnAlreadyFinishedWork</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> workInProgress<span class="token punctuation">,</span> renderLanes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>如果比较结果一致，就不进行后续Fiber流程。</p> <p>参考：</p> <p><a href="https://segmentfault.com/a/1190000018444604" target="_blank" rel="noopener noreferrer">Web 性能优化： 使用 React.memo() 提高 React 组件性能 - SegmentFault 思否<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-memo和purecomponent有什么区别？"><a href="#react-memo和purecomponent有什么区别？" aria-hidden="true" class="header-anchor">#</a> React.memo和PureComponent有什么区别？</h3> <p>React.PureComponent 是 ES6 类的组件</p> <p>React.memo(...) 是函数组件</p> <p>React.PureComponent 优化 ES6 类组件中的重新渲染</p> <p>React.memo(...) 优化函数组件中的重新渲染</p> <p>参考：</p> <p><a href="https://segmentfault.com/a/1190000018444604" target="_blank" rel="noopener noreferrer">Web 性能优化： 使用 React.memo() 提高 React 组件性能 - SegmentFault 思否<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="react-lazy做了什么？怎么做的？"><a href="#react-lazy做了什么？怎么做的？" aria-hidden="true" class="header-anchor">#</a> React.lazy做了什么？怎么做的？</h3> <p>它能让你像渲染常规组件一样处理动态引入的组件，配合 webpack 的 Code Splitting ，只有当组件被加载，对应的资源才会导入 ，从而达到懒加载的效果。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 不使用 React.lazy</span>
<span class="token keyword">import</span> OtherComponent <span class="token keyword">from</span> <span class="token string">'./OtherComponent'</span><span class="token punctuation">;</span>
<span class="token comment">// 使用 React.lazy</span>
<span class="token keyword">const</span> OtherComponent <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'./OtherComponent'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>React.lazy 需要配合 Suspense 组件一起使用，在 Suspense 组件中渲染 React.lazy 异步加载的组件。如果单独使用 React.lazy，React 会给出错误提示。</p> <p>React.lazy不支持服务端渲染，使用服务端渲染的同学，请绕行至 react-loadable和 loadable-components。</p> <p>从实现上来看，React.lazy其实是给组件增加了标识位和回调函数<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react/src/ReactLazy.js#L104" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//React.Lazy实现</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> lazy<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>
  <span class="token function-variable function">ctor</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Thenable<span class="token operator">&lt;</span><span class="token punctuation">{</span><span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token constant">T</span><span class="token punctuation">,</span> <span class="token operator">...</span><span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> LazyComponent<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> payload<span class="token punctuation">:</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token comment">// We use these fields to store the result.</span>
    <span class="token comment">//用来标记</span>
    _status<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>
    _result<span class="token punctuation">:</span> ctor<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//增加标识位</span>
  <span class="token keyword">const</span> lazyType<span class="token punctuation">:</span> LazyComponent<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token punctuation">,</span> Payload<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
    $$<span class="token keyword">typeof</span><span class="token punctuation">:</span> <span class="token constant">REACT_LAZY_TYPE</span><span class="token punctuation">,</span>
    _payload<span class="token punctuation">:</span> payload<span class="token punctuation">,</span>
    _init<span class="token punctuation">:</span> lazyInitializer<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后在fiber的开始阶段，而不是整个项目初始化的阶段。再去执行传入的thenable函数<a href="https://github.com/FunnyLiu/react-1/blob/readsource/packages/react-reconciler/src/ReactFiberBeginWork.new.js#L1278" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code>    <span class="token comment">//如果是lazy组件的话，走单独的流程</span>
    <span class="token keyword">case</span> LazyComponent<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> elementType <span class="token operator">=</span> workInProgress<span class="token punctuation">.</span>elementType<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token function">mountLazyComponent</span><span class="token punctuation">(</span>
        current<span class="token punctuation">,</span>
        workInProgress<span class="token punctuation">,</span>
        elementType<span class="token punctuation">,</span>
        updateLanes<span class="token punctuation">,</span>
        renderLanes<span class="token punctuation">,</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p>参考：</p> <p><a href="https://www.zoo.team/article/react-lazy-suspense" target="_blank" rel="noopener noreferrer">这就是你日思夜想的 React 原生动态加载 - 政采云前端团队<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="class组件为什么需要绑定this"><a href="#class组件为什么需要绑定this" aria-hidden="true" class="header-anchor">#</a> class组件为什么需要绑定this</h3> <p>这其实是javascript的一个问题。</p> <p>我们可以看看：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
    <span class="token comment">//this.display = this.display.bind(this);</span>
  <span class="token punctuation">}</span>
  
  <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token string">'Saurabh'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
foo<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Saurabh</span>

<span class="token keyword">var</span> display <span class="token operator">=</span> foo<span class="token punctuation">.</span>display<span class="token punctuation">;</span>
<span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error</span>
</code></pre></div><p>正常情况下，对象方法是可以访问到this的。但是如果把函数给拷贝给另一个对象时，这个this就会丢失。</p> <p>来看看React是怎么用的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span> <span class="token parameter">props</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span> props <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    
  <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token parameter">event</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 'this' is undefined</span>
  <span class="token punctuation">}</span>
    
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>
      <span class="token operator">&lt;</span>button type<span class="token operator">=</span><span class="token string">&quot;button&quot;</span> onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>handleClick<span class="token punctuation">}</span><span class="token operator">&gt;</span>
        Click Me
      <span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">&gt;</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

ReactDOM<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>Foo <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">,</span>
  document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;app&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><p>onClick相对是与函数拷贝给了下一个组件，所以this就丢失了。</p> <h3 id="怎么解决this丢失问题"><a href="#怎么解决this丢失问题" aria-hidden="true" class="header-anchor">#</a> 怎么解决this丢失问题</h3> <p>有很多方式，有onClick中bindthis，或者箭头函数，或者autobind库里完成。</p> <p>也可以基于</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 方式二</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>这也是react支持的方案。</p> <p>参考：</p> <p><a href="https://github.com/dwqs/blog/issues/67" target="_blank" rel="noopener noreferrer">ES6 Class Methods 定义方式的差异 · Issue #67 · dwqs/blog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="为什么用箭头函数可以解决？"><a href="#为什么用箭头函数可以解决？" aria-hidden="true" class="header-anchor">#</a> 为什么用箭头函数可以解决？</h3> <p>在箭头函数出现之前，每个新定义的函数都有它自己的 this 值，但箭头函数不会创建自己的 this，它从会从自己的作用域链的上一层继承 this。</p> <p>直接箭头函数就是把箭头函数绑定到当前class 构造函数的this上。而普通函数传统方式则是prototype上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token keyword">extends</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
    <span class="token function">print</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print d'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// print b</span>
</code></pre></div><p>编译后为：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">B</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token constant">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">_classCallCheck</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token constant">D</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 继承自 B</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'print b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 通过原型实现继承</span>
<span class="token constant">D</span><span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> <span class="token constant">B</span><span class="token punctuation">;</span>
<span class="token class-name">D</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>

<span class="token class-name">D</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">print</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 类 D 自身定义的 print 方法</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

</code></pre></div><h3 id="concurrent-mode是什么？"><a href="#concurrent-mode是什么？" aria-hidden="true" class="header-anchor">#</a> Concurrent Mode是什么？</h3> <p>Concurrent 模式是一组 React 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p> <p>从源码层面讲，Concurrent Mode是一套可控的“多优先级更新架构”。</p> <p>Concurrent Mode是React过去2年重构Fiber架构的源动力，也是React未来的发展方向。</p> <p>可以预见，当v17完美支持Concurrent Mode后，v18会迎来一大波基于Concurrent Mode的库。</p> <p>到要实现Concurrent Mode，最关键的一点是：实现异步可中断的更新。</p> <p>基于这个前提，React花费2年时间重构完成了Fiber架构。</p> <p>Fiber架构的意义在于，他将单个组件作为工作单元，使以组件为粒度的“异步可中断的更新”成为可能。</p> <h3 id="scheduler（调度器）是做什么的？"><a href="#scheduler（调度器）是做什么的？" aria-hidden="true" class="header-anchor">#</a> Scheduler（调度器）是做什么的？</h3> <p>如果我们同步运行Fiber架构（通过ReactDOM.render），则Fiber架构与重构前并无区别。</p> <p>但是当我们配合时间切片，就能根据宿主环境性能，为每个工作单元分配一个可运行时间，实现“异步可中断的更新”。</p> <p>于是，scheduler （调度器）产生了。</p> <p>Scheduler，他包含两个功能：</p> <p>时间切片</p> <p>优先级调度</p> <h3 id="时间切片的原理"><a href="#时间切片的原理" aria-hidden="true" class="header-anchor">#</a> 时间切片的原理</h3> <p>时间切片的本质是模拟实现requestIdleCallback 。</p> <p>除去“浏览器重排/重绘”，下图是浏览器一帧中可以用于执行JS的时机。</p> <div class="language- extra-class"><pre class="language-text"><code>一个task(宏任务) -- 队列中全部job(微任务) -- requestAnimationFrame -- 浏览器重排/重绘 -- requestIdleCallback
</code></pre></div><p>requestIdleCallback是在“浏览器重排/重绘”后如果当前帧还有空余时间时被调用的。</p> <p>Scheduler的时间切片功能是通过task（宏任务）实现的。</p> <p>最常见的task当属setTimeout了。但是有个task比setTimeout执行时机更靠前，那就是MessageChannel 。</p> <p>所以Scheduler将需要被执行的回调函数作为MessageChannel的回调执行。如果当前宿主环境不支持MessageChannel，则使用setTimeout。</p> <p>在React的render阶段，开启Concurrent Mode时，每次遍历前，都会通过Scheduler提供的shouldYield方法判断是否需要中断遍历，使浏览器有时间渲染：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">workLoopConcurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Perform work until Scheduler asks us to yield</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>workInProgress <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">shouldYield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">performUnitOfWork</span><span class="token punctuation">(</span>workInProgress<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>是否中断的依据，最重要的一点便是每个任务的剩余时间是否用完。</p> <p>在Schdeduler中，为任务分配的初始剩余时间为5ms。随着应用运行，会通过fps动态调整分配给任务的可执行时间。<a href="https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L172-L187" target="_blank" rel="noopener noreferrer">源码在此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="优先级调度的原理"><a href="#优先级调度的原理" aria-hidden="true" class="header-anchor">#</a> 优先级调度的原理</h3> <p>Scheduler内部存在5种优先级。</p> <p>设想一个大型React项目，在某一刻，存在很多不同优先级的任务，对应不同的过期时间。</p> <p>同时，又因为任务可以被延迟，所以我们可以将这些任务按是否被延迟分为：</p> <p>已就绪任务</p> <p>未就绪任务</p> <p>所以，Scheduler存在两个队列：</p> <p>timerQueue：保存未就绪任务</p> <p>taskQueue：保存已就绪任务</p> <p>每当有新的未就绪的任务被注册，我们将其插入timerQueue并根据开始时间重新排列timerQueue中任务的顺序。</p> <p>当timerQueue中有任务就绪，即startTime &lt;= currentTime，我们将其取出并加入taskQueue。</p> <p>取出taskQueue中最早过期的任务并执行他。</p> <p>为了能在O(1)复杂度找到两个队列中时间最早的那个任务，Scheduler使用小顶堆实现了优先级队列。</p> <h2 id="编码"><a href="#编码" aria-hidden="true" class="header-anchor">#</a> 编码</h2> <h3 id="实现一个自定义hook（todo）？"><a href="#实现一个自定义hook（todo）？" aria-hidden="true" class="header-anchor">#</a> 实现一个自定义hook（todo）？</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/library/pm2.html" class="prev">
          PM2
        </a></span> <span class="next"><a href="/library/react_native.html">
          React Native
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2cc9f89.js" defer></script><script src="/assets/js/2.397e6419.js" defer></script><script src="/assets/js/30.25a4547a.js" defer></script>
  </body>
</html>
