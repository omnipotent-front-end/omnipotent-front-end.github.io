<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 无所不能的前端--十万个为什么</title>
    <meta name="description" content="Hello world">
    
    
    <link rel="preload" href="/assets/css/0.styles.617c345f.css" as="style"><link rel="preload" href="/assets/js/app.d2cc9f89.js" as="script"><link rel="preload" href="/assets/js/2.397e6419.js" as="script"><link rel="preload" href="/assets/js/37.3163d65d.js" as="script"><link rel="prefetch" href="/assets/js/10.bb868db5.js"><link rel="prefetch" href="/assets/js/11.4b9af4bc.js"><link rel="prefetch" href="/assets/js/12.c4499f48.js"><link rel="prefetch" href="/assets/js/13.d1872e02.js"><link rel="prefetch" href="/assets/js/14.142a03af.js"><link rel="prefetch" href="/assets/js/15.4a5cbaf1.js"><link rel="prefetch" href="/assets/js/16.f8dbbc61.js"><link rel="prefetch" href="/assets/js/17.82a379c6.js"><link rel="prefetch" href="/assets/js/18.715eafe3.js"><link rel="prefetch" href="/assets/js/19.3ccb129c.js"><link rel="prefetch" href="/assets/js/20.cae30be8.js"><link rel="prefetch" href="/assets/js/21.13af9b85.js"><link rel="prefetch" href="/assets/js/22.37452818.js"><link rel="prefetch" href="/assets/js/23.42d1270e.js"><link rel="prefetch" href="/assets/js/24.ab12fe9d.js"><link rel="prefetch" href="/assets/js/25.c0481126.js"><link rel="prefetch" href="/assets/js/26.11ac2dd4.js"><link rel="prefetch" href="/assets/js/27.739ff2af.js"><link rel="prefetch" href="/assets/js/28.ba55abf0.js"><link rel="prefetch" href="/assets/js/29.b9c0eeba.js"><link rel="prefetch" href="/assets/js/3.addf54d7.js"><link rel="prefetch" href="/assets/js/30.25a4547a.js"><link rel="prefetch" href="/assets/js/31.67514c9b.js"><link rel="prefetch" href="/assets/js/32.70396374.js"><link rel="prefetch" href="/assets/js/33.c599a93b.js"><link rel="prefetch" href="/assets/js/34.7b65401c.js"><link rel="prefetch" href="/assets/js/35.31b0aeaa.js"><link rel="prefetch" href="/assets/js/36.c93744e9.js"><link rel="prefetch" href="/assets/js/38.939dfb29.js"><link rel="prefetch" href="/assets/js/39.05749514.js"><link rel="prefetch" href="/assets/js/4.7d932259.js"><link rel="prefetch" href="/assets/js/40.d517694b.js"><link rel="prefetch" href="/assets/js/41.a7178842.js"><link rel="prefetch" href="/assets/js/42.d2067a3d.js"><link rel="prefetch" href="/assets/js/43.99404503.js"><link rel="prefetch" href="/assets/js/44.64ecbf2b.js"><link rel="prefetch" href="/assets/js/45.df22fe66.js"><link rel="prefetch" href="/assets/js/46.5233a8b7.js"><link rel="prefetch" href="/assets/js/47.e49bafbe.js"><link rel="prefetch" href="/assets/js/48.b77136bc.js"><link rel="prefetch" href="/assets/js/49.0340ff29.js"><link rel="prefetch" href="/assets/js/5.8ee7bf61.js"><link rel="prefetch" href="/assets/js/50.3d8cedd0.js"><link rel="prefetch" href="/assets/js/6.e9a729c7.js"><link rel="prefetch" href="/assets/js/7.4b0de641.js"><link rel="prefetch" href="/assets/js/8.c896fb93.js"><link rel="prefetch" href="/assets/js/9.eca79ebb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.617c345f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无所不能的前端--十万个为什么</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>计算机基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>库</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/library/axios.html" class="sidebar-link">Axios</a></li><li><a href="/library/babel.html" class="sidebar-link">Babel</a></li><li><a href="/library/docker.html" class="sidebar-link">Docker</a></li><li><a href="/library/egg.html" class="sidebar-link">Egg</a></li><li><a href="/library/express.html" class="sidebar-link">express</a></li><li><a href="/library/koa.html" class="sidebar-link">koa</a></li><li><a href="/library/nest.html" class="sidebar-link">NestJS</a></li><li><a href="/library/nginx.html" class="sidebar-link">Nginx</a></li><li><a href="/library/pm2.html" class="sidebar-link">PM2</a></li><li><a href="/library/react.html" class="sidebar-link">React</a></li><li><a href="/library/react_native.html" class="sidebar-link">React Native</a></li><li><a href="/library/redux.html" class="sidebar-link">redux</a></li><li><a href="/library/rollup.html" class="sidebar-link">Rollup</a></li><li><a href="/library/taro.html" class="sidebar-link">Taro</a></li><li><a href="/library/typescript.html" class="sidebar-link">Typescript</a></li><li><a href="/library/vue.html" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/vue.html#应用" class="sidebar-link">应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/vue.html#为什么子组件不能修改父组件传入的props？" class="sidebar-link">为什么子组件不能修改父组件传入的props？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#为什么vuex的mutation和redux的reducer只能用纯函数而不能用异步的？" class="sidebar-link">为什么Vuex的mutation和Redux的reducer只能用纯函数而不能用异步的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue的完整生命周期" class="sidebar-link">Vue的完整生命周期</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#父子组件间生命周期执行顺序是怎么样的？" class="sidebar-link">父子组件间生命周期执行顺序是怎么样的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？" class="sidebar-link">vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-nexttick-有什么用？使用场景是？如何实现的？" class="sidebar-link">Vue.nextTick()有什么用？使用场景是？如何实现的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#computed-和-watch-有什么区别及运用场景" class="sidebar-link">computed 和 watch 有什么区别及运用场景?</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue2怎么深度监听对象变化" class="sidebar-link">vue2怎么深度监听对象变化</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#v-model是什么？有什么用？" class="sidebar-link">v-model是什么？有什么用？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue2组件通信方式" class="sidebar-link">vue2组件通信方式</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue中常用的修饰符" class="sidebar-link">vue中常用的修饰符</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue中常用的内部指令" class="sidebar-link">vue中常用的内部指令</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#v-if和v-show区别？" class="sidebar-link">v-if和v-show区别？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-中-mixin-和-mixins-区别" class="sidebar-link">vue 中 mixin 和 mixins 区别?</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-router-中的导航钩子函数" class="sidebar-link">vue-router 中的导航钩子函数</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#route和-router的区别？" class="sidebar-link">$route和$router的区别？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#用-vue-的时候有没有遇到过难以解决的问题？（todo）" class="sidebar-link">用 Vue 的时候有没有遇到过难以解决的问题？（todo）</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#如何实现vue组件的异步加载" class="sidebar-link">如何实现vue组件的异步加载</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#不需要响应式的数据怎么处理？" class="sidebar-link">不需要响应式的数据怎么处理？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" class="sidebar-link">对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#prop怎么自定义校验？" class="sidebar-link">prop怎么自定义校验？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-config上的配置有哪些，作用是什么" class="sidebar-link">vue.config上的配置有哪些，作用是什么</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#如何重新渲染vue组件？" class="sidebar-link">如何重新渲染vue组件？</a></li></ul></li><li class="sidebar-sub-header"><a href="/library/vue.html#原理" class="sidebar-link">原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/vue.html#简单说明下vue2的全链路运行机制？" class="sidebar-link">简单说明下vue2的全链路运行机制？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue框架本身的生命周期是什么样子的？" class="sidebar-link">Vue框架本身的生命周期是什么样子的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#new-vue-发生了什么？" class="sidebar-link">new Vue 发生了什么？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#virtual-dom有什么用？" class="sidebar-link">virtual DOM有什么用？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue2-x中的virtual-dom到底是什么？如何实现的？" class="sidebar-link">Vue2.x中的virtual DOM到底是什么？如何实现的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#自己如何实现一个简单的virtual-dom系统？" class="sidebar-link">自己如何实现一个简单的virtual Dom系统？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue模板的编译过程介绍下？" class="sidebar-link">Vue模板的编译过程介绍下？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue中的key有什么用？为什么会优化diff算法的速度？" class="sidebar-link">Vue中的key有什么用？为什么会优化diff算法的速度？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-use使用插件，是如何实现的？" class="sidebar-link">Vue.use使用插件，是如何实现的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue中的数据响应式如何实现的？" class="sidebar-link">Vue中的数据响应式如何实现的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#聊聊-vue-的响应式，model-如何改变-view，view-又是如何改变-model-的" class="sidebar-link">聊聊 Vue 的响应式，Model 如何改变 View，View 又是如何改变 Model 的</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue哪些配置会做数据绑定" class="sidebar-link">vue哪些配置会做数据绑定</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-set到底在做什么？" class="sidebar-link">vue.set到底在做什么？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-delete的原理" class="sidebar-link">Vue.delete的原理</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue的响应式用proxy和object-defineproperty有什么区别？" class="sidebar-link">Vue的响应式用Proxy和Object.defineProperty有什么区别？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#为什么vue的模板必须要有一个根元素？" class="sidebar-link">为什么Vue的模板必须要有一个根元素？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue是如何实现事件系统的？" class="sidebar-link">Vue是如何实现事件系统的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue中的keep-alive是怎么实现的？越具体越好。" class="sidebar-link">Vue中的keep-alive是怎么实现的？越具体越好。</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue的mixin模式怎么实现的？" class="sidebar-link">Vue的mixin模式怎么实现的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue3做了哪些优化？" class="sidebar-link">Vue3做了哪些优化？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue3的hook和react的区别？" class="sidebar-link">vue3的hook和React的区别？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue的re-render和react的re-render的区别？" class="sidebar-link">vue的re-render和React的re-render的区别？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#data为什么是个函数" class="sidebar-link">data为什么是个函数</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#v-if和v-for为什么不能在同一个标签？" class="sidebar-link">v-if和v-for为什么不能在同一个标签？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue2中的指令是如何解析的？" class="sidebar-link">vue2中的指令是如何解析的？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#vue-router初始化时做了什么？" class="sidebar-link">vue-router初始化时做了什么？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#router-view组件做了什么？" class="sidebar-link">router-view组件做了什么？</a></li><li class="sidebar-sub-header"><a href="/library/vue.html#路由跳转的方法实现？" class="sidebar-link">路由跳转的方法实现？</a></li></ul></li><li class="sidebar-sub-header"><a href="/library/vue.html#编码" class="sidebar-link">编码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/library/vue.html#实现一个vue的懒加载指令（todo）" class="sidebar-link">实现一个vue的懒加载指令（todo）</a></li></ul></li></ul></li><li><a href="/library/webpack.html" class="sidebar-link">Webpack</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web工程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>企业</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> Vue</h1> <h2 id="应用"><a href="#应用" aria-hidden="true" class="header-anchor">#</a> 应用</h2> <h3 id="为什么子组件不能修改父组件传入的props？"><a href="#为什么子组件不能修改父组件传入的props？" aria-hidden="true" class="header-anchor">#</a> 为什么子组件不能修改父组件传入的props？</h3> <p>首先从设计原则上来说，为了<strong>保证数据的单向流动</strong>，便于对数据进行追踪，避免数据混乱。</p> <p>其次从代码实现上来说，<strong>每当父组件属性值修改时，该值都将被覆盖</strong>。</p> <p>至于Vue如何限制并警告，就是通过Object.defineProperty这个API来拦截该属性的修改。</p> <blockquote><p>需要特别注意的是，当你从子组件修改的prop属于基础类型时会触发提示。 这种情况下，你是无法修改父组件的数据源的， 因为基础类型赋值时是值拷贝。你直接将另一个非基础类型（Object, array）赋值到此key时也会触发提示(但实际上不会影响父组件的数据源)， 当你修改object的属性时不会触发提示，并且会修改父组件数据源的数据。</p></blockquote> <p>参考地址：</p> <p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/60" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="为什么vuex的mutation和redux的reducer只能用纯函数而不能用异步的？"><a href="#为什么vuex的mutation和redux的reducer只能用纯函数而不能用异步的？" aria-hidden="true" class="header-anchor">#</a> 为什么Vuex的mutation和Redux的reducer只能用纯函数而不能用异步的？</h3> <p><strong>异步操作是成功还是失败不可预测，什么时候进行异步操作也不可预测</strong>；当异步操作成功或失败时，如果不 commit(mutation) 或者 dispatch(action)，Vuex 和 Redux 就不能捕获到异步的结果从而进行相应的操作。</p> <p>要在reducer中加入异步的操作，如果你只是单纯想执行异步操作，不会等待异步的返回，那么在reducer中执行的意义是什么。如果想把异步操作的结果反应在state中，首先整个应用的状态将变的不可预测，违背Redux的设计原则。</p> <p>参考地址：</p> <p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/65" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue的完整生命周期"><a href="#vue的完整生命周期" aria-hidden="true" class="header-anchor">#</a> Vue的完整生命周期</h3> <p>Vue 一共有 8 个生命阶段，分别是创建前、创建后、加载前、加载后、更新前、更新后、销毁 前和销毁后，每个阶段对应了一个生命周期的钩子函数。</p> <p>(1)beforeCreate 钩子函数，在实例初始化之后，在数据监听和事件配置之前触发。因此在 这个事件中我们是获取不到 data 数据的。</p> <p>(2)created 钩子函数，在实例创建完成后触发，此时可以访问 data、methods 等属性。但 这个时候组件还没有被挂载到页面中去，所以这个时候访问不到 $el 属性。一般我们可以在这 个函数中进行一些页面初始化的工作，比如通过 ajax 请求数据来对页面进行初始化。</p> <p>(3)beforeMount 钩子函数，在组件被挂载到页面之前触发。在 beforeMount 之前，会找 到对应的 template，并编译成 render 函数。</p> <p>(4)mounted 钩子函数，在组件挂载到页面之后触发。此时可以通过 DOM API 获取到页面中 的 DOM 元素。</p> <p>(5)beforeUpdate 钩子函数，在响应式数据更新时触发，发生在虚拟 DOM 重新渲染和打补 丁之前，这个时候我们可以对可能会被移除的元素做一些操作，比如移除事件监听器。</p> <p>(6)updated 钩子函数，虚拟 DOM 重新渲染和打补丁之后调用。</p> <p>(7)beforeDestroy 钩子函数，在实例销毁之前调用。一般在这一步我们可以销毁定时器、 解绑全局事件等。</p> <p>(8)destroyed 钩子函数，在实例销毁之后调用，调用后，Vue 实例中的所有东西都会解除 绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p> <p>当我们使用 keep-alive 的时候，还有两个钩子函数，分别是 activated 和 deactivated 。 用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数。</p> <blockquote><p>需要修改能重新render的数据后才会触发update相关生命周期，其他数据不会触发。</p></blockquote> <p>参考：</p> <p><a href="https://juejin.cn/entry/6844903602356502542" target="_blank" rel="noopener noreferrer">vue 生命周期深入 - 前端<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="父子组件间生命周期执行顺序是怎么样的？"><a href="#父子组件间生命周期执行顺序是怎么样的？" aria-hidden="true" class="header-anchor">#</a> 父子组件间生命周期执行顺序是怎么样的？</h3> <p>加载渲染过程
<strong>父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created</strong>-&gt;子beforeMount-&gt;<strong>子mounted-&gt;父mounted</strong></p> <p>子组件更新过程
父beforeUpdate-&gt;子beforeUpdate-&gt;子updated-&gt;父updated</p> <p>父组件更新过程
父beforeUpdate-&gt;父updated</p> <p>销毁过程
父beforeDestroy-&gt;子beforeDestroy-&gt;<strong>子destroyed-&gt;父destroyed</strong></p> <h3 id="vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？"><a href="#vue-在-created-和-mounted-这两个生命周期中请求数据有什么区别呢？" aria-hidden="true" class="header-anchor">#</a> vue 在 created 和 mounted 这两个生命周期中请求数据有什么区别呢？</h3> <p>看实际情况，一般在created（或beforeRouter） 里面就可以，如果涉及到需要页面加载完成之后的话就用mounted。</p> <p>在created 的时候，视图中的 html 并没有渲染出来，所以此时如果直接去操作 html 的dom节点，一定找不到相关的元素</p> <p>而在mounted 中，由于此时html 已经渲染出来了，所以可以直接操作 dom 节点，（此时document.getElementById 即可生效了）。</p> <h3 id="vue-nexttick-有什么用？使用场景是？如何实现的？"><a href="#vue-nexttick-有什么用？使用场景是？如何实现的？" aria-hidden="true" class="header-anchor">#</a> Vue.nextTick()有什么用？使用场景是？如何实现的？</h3> <p>官方文档的解释是：<strong>为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 Vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。</strong></p> <p>所以说在这么几个场景下，要用到：</p> <ul><li>在Vue生命周期的<strong>created()钩子函数进行的DOM操作</strong>一定要放在Vue.nextTick()的回调函数中</li> <li>在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的DOM结构的时候，这个操作都应该放进Vue.nextTick()的回调函数中。</li></ul> <p>至于nextTick是如何实现的？首先需要理解<a href="/language/javascript.html#任务队列机制">js的任务队列机制</a>，每一次执行的主线程，就是一个tick。</p> <p>在Vue中，nextTick中声明了microTimerFunc 和 macroTimerFunc 2 个变量，它们分别对应的是 micro task 的函数和 macro task 的函数。<strong>对于 macro task 的实现，优先检测是否支持原生 setImmediate，这是一个高版本 IE 和 Edge 才支持的特性，不支持的话再去检测是否支持原生的 MessageChannel，如果也不支持的话就会降级为 setTimeout 0</strong>；而<strong>对于 micro task 的实现，则检测浏览器是否原生支持 Promise，不支持的话直接指向 macro task 的实现</strong>。</p> <p>nextTick函数的逻辑，就是将传入的回调函数 cb 压入 callbacks 数组，最后一次性地根据 useMacroTask 条件执行 macroTimerFunc 或者是 microTimerFunc，<strong>useMacroTask条件的判断依据就是传入的回调函数中是否有操作state的行为，如果有就认为ture</strong>。</p> <p>具体的业务场景：</p> <blockquote><p>交互是弹框编辑一个很大的字符串。因内容大，弹框弹出慢，为给用户反馈，先遮罩层loading，然后弹框，弹出后，再遮罩层loading
如果没有nexttick的话，遮罩层loading的过程就看不到了,或者是一闪而过</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  <span class="token function-variable function">showEditModal</span><span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>$Spin<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>modal<span class="token punctuation">.</span>edit <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$Spin<span class="token punctuation">.</span><span class="token function">hide</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>具体源码位于<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/util/next-tick.js#L78" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://ustbhuangyi.github.io/vue-analysis/reactive/next-tick.html#vue-%E7%9A%84%E5%AE%9E%E7%8E%B0" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6875492931726376974#comment" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="computed-和-watch-有什么区别及运用场景"><a href="#computed-和-watch-有什么区别及运用场景" aria-hidden="true" class="header-anchor">#</a> computed 和 watch 有什么区别及运用场景?</h3> <p>区别</p> <p>computed 计算属性 : 依赖其它属性值,并且 computed 的值有缓存,只有它依赖的属性值发生改变,下一次获取 computed 的值时才会重新计算 computed 的值。computed不能进行异步操作。</p> <p>watch 侦听器 : 更多的是「观察」的作用,<strong>无缓存性</strong>,类似于某些数据的监听回调,每当监听的数据变化时都会执行回调进行后续操作。watch可以进行异步操作。</p> <p>运用场景：</p> <p>当我们需要进行数值计算,并且<strong>依赖于其它数据</strong>时,应该使用 computed,因为可以利用 computed 的缓存特性,<strong>避免每次获取值时,都要重新计算</strong>。</p> <p>当我们需要<strong>在数据变化时执行异步或开销较大的操作时,应该使用 watch</strong>,使用  watch  选项允许我们执行异步操作 ( 访问一个 API ),限制我们执行该操作的频率,并在我们得到最终结果前,设置中间状态。这些都是计算属性无法做到的。</p> <p>具体业务场景：</p> <ul><li>computed：接口路径由很多参数拼接起来。组件中使用vuex的state可以会用到。</li> <li>watch: 监听详情页id，调用详情接口。</li></ul> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903678533451783" target="_blank" rel="noopener noreferrer">做面试的不倒翁：浅谈 Vue 中 computed 实现原理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903605485436941" target="_blank" rel="noopener noreferrer">深入理解Vue的watch实现原理及其实现方式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue2怎么深度监听对象变化"><a href="#vue2怎么深度监听对象变化" aria-hidden="true" class="header-anchor">#</a> vue2怎么深度监听对象变化</h3> <p>watch的deep属性设为true即可。</p> <div class="language-js extra-class"><pre class="language-js"><code>  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">a</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'new: %s, old: %s'</span><span class="token punctuation">,</span> val<span class="token punctuation">,</span> oldVal<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token comment">// 方法名</span>
    b<span class="token punctuation">:</span> <span class="token string">'someMethod'</span><span class="token punctuation">,</span>
    <span class="token comment">// 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深</span>
    c<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">handler</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> oldVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
      deep<span class="token punctuation">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="v-model是什么？有什么用？"><a href="#v-model是什么？有什么用？" aria-hidden="true" class="header-anchor">#</a> v-model是什么？有什么用？</h3> <p>一则语法糖，相当于 v-bind:value=&quot;xxx&quot; 和 @input，意思是绑定了一个 value 属性的值，子组件可对value 属性监听，通过$emit('input', xxx)的方式给父组件通讯。自己实现model 方式的组件也是这样的思路。</p> <p>自定义事件也可以用于创建支持 v-model 的自定义输入组件。记住：</p> <div class="language-html extra-class"><pre class="language-html"><code>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-model</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>等价于：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText = $event.target.value<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span>
</code></pre></div><p>当用在组件上时，v-model 则会这样：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>custom-input</span>
  <span class="token attr-name"><span class="token namespace">v-bind:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText<span class="token punctuation">&quot;</span></span>
  <span class="token attr-name"><span class="token namespace">v-on:</span>input</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>searchText = $event<span class="token punctuation">&quot;</span></span>
<span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>custom-input</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p><a href="https://github.com/FunnyLiu/vue/blob/readsource/src/platforms/web/compiler/directives/model.js#L127" target="_blank" rel="noopener noreferrer">具体源码实现<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue2组件通信方式"><a href="#vue2组件通信方式" aria-hidden="true" class="header-anchor">#</a> vue2组件通信方式</h3> <h4 id="父子组件之间："><a href="#父子组件之间：" aria-hidden="true" class="header-anchor">#</a> 父子组件之间：</h4> <ul><li>props和$emit</li></ul> <p>父组件通过v-bind绑定数据，子组件通过props接收父组件传过来的数据，利用$emit触发指定事件，父组件通过$on监听子组件触发的对应事件</p> <ul><li>v-model</li></ul> <p>本质是v-bind和v-on的语法糖，在一个组件上使用v-model，默认会为组件绑定名为value的属性和名为input的事件</p> <ul><li>.sync</li></ul> <p>.sync修饰符它的本质和v-model类似，它的本质也是v-bind和v-on的语法糖</p> <ul><li>$parent、$children和ref</li></ul> <p>直接得到组件实例，可以实现父子组件、兄弟组件、跨级组件等数据通信</p> <p>$children场景：类似select相关组件，option是通过slot传入的，select组件中通过$children获取option列表然后通过当前value更新选中状态。<a href="https://github.com/iview/iview/blob/v2.14.3/src/components/select/select.vue#L91" target="_blank" rel="noopener noreferrer">示例代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h4 id="跨级组件通信"><a href="#跨级组件通信" aria-hidden="true" class="header-anchor">#</a> 跨级组件通信</h4> <ul><li>$attrs</li></ul> <p>将父组件直接传递给孙组件</p> <ul><li>inheritAttrs</li></ul> <p>默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。</p> <ul><li>$listeners</li></ul> <p>上面讲了$attrs是为了跨组件传递数据，那如果想通过孙子组件来给父组件传递数据呢？之前的做法也是一层一层的向上传递，比如用$emit方法，但是子组件如果用不到，只是想改变父组件的数据，这时候我们就可以使用$listeners。</p> <p>业务场景：表单弹框组件，相当于将组件包了一层，使用$attrs传参数，$listeners抛事件，减少不必要代码。</p> <ul><li>provide和inject</li></ul> <p>允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件嵌套的层次有多深，并在起上下游关系成立的时间里始终有效。一言以蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。</p> <p>业务场景：锚点组件provide提供数据，子孙组件通过inject接受，如传递父组件实例，点击时调用该组件的方法。因为子链接组件嵌套逻辑复杂 <a href="https://github.com/iview/iview/blob/v3.5.1/src/components/anchor/anchor.vue#L18" target="_blank" rel="noopener noreferrer">示例代码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <ul><li><p>通过中央事件总线（Event Bus）</p></li> <li><p>全局状态管理vuex</p></li></ul> <h3 id="vue中常用的修饰符"><a href="#vue中常用的修饰符" aria-hidden="true" class="header-anchor">#</a> vue中常用的修饰符</h3> <p>.prevent: 提交事件不再重载页面;</p> <p>.stop: 阻止单击事件冒泡;</p> <p>.self: 当事件发生在该元 素本身而不是子元素的时候会触发;</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210914093208.png"> <h3 id="vue中常用的内部指令"><a href="#vue中常用的内部指令" aria-hidden="true" class="header-anchor">#</a> vue中常用的内部指令</h3> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20210914093249.png"> <h3 id="v-if和v-show区别？"><a href="#v-if和v-show区别？" aria-hidden="true" class="header-anchor">#</a> v-if和v-show区别？</h3> <p>1.v-if是通过控制dom元素的删除和生成来实现显隐，每一次显隐都会使组件重新跑一遍生命周期，因为显隐决定了组件的生成和销毁</p> <p>2.v-show是通过控制dom元素的css样式来实现显隐，不会销毁</p> <p>3.频繁或者大数量显隐使用v-show，否则使用v-if</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/h2H-36iVeoyXsorZChwxyQ" target="_blank" rel="noopener noreferrer">熬夜总结50个Vue知识点，全都会你就是神！！！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue-中-mixin-和-mixins-区别"><a href="#vue-中-mixin-和-mixins-区别" aria-hidden="true" class="header-anchor">#</a> vue 中 mixin 和 mixins 区别?</h3> <p>mixin 用于全局混入，会影响到每个组件实例。</p> <p>mixins 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以 将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种逻辑等等。另外需 要注意的是 mixins 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时 候也会有选择性的进行合并</p> <p>参考：</p> <p><a href="https://cn.vuejs.org/v2/guide/mixins.html" target="_blank" rel="noopener noreferrer">混入 — Vue.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue-router-中的导航钩子函数"><a href="#vue-router-中的导航钩子函数" aria-hidden="true" class="header-anchor">#</a> vue-router 中的导航钩子函数</h3> <p>(1)全局的钩子函数 beforeEach 和 afterEach。beforeEach 有三个参数，to 代表要进入的路由对象，from 代表离开的路由对象。next 是一 个必须要执行的函数，如果不传参数，那就执行下一个钩子函数，如果传入 false，则终止跳 转，如果传入一个路径，则导航到对应的路由，如果传入 error ，则导航终止，error 传入错 误的监听函数。</p> <p>(2)单个路由独享的钩子函数 beforeEnter，它是在路由配置上直接进行定义的。</p> <p>(3)组件内的导航钩子主要有这三种:beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave。它们是直接在路由组件内部直接进行定义的。</p> <h3 id="route和-router的区别？"><a href="#route和-router的区别？" aria-hidden="true" class="header-anchor">#</a> $route和$router的区别？</h3> <p>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p> <p>参考：</p> <p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html" target="_blank" rel="noopener noreferrer">导航守卫 | Vue Router<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="用-vue-的时候有没有遇到过难以解决的问题？（todo）"><a href="#用-vue-的时候有没有遇到过难以解决的问题？（todo）" aria-hidden="true" class="header-anchor">#</a> 用 Vue 的时候有没有遇到过难以解决的问题？（todo）</h3> <ul><li><p>slot事件监听</p></li> <li><p>组件库无法高阶组件套用，从而达到修改模板的目的</p></li> <li><p>vue中透传参数，需要一个个在模板中传递，或者$attrs全部透传；而React则可以通过扩展运算符来解决</p></li></ul> <h3 id="如何实现vue组件的异步加载"><a href="#如何实现vue组件的异步加载" aria-hidden="true" class="header-anchor">#</a> 如何实现vue组件的异步加载</h3> <p>下面PublicForm的引入方式会单独构建成一个js文件，模板中通过v-if来动态载入。PickPublicModal会和当前组件打包在一起。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/*组件*/</span>
<span class="token keyword">import</span> PickPublicModal <span class="token keyword">from</span> <span class="token string">'@/components/common/pick-public-modal.vue'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">PublicForm</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">'@/components/public-assets/public/public-form/new-form'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    PickPublicModal<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="不需要响应式的数据怎么处理？"><a href="#不需要响应式的数据怎么处理？" aria-hidden="true" class="header-anchor">#</a> 不需要响应式的数据怎么处理？</h3> <p>在我们的Vue开发中，会有一些数据，从始至终都未曾改变过，这种死数据，既然不改变，那也就不需要对他做响应式处理了，不然只会做一些无用功消耗性能，比如一些写死的下拉框，写死的表格数据，这些数据量大的死数据，如果都进行响应式处理，那会消耗大量性能。</p> <div class="language-js extra-class"><pre class="language-js"><code>
<span class="token comment">// 方法一：将数据定义在data之外</span>
<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>list1 <span class="token operator">=</span> <span class="token punctuation">{</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>list2 <span class="token operator">=</span> <span class="token punctuation">{</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>list3 <span class="token operator">=</span> <span class="token punctuation">{</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>list4 <span class="token operator">=</span> <span class="token punctuation">{</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>list5 <span class="token operator">=</span> <span class="token punctuation">{</span> xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
    
<span class="token comment">// 方法二：Object.freeze()</span>
<span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        list1<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span>xxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        list2<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span>xxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        list3<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span>xxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        list4<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span>xxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        list5<span class="token punctuation">:</span> Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span><span class="token punctuation">{</span>xxxxxxxxxxxxxxxxxxxxxxxx<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/h2H-36iVeoyXsorZChwxyQ" target="_blank" rel="noopener noreferrer">熬夜总结50个Vue知识点，全都会你就是神！！！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？"><a href="#对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？" aria-hidden="true" class="header-anchor">#</a> 对象新属性无法更新视图，删除属性无法更新视图，为什么？怎么办？</h3> <p>原因：Object.defineProperty没有对对象的新属性进行属性劫持</p> <p>对象新属性无法更新视图：使用Vue.$set(obj, key, value)，组件中this.$set(obj, key, value)</p> <p>删除属性无法更新视图：使用Vue.$delete(obj, key)，组件中this.$delete(obj, key)</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/h2H-36iVeoyXsorZChwxyQ" target="_blank" rel="noopener noreferrer">熬夜总结50个Vue知识点，全都会你就是神！！！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="prop怎么自定义校验？"><a href="#prop怎么自定义校验？" aria-hidden="true" class="header-anchor">#</a> prop怎么自定义校验？</h3> <div class="language-js extra-class"><pre class="language-js"><code>props<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    num<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token keyword">default</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token function-variable function">validator</span><span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 返回值为true则验证不通过，报错</span>
          <span class="token keyword">return</span> <span class="token punctuation">[</span>
            <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span>
          <span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token operator">-</span><span class="token number">1</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
</code></pre></div><h3 id="vue-config上的配置有哪些，作用是什么"><a href="#vue-config上的配置有哪些，作用是什么" aria-hidden="true" class="header-anchor">#</a> vue.config上的配置有哪些，作用是什么</h3> <p>常用<code>productionTip</code>设置为 false 以阻止 vue 在启动时生成生产提示。</p> <p><a href="https://cn.vuejs.org/v2/api/#%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="如何重新渲染vue组件？"><a href="#如何重新渲染vue组件？" aria-hidden="true" class="header-anchor">#</a> 如何重新渲染vue组件？</h3> <p>强制 Vue 重新渲染组件的最佳方法是在组件上设置:key。当我们需要重新渲染组件时，只需更 key 的值，Vue 就会重新渲染组件。</p> <p>这是一个非常简单的解决方案。</p> <p>当然，你可能会对其他方式会更感兴趣：</p> <p>简单粗暴的方式：重新加载整个页面</p> <p>不妥的方式：使用 v-if</p> <p>较好的方法：使用Vue的内置forceUpdate方法</p> <p>最好的方法：在组件上进行 key 更改</p> <p>参考：</p> <p><a href="https://blog.csdn.net/qq449245884/article/details/104057886" target="_blank" rel="noopener noreferrer">Vue 中 强制组件重新渲染的正确方法_粉丝们务必加入微信粉丝群-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="原理"><a href="#原理" aria-hidden="true" class="header-anchor">#</a> 原理</h2> <h3 id="简单说明下vue2的全链路运行机制？"><a href="#简单说明下vue2的全链路运行机制？" aria-hidden="true" class="header-anchor">#</a> 简单说明下vue2的全链路运行机制？</h3> <p>初始化以及挂载init, mount</p> <p>在进行模板编译compile，将template编译为渲染函数render function</p> <p>执行render function生成Virtual DOM, render function =&gt; VNode tree</p> <p>再进行响应式依赖收集，render function =&gt; getter, setter =&gt; Watcher.update =&gt; patch。以及使用队列进行异步更新的策略。</p> <p>最后通过diff算法后进行patch更新视图</p> <h3 id="vue框架本身的生命周期是什么样子的？"><a href="#vue框架本身的生命周期是什么样子的？" aria-hidden="true" class="header-anchor">#</a> Vue框架本身的生命周期是什么样子的？</h3> <p>一张图总结：</p> <p><img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200103155422.png" alt=""></p> <p>首先是<a href="https://github.com/FunnyLiu/vue/tree/readsource#%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" target="_blank" rel="noopener noreferrer">Vue的初始化<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，在其生命周期过程中，对<a href="https://github.com/FunnyLiu/vue/tree/readsource#%E6%95%B0%E6%8D%AE%E8%A7%82%E5%AF%9F" target="_blank" rel="noopener noreferrer">数据进行监听<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，对<a href="https://github.com/FunnyLiu/vue/tree/readsource#%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener noreferrer">模板进行编译<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>生成给render函数的字符串。通过render函数，进入patch阶段，进行<a href="https://github.com/FunnyLiu/vue/tree/readsource#vnode%E7%9A%84%E6%9B%B4%E6%96%B0%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener noreferrer">VNode的diff<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>以及生成真正的dom进行挂载。</p> <h3 id="new-vue-发生了什么？"><a href="#new-vue-发生了什么？" aria-hidden="true" class="header-anchor">#</a> new Vue 发生了什么？</h3> <p>Vue 初始化主要就干了几件事情，合并配置，初始化生命周期，初始化事件中心，初始化渲染，初始化 data、props、computed、watcher 等等。具体源码位于<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/init.js#L54" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>参考：</p> <p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/data-driven/new-vue.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener noreferrer">new Vue 发生了什么 | Vue.js 技术揭秘<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="virtual-dom有什么用？"><a href="#virtual-dom有什么用？" aria-hidden="true" class="header-anchor">#</a> virtual DOM有什么用？</h3> <p>我们知道，Vue是数据驱动视图的，数据发生变化视图就要随之更新，在更新视图的时候难免要操作DOM,而操作真实DOM又是非常耗费性能的，这是因为浏览器的标准就把 DOM 设计的非常复杂，所以一个真正的 DOM 元素是非常庞大的。</p> <p>我们可以用JS模拟出一个DOM节点，称之为虚拟DOM节点。当数据发生变化时，我们对比变化前后的虚拟DOM节点，通过DOM-Diff算法计算出需要更新的地方，然后去更新需要更新的视图。</p> <p>这就是虚拟DOM产生的原因以及最大的用途。</p> <p>我认为 Virtual DOM 这种方法对于我们需要有大量的 DOM 操作的时候，能够很好的提高我们 的操作效率，通过在操作前确定需要做的最小修改，尽可能的减少 DOM 操作带来的重流和重绘 的影响。其实 Virtual DOM 并不一定比我们真实的操作 DOM 要快，这种方法的目的是为了提 高我们开发时的可维护性，在任意的情况下，都能保证一个尽量小的性能消耗去进行操作。</p> <p>参考文档：</p> <p><a href="https://github.com/y8n/blog/issues/5" target="_blank" rel="noopener noreferrer">理解 Virtual DOM · Issue #5 · y8n/blog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue2-x中的virtual-dom到底是什么？如何实现的？"><a href="#vue2-x中的virtual-dom到底是什么？如何实现的？" aria-hidden="true" class="header-anchor">#</a> Vue2.x中的virtual DOM到底是什么？如何实现的？</h3> <p>Vue的virtual DOM参考了开源库<a href="https://github.com/snabbdom/snabbdom" target="_blank" rel="noopener noreferrer">snabbdom<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的实现。</p> <h4 id="vnode的定义"><a href="#vnode的定义" aria-hidden="true" class="header-anchor">#</a> VNode的定义</h4> <p>在vue中，vitrual dom是通过VNode这个class去描述的：<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/vdom/vnode.js" target="_blank" rel="noopener noreferrer">VNode Class<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其它属性都是都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。</p> <p>由于 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是<strong>非常轻量和简单的</strong>。</p> <p>Virtual DOM 除了它的数据结构的定义，映射到真实的 DOM 实际上要经历 VNode 的 create、diff、patch 等过程。那么在 Vue.js 中，VNode 的 create 是通过createElement 方法创建的，我们接下来分析这部分的实现。</p> <h4 id="vnode的创建"><a href="#vnode的创建" aria-hidden="true" class="header-anchor">#</a> VNode的创建</h4> <p>Vue.js 利用 createElement 方法创建 VNode，它定义在 <a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/vdom/create-element.js" target="_blank" rel="noopener noreferrer">src/core/vdom/create-elemenet.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中。</p> <p>每个 VNode 有 children，children 每个元素也是一个 VNode，这样就形成了一个 VNode Tree，它很好的描述了我们的 DOM Tree。</p> <p>回到 mountComponent 函数的过程，我们已经知道 vm._render 是如何创建了一个 VNode，接下来就是要<strong>把这个 VNode 渲染成一个真实的 DOM 并渲染出来</strong>。</p> <h4 id="vnode的渲染更新"><a href="#vnode的渲染更新" aria-hidden="true" class="header-anchor">#</a> VNode的渲染更新</h4> <p>Vue 的 _update 是实例的一个私有方法，它被调用的时机有 2 个，一个是首次渲染，一个是数据更新的时候；<strong>_update 方法的作用是把 VNode 渲染成真实的 DOM</strong>，它的定义在 <a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/lifecycle.js#L59" target="_blank" rel="noopener noreferrer">src/core/instance/lifecycle.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 中。</p> <p>其实就是<strong>调用原生 DOM 的 API 进行 DOM 操作</strong>。</p> <p>在 createElm 过程中，如果 vnode 节点不包含 tag，则它有可能是一个注释或者纯文本节点，可以直接插入到父元素中。</p> <p>再回到 patch 方法，首次渲染我们调用了 createElm 方法，这里传入的 parentElm 是 oldVnode.elm 的父元素。</p> <p>实际上<strong>整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上</strong>。
最后，我们根据之前递归 createElm 生成的 vnode 插入顺序队列，执行相关的 insert 钩子函数</p> <hr> <h3 id="自己如何实现一个简单的virtual-dom系统？"><a href="#自己如何实现一个简单的virtual-dom系统？" aria-hidden="true" class="header-anchor">#</a> 自己如何实现一个简单的virtual Dom系统？</h3> <p>参考<a href="https://github.com/FunnyLiu/million/tree/readsource" target="_blank" rel="noopener noreferrer">million<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的实现。一个极简的virtual dom库。</p> <h4 id="基本工作流程"><a href="#基本工作流程" aria-hidden="true" class="header-anchor">#</a> 基本工作流程</h4> <p>提供3个方法m、createElement和patch。</p> <p>m用来创建虚拟dom，createElement用来将虚拟dom变为现实dom，patch用来比较和diff老的和新的两个虚拟dom并返回改变后的虚拟dom。</p> <p>从下面一个例子可以看出3个函数分别在做什么？</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> m<span class="token punctuation">,</span> createElement<span class="token punctuation">,</span> patch <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'https://unpkg.com/million?module'</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> clicks <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span>
  <span class="token function">m</span><span class="token punctuation">(</span>
    <span class="token string">'button'</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      id<span class="token punctuation">:</span> <span class="token string">'app'</span><span class="token punctuation">,</span>
      <span class="token function-variable function">onclick</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">patch</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token string">'app'</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token operator">++</span>clicks<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token function">String</span><span class="token punctuation">(</span>clicks<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>app<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="创建虚拟dom"><a href="#创建虚拟dom" aria-hidden="true" class="header-anchor">#</a> 创建虚拟dom</h4> <p>m函数位于<a href="https://github.com/FunnyLiu/million/blob/readsource/src/m.ts#L53" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>三个参数，标签、属性对象、子dom</p> <p>主要实现如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> m <span class="token operator">=</span> <span class="token punctuation">(</span>tag<span class="token punctuation">:</span> string<span class="token punctuation">,</span> props<span class="token operator">?</span><span class="token punctuation">:</span> VProps<span class="token punctuation">,</span> children<span class="token operator">?</span><span class="token punctuation">:</span> VNode<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> flag<span class="token operator">?</span><span class="token punctuation">:</span> VFlags<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token parameter">VElement</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> key<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>props<span class="token operator">?</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    key <span class="token operator">=</span> <span class="token operator">&lt;</span>string <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token operator">&gt;</span>props<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> props<span class="token punctuation">.</span>key<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    tag<span class="token punctuation">,</span>
    props<span class="token punctuation">,</span>
    children<span class="token punctuation">,</span>
    key<span class="token punctuation">,</span>
    flag<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>就是返回了一个对象而已</p> <h4 id="将虚拟dom转为真实dom"><a href="#将虚拟dom转为真实dom" aria-hidden="true" class="header-anchor">#</a> 将虚拟dom转为真实dom</h4> <p>createElement实现<a href="https://github.com/FunnyLiu/million/blob/readsource/src/createElement.ts#L9" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>创建dom、属性、递归子dom</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> createElement <span class="token operator">=</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">:</span> VNode<span class="token punctuation">,</span> attachField <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLElement <span class="token operator">|</span> <span class="token parameter">Text</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> vnode <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>vnode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//创建dom</span>
  <span class="token keyword">const</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>tag<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//赋予dom属性</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> name <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">[</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> vnode<span class="token punctuation">.</span>props<span class="token punctuation">[</span>name<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//如果有子节点则递归创建子dom</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> vnode<span class="token punctuation">.</span>children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">createElement</span><span class="token punctuation">(</span>vnode<span class="token punctuation">.</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>attachField<span class="token punctuation">)</span> el<span class="token punctuation">[</span><span class="token constant">OLD_VNODE_FIELD</span><span class="token punctuation">]</span> <span class="token operator">=</span> vnode<span class="token punctuation">;</span>

  <span class="token keyword">return</span> el<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre></div><h4 id="diff新老虚拟dom"><a href="#diff新老虚拟dom" aria-hidden="true" class="header-anchor">#</a> diff新老虚拟dom</h4> <p>patch实现在此：<a href="https://github.com/FunnyLiu/million/blob/readsource/src/patch.ts#L74" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>实现流程如下：</p> <p>判断key不一致才diff，如果tag不同则直接替换。</p> <p>如果tag相同，就挨个排查prop。</p> <p>对于children则递归再patch来diff</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> patch <span class="token operator">=</span> <span class="token punctuation">(</span>
  el<span class="token punctuation">:</span> HTMLElement <span class="token operator">|</span> Text<span class="token punctuation">,</span>
  newVNode<span class="token punctuation">:</span> VNode<span class="token punctuation">,</span>
  prevVNode<span class="token operator">?</span><span class="token punctuation">:</span> VNode<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> HTMLElement <span class="token operator">|</span> <span class="token parameter">Text</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token comment">//没有新dom则直接移除老dom</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>newVNode<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 删除当前dom本身</span>
    <span class="token comment">// [Element.remove() - Web APIs | MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/remove)</span>
    el<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> el<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">const</span> oldVNode<span class="token punctuation">:</span> VNode <span class="token operator">|</span> <span class="token keyword">undefined</span> <span class="token operator">=</span> prevVNode <span class="token operator">?</span><span class="token operator">?</span> el<span class="token punctuation">[</span><span class="token constant">OLD_VNODE_FIELD</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> hasString <span class="token operator">=</span> <span class="token keyword">typeof</span> oldVNode <span class="token operator">===</span> <span class="token string">'string'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> newVNode <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">;</span>
  <span class="token comment">//如果是字符串类型，直接替换</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>hasString <span class="token operator">&amp;&amp;</span> oldVNode <span class="token operator">!==</span> newVNode<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">replaceElementWithVNode</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> newVNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasString<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>oldVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>key <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">||</span>
      <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>oldVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>key <span class="token operator">!==</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>key
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//都有key且key不同才进行diff</span>

      <span class="token comment">/* istanbul ignore if */</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>
        <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>oldVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>tag <span class="token operator">!==</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>tag <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>children <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>props
      <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果标签不同，直接全部替换</span>
        <span class="token comment">// newVNode has no props/children is replaced because it is generally</span>
        <span class="token comment">// faster to create a empty HTMLElement rather than iteratively/recursively</span>
        <span class="token comment">// remove props/children</span>
        <span class="token keyword">return</span> <span class="token function">replaceElementWithVNode</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> newVNode<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token comment">//如果标签相同，则替换属性</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>oldVNode <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>el <span class="token keyword">instanceof</span> <span class="token class-name">Text</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">patchProps</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>oldVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* istanbul ignore next */</span>
        <span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VFlags<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">case</span> VFlags<span class="token punctuation">.</span><span class="token constant">NO_CHILDREN</span><span class="token punctuation">:</span>
            el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">case</span> VFlags<span class="token punctuation">.</span><span class="token constant">ONLY_TEXT_CHILDREN</span><span class="token punctuation">:</span>
            el<span class="token punctuation">.</span>textContent <span class="token operator">=</span> <span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>children<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token keyword">default</span><span class="token punctuation">:</span>
            <span class="token comment">//再替换子dom</span>
            <span class="token comment">//本质还是递归patch</span>
            <span class="token function">patchChildren</span><span class="token punctuation">(</span>el<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>oldVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>children<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span>VElement<span class="token operator">&gt;</span>newVNode<span class="token punctuation">)</span><span class="token punctuation">.</span>children<span class="token operator">!</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>prevVNode<span class="token punctuation">)</span> el<span class="token punctuation">[</span><span class="token constant">OLD_VNODE_FIELD</span><span class="token punctuation">]</span> <span class="token operator">=</span> newVNode<span class="token punctuation">;</span>

  <span class="token keyword">return</span> el<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="vue模板的编译过程介绍下？"><a href="#vue模板的编译过程介绍下？" aria-hidden="true" class="header-anchor">#</a> Vue模板的编译过程介绍下？</h3> <p>参考<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/compiler/index.js#L24" target="_blank" rel="noopener noreferrer">笔记内容<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200113110026.png"> <p>编译compiler(src/compiler/index.js) 分为三个阶段：</p> <p>1.模板解析阶段(src/compiler/parser/index.js)：将一堆模板字符串用正则等方式解析成抽象语法树AST；</p> <p>2.优化阶段(src/compiler/optimizer.js)：遍历AST，找出其中的静态节点，并打上标记；方便Patch阶段的diff算法直接跳过静态节点；</p> <p>3.代码生成阶段(src/compiler/codegen/index.js)：将AST转换成渲染函数；直接生成render函数需要的函数字符串</p> <p>核心实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//模板编译器的入口文件</span>
<span class="token comment">//总体流程为：</span>
<span class="token comment">//将一堆字符串模板解析成抽象语法树AST后，我们就可以对其进行各种操作处理了，</span>
<span class="token comment">//处理完后用处理后的AST来生成render函数。其具体流程可大致分为三个阶段：</span>
<span class="token comment">//1.模板解析阶段：将一堆模板字符串用正则等方式解析成抽象语法树AST；</span>
<span class="token comment">//2.优化阶段：遍历AST，找出其中的静态节点，并打上标记；</span>
<span class="token comment">//3.代码生成阶段：将AST转换成渲染函数；</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> createCompiler <span class="token operator">=</span> <span class="token function">createCompilerCreator</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">baseCompile</span> <span class="token punctuation">(</span>
  <span class="token parameter">template<span class="token punctuation">:</span> string<span class="token punctuation">,</span>
  options<span class="token punctuation">:</span> CompilerOptions</span>
<span class="token punctuation">)</span><span class="token punctuation">:</span> CompiledResult <span class="token punctuation">{</span>
  <span class="token comment">//1.模板解析阶段</span>
  <span class="token comment">//通过解析html、text、过滤器等等，拿到了AST</span>
  <span class="token keyword">const</span> ast <span class="token operator">=</span> <span class="token function">parse</span><span class="token punctuation">(</span>template<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>optimize <span class="token operator">!==</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//2.优化阶段</span>
    <span class="token comment">//针对静态节点：有一种节点一旦首次渲染上了之后不管状态再怎么变化它都不会变了，这种节点叫做静态节点</span>
    <span class="token comment">//为了提高虚拟DOM中patch过程的性能。</span>
    <span class="token comment">//在优化阶段将所有静态节点都打上标记，这样在patch过程中就可以跳过对比这些节点。</span>
    <span class="token comment">//进行优化</span>
    <span class="token function">optimize</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token comment">//3.代码生成阶段</span>
  <span class="token comment">//最终生成的内容是render函数字符串</span>
  <span class="token comment">//所谓代码生成其实就是根据模板对应的抽象语法树AST生成一个函数，通过调用这个函数就可以得到模板对应的虚拟DOM</span>
  <span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token function">generate</span><span class="token punctuation">(</span>ast<span class="token punctuation">,</span> options<span class="token punctuation">)</span>
  <span class="token comment">//将生成的render函数字符串外传</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span>
    ast<span class="token punctuation">,</span>
    render<span class="token punctuation">:</span> code<span class="token punctuation">.</span>render<span class="token punctuation">,</span>
    staticRenderFns<span class="token punctuation">:</span> code<span class="token punctuation">.</span>staticRenderFns
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="vue中的key有什么用？为什么会优化diff算法的速度？"><a href="#vue中的key有什么用？为什么会优化diff算法的速度？" aria-hidden="true" class="header-anchor">#</a> Vue中的key有什么用？为什么会优化diff算法的速度？</h3> <p>首先我们要明白key的作用是什么：</p> <p><strong>key是给每一个vnode的唯一id,可以依靠key,更准确, 更快的拿到oldVnode中对应的vnode节点。</strong></p> <p>key的作用可参考 <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/1#issue-401165995" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>接下来看看Vue的diff算法。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710144357.png"> <p>组件更新的过程<strong>核心就是新旧 vnode diff</strong>，对新旧节点相同以及不同的情况分别做不同的处理。</p> <p><strong>新旧节点不同</strong>的更新流程是<strong>创建新节点-&gt;更新父占位符节点-&gt;删除旧节点</strong>；而<strong>新旧节点相同</strong>的更新流程是去获取它们的 children，根据不同情况做不同的更新逻辑。最复杂的情况是新旧节点相同且它们都存在子节点，那么会执行 updateChildren 逻辑。updateChildren的逻辑在<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/vdom/patch.js#L404" target="_blank" rel="noopener noreferrer">vdom/patch.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>我们看看updateChildren具体的示例：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710144727.png"> <p>oldCh和newCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，<strong>如果设置了key，就会用key进行比较</strong>，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和newCh至少有一个已经遍历完了，就会结束比较。</p> <p><strong>这里就是设置key的关键了，不设key，newCh和oldCh只会进行头尾两端的相互比较，设key后，除了头尾两端的比较外，还会从用key生成的对象oldKeyToIdx中查找匹配的节点，所以为节点设置key可以更高效的利用dom。</strong></p> <p>首先看看<strong>不带key的情况</strong>：</p> <p>第一步，oldCh和newCh的起点和终点都不相同，故而newCh的第一个被放到oldCh的前面，然后newStartIndex后移一位。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710151322.png">
第二步，发现newStartIndex和oldStartIndex一样，故而A保持不变位置，oldStartIndex和newStartIndex均后移一位。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710151347.png">
第三步，发现oldEndIndex和newStartIndex一样，故而将oldCh的D直接移动到A后面，然后oldStartIndex和newStartIndex均后移一位，oldEndIndex向前移动一位。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710151412.png">
第四步，发现oldEndIndex和newStartIndex一样，故而将oldCh的C直接移动到D后面，然后oldStartIndex和newStartIndex均后移一位，oldEndIndex向前移动一位。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710151849.png">
第五步，oldCh和newCh的起点和终点都不相同，故而newCh的F被放到了oldCh的C后面。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710152025.png">
第六步，newStartIndex已经超过了newEndIndex，说明oldCh存在多余节点，将其后面的删除即可。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710152201.png"></p> <p>再来看看<strong>带有key的情况</strong>：</p> <p>第一步，oldCh和newCh的起点和终点都不相同，但newStartIndex通过key找到了oldCh里的B，故而newCh的第一个被放到oldCh的前面，然后newStartIndex后移一位，并将oldCh中的B进行删除。
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710152519.png"></p> <p>第二步和原来一致
<img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710152711.png"></p> <p>后面都和原来一致了。</p> <p>这样就可以<strong>通过key来有效的缩短更新所需要花费的耗时</strong>。</p> <h3 id="vue-use使用插件，是如何实现的？"><a href="#vue-use使用插件，是如何实现的？" aria-hidden="true" class="header-anchor">#</a> Vue.use使用插件，是如何实现的？</h3> <p>首先插件是需要提供一个install方法的，而<code>Vue.use</code>在调用的时候就会去执行其install方法，也会把Vue原型提供进去供插件使用。其核心代码在<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/global-api/use.js#L6" target="_blank" rel="noopener noreferrer">src/core/global-api/use.js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>:</p> <div class="language-js extra-class"><pre class="language-js"><code>  Vue<span class="token punctuation">.</span><span class="token function-variable function">use</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">plugin<span class="token punctuation">:</span> Function <span class="token operator">|</span> Object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> installedPlugins <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_installedPlugins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>installedPlugins<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// additional parameters</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token function">toArray</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
    args<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin<span class="token punctuation">.</span>install <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      plugin<span class="token punctuation">.</span><span class="token function">install</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>plugin<span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> plugin <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">plugin</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    installedPlugins<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>plugin<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>Vue.use 接受一个 plugin 参数，并且维护了一个 _installedPlugins 数组，它存储所有注册过的 plugin；接着又会判断 plugin 有没有定义 install 方法，如果有的话则调用该方法，并且该方法执行的第一个参数是 Vue；最后把 plugin 存储到 installedPlugins 中。</p> <p>可以看到 Vue 提供的插件注册机制很简单，每个插件都需要实现一个静态的 install 方法，当我们执行 Vue.use 注册插件的时候，就会执行这个 install 方法，并且在这个 install 方法的第一个参数我们可以拿到 Vue 对象，这样的好处就是作为插件的编写方不需要再额外去import Vue 了。</p> <h3 id="vue中的数据响应式如何实现的？"><a href="#vue中的数据响应式如何实现的？" aria-hidden="true" class="header-anchor">#</a> Vue中的数据响应式如何实现的？</h3> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20200116113829.png"> <p>通过Observer，对需要的object，通过defineProperty递归的建立可观察对象；对需要的数组，通过array.js提供的方法对数组原型进行hack复写，并植入观察逻辑。</p> <p>Dep用来负责依赖的收集。</p> <p>watcher 中实例化了 dep 并向 dep.subs 中添加了订阅者,dep 通过 notify 遍历了 dep.subs 通知每个 watcher 更新。</p> <p>参考<a href="https://github.com/FunnyLiu/vue/tree/readsource#%E6%95%B0%E6%8D%AE%E8%A7%82%E5%AF%9F" target="_blank" rel="noopener noreferrer">源码解读<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>参考 <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%A6%82%E4%BD%95%E8%BF%BD%E8%B8%AA%E5%8F%98%E5%8C%96" target="_blank" rel="noopener noreferrer">官方解释<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。</p> <h3 id="聊聊-vue-的响应式，model-如何改变-view，view-又是如何改变-model-的"><a href="#聊聊-vue-的响应式，model-如何改变-view，view-又是如何改变-model-的" aria-hidden="true" class="header-anchor">#</a> 聊聊 Vue 的响应式，Model 如何改变 View，View 又是如何改变 Model 的</h3> <p>参考 <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/34#issuecomment-519823665" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>此题和上题同样可参考 <a href="https://juejin.im/post/5e93e1ea51882573cb72277a#heading-7" target="_blank" rel="noopener noreferrer">一题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue哪些配置会做数据绑定"><a href="#vue哪些配置会做数据绑定" aria-hidden="true" class="header-anchor">#</a> vue哪些配置会做数据绑定</h3> <p>vue源码中观察数据的方法有<a href="https://github.com/FunnyLiu/vue/blob/c8c89c9fbc6d4243cf55a8aaddabfff395af0587/src/core/observer/index.js#L149" target="_blank" rel="noopener noreferrer">defineReactive<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://github.com/FunnyLiu/vue/blob/c8c89c9fbc6d4243cf55a8aaddabfff395af0587/src/core/observer/index.js#L123" target="_blank" rel="noopener noreferrer">observe<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 使用在如下vue配置上</p> <ul><li><p>props：<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/util/props.js#L51" target="_blank" rel="noopener noreferrer">源码1<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/state.js#L101" target="_blank" rel="noopener noreferrer">源码2<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>data <a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/state.js#L169" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，</p></li> <li><p>computed <a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/state.js#L231" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，</p></li> <li><p>inject <a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/inject.js#L16" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/render.js#L43" target="_blank" rel="noopener noreferrer">$attrs<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/render.js#L46" target="_blank" rel="noopener noreferrer">$listeners<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p><a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/observer/index.js#L222" target="_blank" rel="noopener noreferrer">set<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 给响应式对象加新的响应式property</p></li> <li><p>vuex的实例的<code>state</code>即<code>$store.state</code>也是响应式的，改了之后dom会更新的</p></li></ul> <p><a href="https://github.com/theydy/notebook/issues/39" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue-set到底在做什么？"><a href="#vue-set到底在做什么？" aria-hidden="true" class="header-anchor">#</a> vue.set到底在做什么？</h3> <p>Vue.set( target, propertyName/index, value )向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property。</p> <ul><li>target是数组。设置数组长度防止index取不到，使用splice方法，将value赋给index。return value;</li> <li>target上有这个propertyName，直接赋值。 return value;</li> <li>target不能是Vue实例，或者Vue实例的根数据对象，否则报错。return value;</li> <li>target不是响应式对象，赋值。return value;</li> <li>target使用object.defineProperty，赋值，建立监听，然后触发dep的notify方法。</li></ul> <p><a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/observer/index.js#L222" target="_blank" rel="noopener noreferrer">源码地址<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断是否是数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 判断谁大谁小</span>
        target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
        <span class="token comment">// 执行splice</span>
        target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
        <span class="token keyword">return</span> val
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> ob <span class="token operator">=</span> target<span class="token punctuation">.</span>__ob__

    <span class="token comment">// 如果此对象没有不是响应式对象，直接设置并返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> target<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val
        <span class="token keyword">return</span> val
    <span class="token punctuation">}</span>

    <span class="token comment">// 否则，新增属性，并响应式处理</span>
    <span class="token function">defineReactive</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> val
<span class="token punctuation">}</span>

</code></pre></div><h3 id="vue-delete的原理"><a href="#vue-delete的原理" aria-hidden="true" class="header-anchor">#</a> Vue.delete的原理</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">del</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断是否为数组</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 执行splice</span>
        target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">const</span> ob <span class="token operator">=</span> target<span class="token punctuation">.</span>__ob__

    <span class="token comment">// 对象本身就没有这个属性，直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> target<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span>


    <span class="token comment">// 否则，删除这个属性</span>
    <span class="token keyword">delete</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span>

    <span class="token comment">// 判断是否是响应式对象，不是的话，直接返回</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token keyword">return</span>
    <span class="token comment">// 是的话，删除后要通知视图更新</span>
    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h3 id="vue的响应式用proxy和object-defineproperty有什么区别？"><a href="#vue的响应式用proxy和object-defineproperty有什么区别？" aria-hidden="true" class="header-anchor">#</a> Vue的响应式用Proxy和Object.defineProperty有什么区别？</h3> <p>Object.defineProperty有如下缺陷：</p> <p>1、Object.defineProperty 无法一次性监听对象所有属性，必须遍历或者递归来实现。</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token keyword">let</span> girl <span class="token operator">=</span> <span class="token punctuation">{</span>
     name<span class="token punctuation">:</span> <span class="token string">&quot;marry&quot;</span><span class="token punctuation">,</span>
     age<span class="token punctuation">:</span> <span class="token number">22</span>
   <span class="token punctuation">}</span>
   <span class="token comment">/* Proxy 监听整个对象*/</span>
   girl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>girl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">/* Object.defineProperty */</span>
   Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>girl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>girl<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
       <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>2、Object.defineProperty 无法监听新增加的属性</p> <p>Proxy 可以监听到新增加的属性，而 Object.defineProperty 不可以，需要你手动再去做一次监听。因此，在 Vue 中想动态监听属性，一般用 Vue.set(girl, &quot;hobby&quot;, &quot;game&quot;) 这种形式来添加。</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token keyword">let</span> girl <span class="token operator">=</span> <span class="token punctuation">{</span>
     name<span class="token punctuation">:</span> <span class="token string">&quot;marry&quot;</span><span class="token punctuation">,</span>
     age<span class="token punctuation">:</span> <span class="token number">22</span>
   <span class="token punctuation">}</span>
   <span class="token comment">/* Proxy 监听整个对象*/</span>
   girl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>girl<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">/* Object.defineProperty */</span>
   Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>girl<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>girl<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>
       <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">/* Proxy 生效，Object.defineProperty 不生效 */</span>
   girl<span class="token punctuation">.</span>hobby <span class="token operator">=</span> <span class="token string">&quot;game&quot;</span><span class="token punctuation">;</span> 
</code></pre></div><p>3、Object.defineProperty 无法响应数组操作</p> <p>Object.defineProperty 可以监听数组的变化，Object.defineProperty 无法对 push、shift、pop、unshift 等方法进行响应。</p> <div class="language-js extra-class"><pre class="language-js"><code>   <span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token comment">/* Proxy 监听数组*/</span>
   arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token punctuation">{</span>
     <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
     <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token comment">/* Object.defineProperty */</span>
   arr<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
     Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>index<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
       <span class="token keyword">set</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
       <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span><span class="token punctuation">)</span>

   arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 都生效</span>
   arr<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 只有 Proxy 生效</span>
   arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 只有 Proxy 生效</span>
</code></pre></div><p>对于新增加的数组项，Object.defineProperty 依旧无法监听到，如果想要监听到 push、shift、pop、unshift等方法，该怎么做呢？在 Vue 和 Mobx 中都是通过重写原型实现的。</p> <p>这也是为什么Vue3会基于Proxy的原因。</p> <p>如果要自己实现，可以参考：<a href="/language/javascript.html#基于object-defineproperty实现双向绑定">基于object-defineproperty实现双向绑定</a>和<a href="/language/javascript.html#基于proxy实现双向绑定">基于proxy实现双向绑定</a>。</p> <h3 id="为什么vue的模板必须要有一个根元素？"><a href="#为什么vue的模板必须要有一个根元素？" aria-hidden="true" class="header-anchor">#</a> 为什么Vue的模板必须要有一个根元素？</h3> <p>这个问题可以参考<a href="https://github.com/vuejs/vue/issues/7088#issuecomment-348252040" target="_blank" rel="noopener noreferrer">github上尤雨溪自己的回答<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。
也就是现有diff算法的限制导致的。而React在16.2推出的<a href="https://reactjs.org/blog/2017/11/28/react-v16.2.0-fragment-support.html" target="_blank" rel="noopener noreferrer">React v16.2.0: Improved Support for Fragments – React Blog<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，其实是在重写diff算法的同时进行了支持。</p> <p>至于Vue的diff算法具体逻辑，可以参考<a href="/library/vue.html#vue中的key有什么用？为什么会优化diff算法的速度？">vue中的key有什么用？为什么会优化diff算法的速度？</a></p> <h3 id="vue是如何实现事件系统的？"><a href="#vue是如何实现事件系统的？" aria-hidden="true" class="header-anchor">#</a> Vue是如何实现事件系统的？</h3> <p>Vue中的事件有Dom事件和Vue事件（自定义事件）两种，所以可将事件的绑定总结为一下几种类型：</p> <ul><li>类型一：在模板中通过v-on指令绑定的Dom事件</li> <li>类型二：在模板中通过v-on指令绑定的自定义事件</li> <li>类型三：在vue options中通过events绑定的自定义事件（<a href="https://cn.vuejs.org/v2/guide/migration.html#events-%E9%80%89%E9%A1%B9%E7%A7%BB%E9%99%A4" target="_blank" rel="noopener noreferrer">events被废弃了<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>)</li> <li>类型四：通过$on方法绑定的自定义事件</li></ul> <p>Vue中为DOM元素绑定事件是采用DOM2级事件的处理方式，也就是addEventListener，因为Vue服务的是IE9以上的现代浏览器，他们也都是支持DOM2级事件。</p> <p>而自定义事件是为组件间通信设计，自定义事件提供了 $on、$off、$once、$emit、$broadcast、$dispatch 几个 api，非常简洁。<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/instance/events.js#L2" target="_blank" rel="noopener noreferrer">实现源码在此<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>首先提两个vm的私有变量，<strong>vm._events 和 vm._eventCount</strong>。<strong>每个vm实例所有的自定义事件都将存储在 vm._events，而 vm._eventsCount 存储的是执行事件广播后子组件触发自定义事件处理程序的数量</strong>，这是为了事件广播优化而来的，如果 vm._eventsCount[event] 数量为零，当事件广播时则可断定子组件没有该事件的监听器，就没必要向子组件层层捕获该事件监听器了。</p> <p>参考：</p> <p><a href="https://defed.github.io/Vue%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB-%E6%96%B9%E6%B3%95%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/" target="_blank" rel="noopener noreferrer">Vue源码解读-方法与事件绑定 | 滴滴商业FED<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.im/entry/577ce6b88ac2470061c2fcce" target="_blank" rel="noopener noreferrer">Vue 的事件系统 - 前端 - 掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <hr> <h3 id="vue中的keep-alive是怎么实现的？越具体越好。"><a href="#vue中的keep-alive是怎么实现的？越具体越好。" aria-hidden="true" class="header-anchor">#</a> Vue中的keep-alive是怎么实现的？越具体越好。</h3> <p>首先看下使用方法：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token comment">&lt;!-- 失活的组件将会被缓存！--&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>component</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>is</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">&quot;</span>currentTabComponent<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>component</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>keep-alive</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>include定义缓存白名单，keep-alive会缓存命中的组件；exclude定义缓存黑名单，被命中的组件将不会被缓存；max定义缓存组件上限，超出上限使用<strong>LRU的策略</strong>置换缓存数据。</p> <p>简单的说，就是切换组件时不销毁它，而是<strong>将其缓存至内存</strong>中；等切回来时再将其激活，不再走原来的生命周期了。</p> <p>其原理就是：被包含在 keep-alive 中创建的组件，会增加额外的vnode属性和逻辑如<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/components/keep-alive.js#L133" target="_blank" rel="noopener noreferrer">keepalive<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，而在vue框架生命周期的<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/vdom/patch.js#L215" target="_blank" rel="noopener noreferrer">patch阶段，对其做了处理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</p> <p>查看patch.js逻辑。在首次加载被包裹组件时，由<code>keep-alive.js</code>中的render函数可知，<code>vnode.componentInstance</code>的值是undefined，keepAlive的值是true，因为keep-alive组件作为父组件，它的render函数会先于被包裹组件执行。所以逻辑断掉了。</p> <p>再次访问被包裹组件时，<code>vnode.componentInstance</code>的值就是已经缓存的组件实例，那么会执行<code>insert(parentElm, vnode.elm, refElm)</code>逻辑，这样就直接把上一次的DOM插入到了父元素中。</p> <p>参考：</p> <p><a href="https://juejin.im/post/5cce49036fb9a031eb58a8f9" target="_blank" rel="noopener noreferrer">彻底揭秘keep-alive原理 - 掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue的mixin模式怎么实现的？"><a href="#vue的mixin模式怎么实现的？" aria-hidden="true" class="header-anchor">#</a> Vue的mixin模式怎么实现的？</h3> <p>组件调用mixin的方式有两种：</p> <p>Vue.mixin()：直接调用组件构造函数上的mixin静态方法。</p> <p>vue options-&gt;{ mixins: [] }：在组件的配置对象中挂载mixins的成员。</p> <p>无论以上使用了哪种方式，最终调用的都是mergeOptions这个工具方法。</p> <p>这个方式的实现参考：<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/util/options.js#L401" target="_blank" rel="noopener noreferrer">vue/options.js at readsource · FunnyLiu/vue<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，针对不同的类型，进行不同的策略进行merge。</p> <p>比如生命周期，就是通过<a href="https://github.com/FunnyLiu/vue/blob/readsource/src/core/util/options.js#L147" target="_blank" rel="noopener noreferrer">mergeHook<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，将父子的函数concat为数组来完成。</p> <p>具体每一种类型的实现不一一展开了。</p> <p>参考：</p> <p><a href="https://juejin.im/post/5d37de4ee51d45590a445c19" target="_blank" rel="noopener noreferrer">Vue探究：精读mixin与mergeOptions - 掘金<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue3做了哪些优化？"><a href="#vue3做了哪些优化？" aria-hidden="true" class="header-anchor">#</a> Vue3做了哪些优化？</h3> <p>生 成 Block tree</p> <p>Vue.js 2.x 的数据更新并触发重新渲染的粒度是组件级的，单个组件内部 需要遍历该组件的整个 vnode 树。在 2.0 里，渲染效率的快慢与组件大小成正相关：组件越大，渲染效率越慢。并且，对于一些静态节点，又无数据更新，这些遍历都是性能浪费。Vue.js 3.0 做到了通过编译阶段对静态模板的分析，编译生成了 Block tree。</p> <p>Block tree是一个将模版基于动态节点指令切割的嵌套区块，每个 区块内部的节点结构是固定的， 每个区块只需要追踪自身包含的动态节点。所以，在 3.0 里，渲染效率不再与模板大小成正相关，而是与模板中动态节点的数量成正相关。</p> <p>slot 编译优化</p> <p>Vue.js 2.x 中，如果有一个组件传入了 slot，那么每次父组件更新的时候，会强制使子组件update，造成性能的浪费。</p> <p>Vue.js 3.0 优化了 slot 的生成，使得非动态 slot 中属性的更新只会触发子组件的更新。动态 slot 指的是在 slot 上面使用 v-if，v-for，动态slot 名字等会导致 slot 产生运行时动态变化但是又无法被子组件 track 的操作。</p> <p>diff 算法优化</p> <p>Vue2.x 中的虚拟dom 是进行全量的对比。</p> <p>Vue3.0 中新增了静态标记（PatchFlag）：在与上次虚拟结点进行对比的时候，值对比带有patch flag 的节点，并且可以通过 flag 的信息得知当前节点要对比的具体内容化。</p> <p>cacheHandlers 事件侦听器缓存</p> <p>默认情况下onClick 会被视为动态绑定，所以每次都会去追踪它的变化但是因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可。</p> <h3 id="vue3的hook和react的区别？"><a href="#vue3的hook和react的区别？" aria-hidden="true" class="header-anchor">#</a> vue3的hook和React的区别？</h3> <p>React hook 底层是基于链表实现，调用的条件是每次组件被 render 的时候都会顺序执行所有的hooks。</p> <p>Vue hook 只会被注册调用一次，Vue 能避开这些麻烦的问题，原因在于它对数据的响应是基于proxy 的，对数据直接代理观察。（这种场景下，只要任何一个更改 data 的地方，相关的 function 或者 template 都会被重新计算，因此避开了 React 可能遇到的性能上的问题）。</p> <p>React 中，数据更改的时候，会导致重新 render，重新 render 又会重新把 hooks 重新注册一次，所以React 复杂程度会高一些。</p> <h3 id="vue的re-render和react的re-render的区别？"><a href="#vue的re-render和react的re-render的区别？" aria-hidden="true" class="header-anchor">#</a> vue的re-render和React的re-render的区别？</h3> <p>Vue2通过主动记录数据依赖，可以精确到某个组件开始及其子组件的re-render;</p> <p>Vue3进一步优化到模板中区分静态节点和动态节点，只re-render动态节点；</p> <p>而React则是每次改变状态后对整个APP进行重新diff并查到需要render的组件，重新执行render。</p> <h3 id="data为什么是个函数"><a href="#data为什么是个函数" aria-hidden="true" class="header-anchor">#</a> data为什么是个函数</h3> <p>因为组件的data是一个对象，而对象是引用类型的，若不是函数，多个组件实例的data会指向同一个对象的堆，导致对象的内容互相影响。所以需要用函数使每个组件实例返回一个新的data。</p> <p>data之所以只一个函数，是因为一个组件可能会多处调用，而每一次调用就会执行data函数并返回新的数据对象，这样，可以避免多处调用之间的数据污染。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s/h2H-36iVeoyXsorZChwxyQ" target="_blank" rel="noopener noreferrer">熬夜总结50个Vue知识点，全都会你就是神！！！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="v-if和v-for为什么不能在同一个标签？"><a href="#v-if和v-for为什么不能在同一个标签？" aria-hidden="true" class="header-anchor">#</a> v-if和v-for为什么不能在同一个标签？</h3> <p>在Vue2中，v-for优先级是高于v-if的，咱们来看例子</p> <div class="language-html extra-class"><pre class="language-html"><code>&lt;div v-for=item in [1, 2, 3, 4, 5, 6, 7] v-if=item !== 3&gt;
    {{item}}
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>上面的写法是v-for和v-if同时存在，会先把7个元素都遍历出来，然后再一个个判断是否为3，并把3给隐藏掉，这样的坏处就是，渲染了无用的3节点，增加无用的dom操作，建议使用computed来解决这个问题：</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;div v-for=item in list&gt;
    {{item}}
&lt;/div&gt;

computed() {
    list() {
        return [1, 2, 3, 4, 5, 6, 7].filter(item =&gt; item !== 3)
    }
  }
</code></pre></div><p>使用computed我们将会获得如下好处：</p> <ul><li>过滤后的列表只会在 users 数组发生相关变化时才被重新运算，过滤更高效。</li> <li>使用 v-for=&quot;user in activeUsers&quot; 之后，我们在渲染的时候只遍历活跃用户，渲染更高效。</li> <li>解耦渲染层的逻辑，可维护性 (对逻辑的更改和扩展) 更强。</li></ul> <p>参考：</p> <p><a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7%E5%BF%85%E8%A6%81" target="_blank" rel="noopener noreferrer">避免 v-if 和 v-for 用在一起<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://mp.weixin.qq.com/s/h2H-36iVeoyXsorZChwxyQ" target="_blank" rel="noopener noreferrer">熬夜总结50个Vue知识点，全都会你就是神！！！<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="vue2中的指令是如何解析的？"><a href="#vue2中的指令是如何解析的？" aria-hidden="true" class="header-anchor">#</a> vue2中的指令是如何解析的？</h3> <p>指令本质上就是一个 JavaScript 对象，对象上挂着一些钩子函数，无论是官方提供的指令，还是自定义指令，一个指令从第一次被绑定到元素上到最终与被绑定的元素解绑，它会经过以下几种状态：</p> <p>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p> <p>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</p> <p>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。</p> <p>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</p> <p>unbind：只调用一次，指令与元素解绑时调用。</p> <p>了每个状态的钩子函数，这样我们就可以让指令在不同状态下做不同的事情。当虚拟DOM渲染更新的时候会触发create、update、destroy这三个钩子函数，从而就会执行updateDirectives函数来处理指令的相关逻辑，执行指令函数，让指令生效。</p> <h3 id="vue-router初始化时做了什么？"><a href="#vue-router初始化时做了什么？" aria-hidden="true" class="header-anchor">#</a> vue-router初始化时做了什么？</h3> <p>插件注册的时候的核心逻辑：给vue组件增加$router和$route，并全局注册RouterView和RouterLink组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// mixin</span>
  Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function">beforeCreate</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// $options.router存在则表示是根组件</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isDef</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_routerRoot <span class="token operator">=</span> <span class="token keyword">this</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_router <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options<span class="token punctuation">.</span>router
        <span class="token keyword">this</span><span class="token punctuation">.</span>_router<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
        Vue<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'_route'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_router<span class="token punctuation">.</span>history<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 不是根组件则从父组件中获取</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_routerRoot <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$parent <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$parent<span class="token punctuation">.</span>_routerRoot<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">this</span>
      <span class="token punctuation">}</span>
      <span class="token function">registerInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">destroyed</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">registerInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">//$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。</span>
  <span class="token comment">// 而 $router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</span>
  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'$router'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_routerRoot<span class="token punctuation">.</span>_router <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'$route'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_routerRoot<span class="token punctuation">.</span>_route <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token comment">// 注册组件</span>
  Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'RouterView'</span><span class="token punctuation">,</span> View<span class="token punctuation">)</span>
  Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'RouterLink'</span><span class="token punctuation">,</span> Link<span class="token punctuation">)</span>
</code></pre></div><h3 id="router-view组件做了什么？"><a href="#router-view组件做了什么？" aria-hidden="true" class="header-anchor">#</a> router-view组件做了什么？</h3> <p>router-view组件的作用是根据路由的变化渲染出路由所对应的组件。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 根据路由的变化渲染出路由所对应的组件</span>
<span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span>component<span class="token punctuation">,</span> data<span class="token punctuation">,</span> children<span class="token punctuation">)</span>
</code></pre></div><h3 id="路由跳转的方法实现？"><a href="#路由跳转的方法实现？" aria-hidden="true" class="header-anchor">#</a> 路由跳转的方法实现？</h3> <p>以push为例，分为两种情况，hash情况下就是通过<code>window.location.hash = path</code>来实现，history情况下就是通过<code>history.pushState({ key: setStateKey(genStateKey()) }, '', url)</code> 来实现。</p> <h2 id="编码"><a href="#编码" aria-hidden="true" class="header-anchor">#</a> 编码</h2> <h3 id="实现一个vue的懒加载指令（todo）"><a href="#实现一个vue的懒加载指令（todo）" aria-hidden="true" class="header-anchor">#</a> 实现一个vue的懒加载指令（todo）</h3></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/library/typescript.html" class="prev">
          Typescript
        </a></span> <span class="next"><a href="/library/webpack.html">
          Webpack
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2cc9f89.js" defer></script><script src="/assets/js/2.397e6419.js" defer></script><script src="/assets/js/37.3163d65d.js" defer></script>
  </body>
</html>
