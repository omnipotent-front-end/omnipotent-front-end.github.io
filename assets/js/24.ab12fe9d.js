(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{284:function(e,r,t){"use strict";t.r(r);var a=t(38),n=Object(a.a)({},function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"egg"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#egg","aria-hidden":"true"}},[e._v("#")]),e._v(" Egg")]),e._v(" "),t("h2",{attrs:{id:"使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#使用","aria-hidden":"true"}},[e._v("#")]),e._v(" 使用")]),e._v(" "),t("h3",{attrs:{id:"egg-cluster和pm2有什么区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#egg-cluster和pm2有什么区别？","aria-hidden":"true"}},[e._v("#")]),e._v(" Egg-cluster和pm2有什么区别？")]),e._v(" "),t("p",[e._v("egg的cluster相比pm2，代码有所简化，"),t("strong",[e._v("在传统的Master-worker的基础上，增加了agent")]),e._v("。变为Master-agetn-worker。")]),e._v(" "),t("p",[e._v("在大部分情况下，我们在写业务代码的时候完全不用考虑 Agent 进程的存在，但是"),t("strong",[e._v("当我们遇到一些场景，只想让代码运行在一个进程上的时候，Agent 进程就到了发挥作用的时候")]),e._v("了。")]),e._v(" "),t("p",[e._v("由于 Agent 只有一个，而且会负责许多维持连接的脏活累活，因此它不能轻易挂掉和重启，所以 Agent 进程在监听到未捕获异常时不会退出，但是会打印出错误日志，我们需要对日志中的未捕获异常提高警惕。")]),e._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[e._v("                +--------+          +-------+\n                "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" Master +"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v("--------"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v(">")]),e._v("+ Agent "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n                +---+----+          +-------+\n                "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("v")]),e._v("   ^    "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("v")]),e._v("\n               /    "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("     "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n             /      "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("       "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n           /        "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("         "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("\\")]),e._v("\n         ^          "),t("span",{pre:!0,attrs:{class:"token function"}},[e._v("v")]),e._v("          ^\n+--------+-+   +----+-----+   ++---------+\n"),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" Worker "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("   "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" Worker "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("   "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v(" Worker "),t("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[e._v("|")]),e._v("\n+----------+   +----------+   +----------+\n\n")])])]),t("p",[e._v("参考：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/298718190/answer/511704261?from=singlemessage&isappinstalled=0&utm_medium=social&utm_oi=41809770184704&utm_source=wechat_session&s_r=0",target:"_blank",rel:"noopener noreferrer"}},[e._v("Egg.js 进程管理为什么没有选型 PM2 ？ - 知乎"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://cnodejs.org/topic/5b60495e58db3ccf66a450c6",target:"_blank",rel:"noopener noreferrer"}},[e._v("nest如何实现多进程间通信和egg类似的agent机制 - CNode技术社区"),t("OutboundLink")],1)]),e._v(" "),t("h3",{attrs:{id:"agent的使用场景有哪些？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#agent的使用场景有哪些？","aria-hidden":"true"}},[e._v("#")]),e._v(" Agent的使用场景有哪些？")]),e._v(" "),t("p",[e._v("有些工作其实不需要每个 Worker 都去做，如果都做，一来是浪费资源，更重要的是可能会"),t("strong",[e._v("导致多进程间资源访问冲突")]),e._v("。举个例子：生产环境的日志文件我们一般会按照日期进行归档，在单进程模型下这再简单不过了：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("每天凌晨 0 点，将当前日志文件按照日期进行重命名")])]),e._v(" "),t("li",[t("p",[e._v("销毁以前的文件句柄，并创建新的日志文件继续写入")])])]),e._v(" "),t("p",[e._v("试想如果现在是 4 个进程来做同样的事情，是不是就乱套了。所以，对于这一类后台运行的逻辑，我们希望将它们放到一个单独的进程上去执行，这个进程就叫 Agent Worker，简称 Agent。Agent 好比是 Master 给其他 Worker 请的一个『秘书』，它不对外提供服务，只给 App Worker 打工，专门处理一些公共事务。")]),e._v(" "),t("h3",{attrs:{id:"配置中的app-keys为什么要支持多个？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#配置中的app-keys为什么要支持多个？","aria-hidden":"true"}},[e._v("#")]),e._v(" 配置中的app.keys为什么要支持多个？")]),e._v(" "),t("p",[e._v("在cookie加解密时，这里采用的是轮替密钥的方案。")]),e._v(" "),t("p",[e._v("替密钥不会停用或销毁以前的密钥版本。以前的密钥版本将不再是主密钥版本，但仍可用于解密数据。")]),e._v(" "),t("p",[e._v("keys 配置成一个字符串，可以按照逗号分隔配置多个 key。Cookie 在使用这个配置进行加解密时：")]),e._v(" "),t("p",[e._v("加密和加签时只会使用第一个秘钥。")]),e._v(" "),t("p",[e._v("解密和验签时会遍历 keys 进行解密。")]),e._v(" "),t("p",[e._v("如果我们想要更新 Cookie 的秘钥，但是又不希望之前设置到用户浏览器上的 Cookie 失效，可以将新的秘钥配置到 keys 最前面，等过一段时间之后再删去不需要的秘钥即可。")]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://eggjs.org/zh-cn/core/cookie-and-session.html#cookie-%E7%A7%98%E9%92%A5",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg官方文档"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://cloud.google.com/kms/docs/key-rotation",target:"_blank",rel:"noopener noreferrer"}},[e._v("密钥轮替  |  Cloud KMS  |  Google Cloud"),t("OutboundLink")],1)]),e._v(" "),t("hr"),e._v(" "),t("h2",{attrs:{id:"原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),t("h3",{attrs:{id:"有没有系统看过egg相关源码？大致是怎样工作的？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#有没有系统看过egg相关源码？大致是怎样工作的？","aria-hidden":"true"}},[e._v("#")]),e._v(" 有没有系统看过egg相关源码？大致是怎样工作的？")]),e._v(" "),t("p",[e._v("通过loader，在不同的文件夹下找到对象，mixin到ctx原型上。命令行工具common-bin思路也是如此。")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg相关生态源码分析"),t("OutboundLink")],1)])]),e._v(" "),t("p",[e._v("核心依赖项")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/koa/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("koa源码分析"),t("OutboundLink")],1),e._v(" - egg的ctx，app等均继承自koa，所以koa源码是基本。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-core/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-core源码分析"),t("OutboundLink")],1),e._v(" - 核心的loader和controller，service，app，等均在此封装")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-bin/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-bin源码分析"),t("OutboundLink")],1),e._v(" - 提供一些cli命令，继承自common-bin模块。封装了dev、test等cli命令。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-scripts/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-script源码分析"),t("OutboundLink")],1),e._v(" - 提供start/stop命令。继承自common-bin模块。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/common-bin/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("common-bin源码分析"),t("OutboundLink")],1),e._v(" - cli基本类，通过load文件夹内容的规约方式来注册命令。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-cluster/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-cluster源码分析"),t("OutboundLink")],1),e._v(" - egg多进程模型启动，具体实现。提供startCluster方法供egg-bin dev和egg-scripts start使用。")])]),e._v(" "),t("p",[e._v("内部集成插件依赖")]),e._v(" "),t("ul",[t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-logger/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-logger源码分析"),t("OutboundLink")],1),e._v(" - 分级日志logger和transform在此封装。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-onerror/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-onerror源码分析"),t("OutboundLink")],1),e._v(" - 内置的异常处理插件，基于koa-onerror，拦截异常上报和错误页渲染模板。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-session/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-session源码分析"),t("OutboundLink")],1),e._v(" - 将koa-session作为中间件挂载，并提供了sessionStore，方便自定义存取器，供给config.session.store。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-watcher/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-watcher源码分析"),t("OutboundLink")],1),e._v(" - 底层基于ws模块负责文件监听，这里进行了配置和默认eventSource的封装。库本身是继承自sdk-base。 文件监听后对外抛出事件。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-multipart/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-multipart源码分析"),t("OutboundLink")],1),e._v(" - 基于co-busboy模块，解析multipart，挂载ctx.request.files和ctx.request.body。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-security/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-security源码分析"),t("OutboundLink")],1),e._v(" - 提供一系列转义的helper方法，和一系列安全的中间件，加上各种响应头。")]),e._v(" "),t("li",[t("a",{attrs:{href:"https://github.com/FunnyLiu/egg-development/tree/readsource",target:"_blank",rel:"noopener noreferrer"}},[e._v("egg-development源码分析"),t("OutboundLink")],1),e._v(" - __loader_trace__显示追踪调用数据，agent基于egg-watcher模块挂载的ctx.watcher开启文件监听，通过process.send给master进程发消息。app简单的增加中间件。")])])])},[],!1,null,null,null);r.default=n.exports}}]);