(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{294:function(t,a,s){"use strict";s.r(a);var e=s(38),r=Object(e.a)({},function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"react-native"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-native","aria-hidden":"true"}},[t._v("#")]),t._v(" React Native")]),t._v(" "),s("h2",{attrs:{id:"应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#应用","aria-hidden":"true"}},[t._v("#")]),t._v(" 应用")]),t._v(" "),s("h3",{attrs:{id:"怎么做到真正的跨三端？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#怎么做到真正的跨三端？","aria-hidden":"true"}},[t._v("#")]),t._v(" 怎么做到真正的跨三端？")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220104173642.png"}}),t._v(" "),s("p",[t._v("让我们自顶向下的来看看。首先我们的项目需要同时具备在app内和浏览器内使用的能力，这样才是真正的跨了三端。")]),t._v(" "),s("p",[t._v("我们需要做到基于react做平行扩展，这样未来小程序内无论是webview嵌h5的方式还是小程序原生的方式，都存在可以想象和优化的空间。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("那么问题来了，如何做到h5和app内通用呢？\n")])])]),s("p",[t._v("这里我们需要分析两个容器的异同点：")]),t._v(" "),s("h4",{attrs:{id:"原生能力"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原生能力","aria-hidden":"true"}},[t._v("#")]),t._v(" 原生能力")]),t._v(" "),s("p",[t._v("App内的react native是通过nativeModule来通信；而hybird、h5、小程序等均是其他的实现，比如说jsbridge、后端接口、小程序API等等。")]),t._v(" "),s("p",[t._v("针对这个点，我们通过适配器模式来解决。")]),t._v(" "),s("p",[t._v("我们通过一个简单的模块来保存引用：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" bridge "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("setBridge")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("bge")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  bridge "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" bge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("bridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("p",[t._v("然后在不同的入口文件（h5、app入口文件区分开来），塞入不同的bridge即可：")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// react native 入口")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("YktNativeModule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" NativeModules"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nbridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("bridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" YktNativeModule"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setBridge")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// h5入口")]),t._v("\nbridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("init")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("yktlog"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" window"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("YktTracker"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("setBridge")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("bridge"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h4",{attrs:{id:"ui跨端"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ui跨端","aria-hidden":"true"}},[t._v("#")]),t._v(" UI跨端")]),t._v(" "),s("p",[t._v("我们书写的react-native组件，比如说View、Text等，需要通过react-native-web来变成react-dom可以识别的节点：")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220105193144.png"}}),t._v(" "),s("p",[t._v("它的原理就是把react-native这个库所有暴露的api，都实现了一遍，然后配合webpack的alias，在打包的时候别名替换一下即可。")]),t._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[t._v("  resolve"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    alias"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react-native'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'react-native-web'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n")])])]),s("h3",{attrs:{id:"如何进行拆包？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何进行拆包？","aria-hidden":"true"}},[t._v("#")]),t._v(" 如何进行拆包？")]),t._v(" "),s("p",[t._v("答案就是拆包：")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220105104340.png"}}),t._v(" "),s("p",[t._v("左上角的图片是整体的思路，可以看到左边是之前的现状，就是每个rn业务模块，都依赖了一些公共的代码，比如说react、react-native，我们想把这些公共的代码抽出来，不让每个业务包都含有大量重复代码，影响app的尺寸，同时客户端也可以预加载公共包的逻辑，从而降低白屏时间。")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("metro是Facebook出品的react native专用打包工具\n")])])]),s("p",[t._v("整个流程分为3步。")]),t._v(" "),s("p",[t._v("第一步是找到公共包依赖了哪些js文件。这里我们通过metro的api，在公共包打包的createModuleFactory的阶段，拿到每个参与打包的js模块路径，然后通过md5文件路径的方式生成唯一的id。")]),t._v(" "),s("p",[t._v("第二步是把依赖列表保持到文件里，具体内容可以看右上角的图片，主要是文件路径和对应的模块id。")]),t._v(" "),s("p",[t._v("第三步是在业务包打包的时候，通过metro的api，在processModuleFilter阶段，基于第二步生成的文件，将这些模块排除在打包过程之外，从而得到纯粹的业务包内容。")]),t._v(" "),s("p",[t._v("这样即使日后公共包内容变多了，也可以自动计算出依赖列表，并通过唯一id去重。")]),t._v(" "),s("p",[t._v("一起看看拆包对bundle尺寸大小的降低：")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220105191611.png"}}),t._v(" "),s("h2",{attrs:{id:"原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 原理")]),t._v(" "),s("h3",{attrs:{id:"说下react-native的原理？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#说下react-native的原理？","aria-hidden":"true"}},[t._v("#")]),t._v(" 说下react-native的原理？")]),t._v(" "),s("p",[t._v("react-native 运行了一个带js引擎的线程，线程负责js和原生的通信， 最后通过调用原生渲染从而实现跨平台的能力，react-native的产物是一个js文件，所以可通过更新js文件即可实现热更新。")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20211229162927.png"}}),t._v(" "),s("p",[t._v("绿色的是我们应用开发的部分，我们写的代码基本上都是在这一层。")]),t._v(" "),s("p",[t._v("蓝色代表公用的跨平台的代码和工具引擎，一般我们不会动蓝色部分的代码。")]),t._v(" "),s("p",[t._v("黄色代表平台相关的 bridge 代码，做定制化的时候会添加修改代码。")]),t._v(" "),s("p",[t._v("红色代表系统平台的功能，另外红色上面有一个虚线，表示所有平台相关的东西都通过 bridge 隔离开来了，红色部分是独立于 React Native 的。")]),t._v(" "),s("p",[t._v("参考：")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/343519887",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Native 原理与实践 - 知乎"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"原生端和js端是怎么通信的？"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原生端和js端是怎么通信的？","aria-hidden":"true"}},[t._v("#")]),t._v(" 原生端和js端是怎么通信的？")]),t._v(" "),s("p",[t._v("旧架构通过bridge，App启动时，原生侧会将原生模块（module）注册到js的映射表，原生模块包括方法（method），即一个module对应多个method的key-value形式。js在调用的时候，通过module + method的方式进行序列化发送到原生，原生解析module得到具体的原生对象，再通过method找到对应的方式，和JSBridge的本质一样，只是做了一层封装。并且，js端自行维护了消息队列实现调用回调。")]),t._v(" "),s("p",[t._v("新架构采用JavaScript Interface (JSI)。")]),t._v(" "),s("p",[t._v("JSI 移除了原生代码和JavaScript代码之间的桥接（bridge），同时也省去了两端相互调用时大量的JSON序列化和反序列化操作。JSI为原生和JS交互打开了新的大门。")]),t._v(" "),s("p",[t._v("不同于之前直接将 JavaScript 代码输入给 JSC，JSI屏蔽 JavaScript 引擎的差异，允许换用不同的 JavaScript 引擎，同时JSI 所在的 C++层也可以作为复用 Native 代码的一种方式。")]),t._v(" "),s("p",[t._v("参考：")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/343519887",target:"_blank",rel:"noopener noreferrer"}},[t._v("React Native 原理与实践 - 知乎"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"hermes引擎相比javascriptcore的优势"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hermes引擎相比javascriptcore的优势","aria-hidden":"true"}},[t._v("#")]),t._v(" Hermes引擎相比javascriptCore的优势")]),t._v(" "),s("p",[t._v("关于hermes做了哪些优化，以及生产环境使用后效果提升如何，可以参考头条这篇文章"),s("a",{attrs:{href:"https://juejin.cn/post/7000632245824258079",target:"_blank",rel:"noopener noreferrer"}},[t._v("ReactNative在游戏营销场景中的实践和探索-Hermes引擎 - 掘金"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("这里我们只看两点，一个是hermes可以直接运行字节码；一个是大大降低的内存占用和启动时间。")]),t._v(" "),s("p",[t._v("可以看到启用了hermes和提供字节码后，TTI（可交互时间降低了一半左右）：")]),t._v(" "),s("img",{attrs:{src:"https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220105102841.png"}})])},[],!1,null,null,null);a.default=r.exports}}]);