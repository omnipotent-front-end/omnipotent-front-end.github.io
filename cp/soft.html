<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>软件工程 | 无所不能的前端--十万个为什么</title>
    <meta name="description" content="Hello world">
    
    
    <link rel="preload" href="/assets/css/0.styles.617c345f.css" as="style"><link rel="preload" href="/assets/js/app.d2cc9f89.js" as="script"><link rel="preload" href="/assets/js/2.397e6419.js" as="script"><link rel="preload" href="/assets/js/14.142a03af.js" as="script"><link rel="prefetch" href="/assets/js/10.bb868db5.js"><link rel="prefetch" href="/assets/js/11.4b9af4bc.js"><link rel="prefetch" href="/assets/js/12.c4499f48.js"><link rel="prefetch" href="/assets/js/13.d1872e02.js"><link rel="prefetch" href="/assets/js/15.4a5cbaf1.js"><link rel="prefetch" href="/assets/js/16.f8dbbc61.js"><link rel="prefetch" href="/assets/js/17.82a379c6.js"><link rel="prefetch" href="/assets/js/18.715eafe3.js"><link rel="prefetch" href="/assets/js/19.3ccb129c.js"><link rel="prefetch" href="/assets/js/20.cae30be8.js"><link rel="prefetch" href="/assets/js/21.13af9b85.js"><link rel="prefetch" href="/assets/js/22.37452818.js"><link rel="prefetch" href="/assets/js/23.42d1270e.js"><link rel="prefetch" href="/assets/js/24.ab12fe9d.js"><link rel="prefetch" href="/assets/js/25.c0481126.js"><link rel="prefetch" href="/assets/js/26.11ac2dd4.js"><link rel="prefetch" href="/assets/js/27.739ff2af.js"><link rel="prefetch" href="/assets/js/28.ba55abf0.js"><link rel="prefetch" href="/assets/js/29.b9c0eeba.js"><link rel="prefetch" href="/assets/js/3.addf54d7.js"><link rel="prefetch" href="/assets/js/30.25a4547a.js"><link rel="prefetch" href="/assets/js/31.67514c9b.js"><link rel="prefetch" href="/assets/js/32.70396374.js"><link rel="prefetch" href="/assets/js/33.c599a93b.js"><link rel="prefetch" href="/assets/js/34.7b65401c.js"><link rel="prefetch" href="/assets/js/35.31b0aeaa.js"><link rel="prefetch" href="/assets/js/36.c93744e9.js"><link rel="prefetch" href="/assets/js/37.3163d65d.js"><link rel="prefetch" href="/assets/js/38.939dfb29.js"><link rel="prefetch" href="/assets/js/39.05749514.js"><link rel="prefetch" href="/assets/js/4.7d932259.js"><link rel="prefetch" href="/assets/js/40.d517694b.js"><link rel="prefetch" href="/assets/js/41.a7178842.js"><link rel="prefetch" href="/assets/js/42.d2067a3d.js"><link rel="prefetch" href="/assets/js/43.99404503.js"><link rel="prefetch" href="/assets/js/44.64ecbf2b.js"><link rel="prefetch" href="/assets/js/45.df22fe66.js"><link rel="prefetch" href="/assets/js/46.5233a8b7.js"><link rel="prefetch" href="/assets/js/47.e49bafbe.js"><link rel="prefetch" href="/assets/js/48.b77136bc.js"><link rel="prefetch" href="/assets/js/49.0340ff29.js"><link rel="prefetch" href="/assets/js/5.8ee7bf61.js"><link rel="prefetch" href="/assets/js/50.3d8cedd0.js"><link rel="prefetch" href="/assets/js/6.e9a729c7.js"><link rel="prefetch" href="/assets/js/7.4b0de641.js"><link rel="prefetch" href="/assets/js/8.c896fb93.js"><link rel="prefetch" href="/assets/js/9.eca79ebb.js">
    <link rel="stylesheet" href="/assets/css/0.styles.617c345f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无所不能的前端--十万个为什么</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cp/algorithm.html" class="sidebar-link">算法</a></li><li><a href="/cp/browser.html" class="sidebar-link">浏览器相关</a></li><li><a href="/cp/compiler.html" class="sidebar-link">编译原理</a></li><li><a href="/cp/network.html" class="sidebar-link">计算机网络</a></li><li><a href="/cp/os.html" class="sidebar-link">操作系统</a></li><li><a href="/cp/soft.html" class="active sidebar-link">软件工程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/soft.html#设计模式" class="sidebar-link">设计模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/soft.html#工作中或者哪些源码中遇到过什么设计模式，列举一下？" class="sidebar-link">工作中或者哪些源码中遇到过什么设计模式，列举一下？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#如何实现集群下的单例模式？" class="sidebar-link">如何实现集群下的单例模式？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#享元模式和对象池有什么区别？" class="sidebar-link">享元模式和对象池有什么区别？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#观察者和发布订阅的区别是？" class="sidebar-link">观察者和发布订阅的区别是？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#平常在哪些地方有使用到观察者或发布-订阅模式？" class="sidebar-link">平常在哪些地方有使用到观察者或发布 / 订阅模式？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#适配器模式是什么？" class="sidebar-link">适配器模式是什么？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#中介者模式了不了解？" class="sidebar-link">中介者模式了不了解？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#代理模式了解不？" class="sidebar-link">代理模式了解不？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#单例模式了解不？" class="sidebar-link">单例模式了解不？</a></li></ul></li><li class="sidebar-sub-header"><a href="/cp/soft.html#编程模型" class="sidebar-link">编程模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/soft.html#了解-mvc-mvp-mvvm-的区别吗？" class="sidebar-link">了解 MVC / MVP / MVVM 的区别吗？</a></li><li class="sidebar-sub-header"><a href="/cp/soft.html#mvc和mvvm的区别？" class="sidebar-link">MVC和MVVM的区别？</a></li></ul></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web工程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>企业</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="软件工程"><a href="#软件工程" aria-hidden="true" class="header-anchor">#</a> 软件工程</h1> <h2 id="设计模式"><a href="#设计模式" aria-hidden="true" class="header-anchor">#</a> 设计模式</h2> <h3 id="工作中或者哪些源码中遇到过什么设计模式，列举一下？"><a href="#工作中或者哪些源码中遇到过什么设计模式，列举一下？" aria-hidden="true" class="header-anchor">#</a> 工作中或者哪些源码中遇到过什么设计模式，列举一下？</h3> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=工厂方法">工厂模式</a></li></ul> <p>在父类中提供一个创建对象的接口，允许子类决定实例化对象的类型。</p> <p>开源例子：express()创造实例时，调用他的工厂方法。axios.create()创建实例。ui库ora(options)</p> <p>业务例子：要做很多有略微差异的卡片。父组件包含一些框架和共有逻辑，各个子组件去定制这些卡片的差异内容。</p> <blockquote><p>koa是new的。new Koa()</p></blockquote> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=生成器">生成器</a></li></ul> <p>使你能分步骤创建复杂对象。该模式使你能用相同的创建代码生成不同类型和形式的对象</p> <p>开源例子：webpack的config对象很复杂时，可使用工具按需生成该对象</p> <p>业务例子：组件是一个对象（包含render等），可以用生成器模式拼装出来</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=单例">单例</a></li></ul> <p>保证一个类只有一个实例，并提供一个访问该实例的全局节点</p> <p>常用例子：vuex vue-router redux。组件中的modal message等也是单例</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=适配器">适配器</a></li></ul> <p>使接口不兼容的对象能够互相合作</p> <p>开源例子：<code>axios</code>的API适配成<code>XMLHttpRequest</code>或<code>http</code>模块，兼容浏览器和node端。orm框架兼容多种数据库。</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=外观（门面）">外观模式</a></li></ul> <p>为程序库、 框架或其他复杂类提供一个简单的接口</p> <p>例子：babel preset</p> <p>业务例子：使用<code>echart</code>时，会写一个适配器组件。当绘图组件升级或更改时，降低更改范围。</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=职责链">职责链</a></li></ul> <p>允许你将请求沿着处理者链进行发送。收到请求后，每个处理者都可对请求进行处理，然后将其传递给链上的下个处理者。</p> <p>常用例子：axios拦截器，koa中间件，webpack的loader，vue的过滤器。逻辑放js，简化dom。</p> <blockquote><p>一个文件会有多个loader，一个loader处理后会传给下一个loader</p></blockquote> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=观察者">观察者</a></li></ul> <p>允许你定义一种订阅机制，可以对象发生时通知多个“观察”该对象的其他对象</p> <p>常用例子：<a href="/library/vue.html#vue中的数据响应式如何实现的？">vue的数据响应式</a>，webpack的plugin，vue的生命周期（生命周期相关都是）</p> <ul><li><a href="/cp/soft.html#观察者和发布订阅的区别是？">发布订阅</a></li></ul> <p>借助第三方来实现调度的，发布者和订阅者之间互不感知</p> <p>例子：vue的eventbus</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=策略">策略模式</a></li></ul> <p>能让你定义一系列算法，并将每种算法放入独立的类中，以使算法的对象互相替换</p> <p>例子：<code>axios</code>支持浏览器端和node端</p> <ul><li><a href="/-Design-Patterns-Typescript/#/?id=中介者">中介者</a></li></ul> <p>限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作，减少对象之间混乱无序的依赖关系</p> <p>例子：vuex</p> <h3 id="如何实现集群下的单例模式？"><a href="#如何实现集群下的单例模式？" aria-hidden="true" class="header-anchor">#</a> 如何实现集群下的单例模式？</h3> <p>我们需要把这个单例对象序列化并存储到外部共享存储区(比如文件、或者第三方中间件如redis)。</p> <p>进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p> <p>为了保证任何时刻在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，需要显式地将对象从内存中删除，并且释放对对象的加锁。</p> <h3 id="享元模式和对象池有什么区别？"><a href="#享元模式和对象池有什么区别？" aria-hidden="true" class="header-anchor">#</a> 享元模式和对象池有什么区别？</h3> <p>对象池、连接池(比如数据库连接池)、线程池等也是为了复用，那它们跟享元模式有什么
区别呢?</p> <p>对象池是指像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创 建和释放导致内存碎片，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。 每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放 回到对象池中以供后续复用，而非直接释放掉。。</p> <p>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间(比如从数据库池中
取一个连接，不需要重新创建)。在任意时刻，每一个对象、连接、线程，并不会被多处使
用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。享
元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享
的，主要目的是节省空间。</p> <h3 id="观察者和发布订阅的区别是？"><a href="#观察者和发布订阅的区别是？" aria-hidden="true" class="header-anchor">#</a> 观察者和发布订阅的区别是？</h3> <p>观察者模式中主体和观察者是互相感知的，发布-订阅模式是<strong>借助第三方来实现调度</strong>的，发布者和订阅者之间互不感知：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190710190123.png"> <h3 id="平常在哪些地方有使用到观察者或发布-订阅模式？"><a href="#平常在哪些地方有使用到观察者或发布-订阅模式？" aria-hidden="true" class="header-anchor">#</a> 平常在哪些地方有使用到观察者或发布 / 订阅模式？</h3> <p>前端一般在事件通信和响应式数据管理的情况下会用到观察者模式，具体可以参考<a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/observer/index?id=_1%e3%80%81%e4%ba%8b%e4%bb%b6%e9%80%9a%e4%bf%a1" target="_blank" rel="noopener noreferrer">design - 设计模式（以Typescript描述）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="适配器模式是什么？"><a href="#适配器模式是什么？" aria-hidden="true" class="header-anchor">#</a> 适配器模式是什么？</h3> <p>适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。</p> <p>具体的应用场景可以参考：<a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/adapter/index?id=%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" target="_blank" rel="noopener noreferrer">design - 设计模式（以Typescript描述）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="中介者模式了不了解？"><a href="#中介者模式了不了解？" aria-hidden="true" class="header-anchor">#</a> 中介者模式了不了解？</h3> <p>中介者是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使它们通过一个中介者对象进行合作。</p> <p>具体应用场景可以参考：<a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/mediator/index?id=_1%e3%80%81%e6%95%b0%e6%8d%ae%e7%8a%b6%e6%80%81%e7%ae%a1%e7%90%86" target="_blank" rel="noopener noreferrer">design - 设计模式（以Typescript描述）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="代理模式了解不？"><a href="#代理模式了解不？" aria-hidden="true" class="header-anchor">#</a> 代理模式了解不？</h3> <p>代理是一种结构型设计模式，让你能够提供对象的替代品或其占位符。代理控制着对于原对象的访问，并允许在将请求提交给对象前后进行一些处理。</p> <p>具体应用场景可以参考：<a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/proxy/index?id=%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" target="_blank" rel="noopener noreferrer">design - 设计模式（以Typescript描述）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="单例模式了解不？"><a href="#单例模式了解不？" aria-hidden="true" class="header-anchor">#</a> 单例模式了解不？</h3> <p>单例模式是一种创建型设计模式， 让你能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。</p> <p>具体应用场景可以参考：<a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/singleton/index?id=%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" target="_blank" rel="noopener noreferrer">design - 设计模式（以Typescript描述）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="编程模型"><a href="#编程模型" aria-hidden="true" class="header-anchor">#</a> 编程模型</h2> <h3 id="了解-mvc-mvp-mvvm-的区别吗？"><a href="#了解-mvc-mvp-mvvm-的区别吗？" aria-hidden="true" class="header-anchor">#</a> 了解 MVC / MVP / MVVM 的区别吗？</h3> <p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结 构，优化我们的开发效率。</p> <p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的 显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应 用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互 的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然 后 Model 层再去通知 View 层更新。</p> <p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中我们使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代 码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层 的解耦。MVC 中的
Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此我们可以在 Presenter 中将 Model 的变化和 View 的 变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p> <p>MVVM 模式中的 VM，指的是 ViewModel，它和 MVP 的思想其实是相同的，不过它通过双向的 数据绑定，将 View 和 Model 的同步更新给自动化了。当 Model 发生变化的时候，ViewModel 就会自动更新;ViewModel 变化了，View 也会更新。这样就将 Presenter 中的工作给自动化了。我了解过一点双向数据绑定的原理，比如 vue 是通过使用数据劫持和发布订阅者模式来 实现的这一功能。</p> <p>参考：</p> <p><a href="https://juejin.cn/post/6844903480126078989" target="_blank" rel="noopener noreferrer">浅析前端开发中的 MVC/MVP/MVVM 模式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="mvc和mvvm的区别？"><a href="#mvc和mvvm的区别？" aria-hidden="true" class="header-anchor">#</a> MVC和MVVM的区别？</h3> <p>MVC允许在不改变视图的情况下改变视图对用户输入的响应方式，用户对View的操作交给了Controller处理，在Controller中响应View的事件调用Model的接口对数据进行操作，一旦Model发生变化便通知相关视图进行更新</p> <p>MVVM与MVC最大的区别就是：它实现了View和Model的自动同步，也就是当Model的属性改变时，我们不用再自己手动操作Dom元素，来改变View的显示，而是改变属性后该属性对应View层显示会自动改变</p> <p>参考：</p> <p><a href="https://www.kancloud.cn/lixianshengdezhanghao/interview/904696" target="_blank" rel="noopener noreferrer">11. MVC和MVVM的区别 · 面试题 · 看云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/cp/os.html" class="prev">
          操作系统
        </a></span> <span class="next"><a href="/language/css.html">
          Css
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2cc9f89.js" defer></script><script src="/assets/js/2.397e6419.js" defer></script><script src="/assets/js/14.142a03af.js" defer></script>
  </body>
</html>
