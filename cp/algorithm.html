<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>算法 | 无所不能的前端--十万个为什么</title>
    <meta name="description" content="Hello world">
    
    
    <link rel="preload" href="/assets/css/0.styles.617c345f.css" as="style"><link rel="preload" href="/assets/js/app.d2cc9f89.js" as="script"><link rel="preload" href="/assets/js/2.397e6419.js" as="script"><link rel="preload" href="/assets/js/9.eca79ebb.js" as="script"><link rel="prefetch" href="/assets/js/10.bb868db5.js"><link rel="prefetch" href="/assets/js/11.4b9af4bc.js"><link rel="prefetch" href="/assets/js/12.c4499f48.js"><link rel="prefetch" href="/assets/js/13.d1872e02.js"><link rel="prefetch" href="/assets/js/14.142a03af.js"><link rel="prefetch" href="/assets/js/15.4a5cbaf1.js"><link rel="prefetch" href="/assets/js/16.f8dbbc61.js"><link rel="prefetch" href="/assets/js/17.82a379c6.js"><link rel="prefetch" href="/assets/js/18.715eafe3.js"><link rel="prefetch" href="/assets/js/19.3ccb129c.js"><link rel="prefetch" href="/assets/js/20.cae30be8.js"><link rel="prefetch" href="/assets/js/21.13af9b85.js"><link rel="prefetch" href="/assets/js/22.37452818.js"><link rel="prefetch" href="/assets/js/23.42d1270e.js"><link rel="prefetch" href="/assets/js/24.ab12fe9d.js"><link rel="prefetch" href="/assets/js/25.c0481126.js"><link rel="prefetch" href="/assets/js/26.11ac2dd4.js"><link rel="prefetch" href="/assets/js/27.739ff2af.js"><link rel="prefetch" href="/assets/js/28.ba55abf0.js"><link rel="prefetch" href="/assets/js/29.b9c0eeba.js"><link rel="prefetch" href="/assets/js/3.addf54d7.js"><link rel="prefetch" href="/assets/js/30.25a4547a.js"><link rel="prefetch" href="/assets/js/31.67514c9b.js"><link rel="prefetch" href="/assets/js/32.70396374.js"><link rel="prefetch" href="/assets/js/33.c599a93b.js"><link rel="prefetch" href="/assets/js/34.7b65401c.js"><link rel="prefetch" href="/assets/js/35.31b0aeaa.js"><link rel="prefetch" href="/assets/js/36.c93744e9.js"><link rel="prefetch" href="/assets/js/37.3163d65d.js"><link rel="prefetch" href="/assets/js/38.939dfb29.js"><link rel="prefetch" href="/assets/js/39.05749514.js"><link rel="prefetch" href="/assets/js/4.7d932259.js"><link rel="prefetch" href="/assets/js/40.d517694b.js"><link rel="prefetch" href="/assets/js/41.a7178842.js"><link rel="prefetch" href="/assets/js/42.d2067a3d.js"><link rel="prefetch" href="/assets/js/43.99404503.js"><link rel="prefetch" href="/assets/js/44.64ecbf2b.js"><link rel="prefetch" href="/assets/js/45.df22fe66.js"><link rel="prefetch" href="/assets/js/46.5233a8b7.js"><link rel="prefetch" href="/assets/js/47.e49bafbe.js"><link rel="prefetch" href="/assets/js/48.b77136bc.js"><link rel="prefetch" href="/assets/js/49.0340ff29.js"><link rel="prefetch" href="/assets/js/5.8ee7bf61.js"><link rel="prefetch" href="/assets/js/50.3d8cedd0.js"><link rel="prefetch" href="/assets/js/6.e9a729c7.js"><link rel="prefetch" href="/assets/js/7.4b0de641.js"><link rel="prefetch" href="/assets/js/8.c896fb93.js">
    <link rel="stylesheet" href="/assets/css/0.styles.617c345f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">无所不能的前端--十万个为什么</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://brizer.github.io/urls/zh/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  awesome-url
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://omnipotent-front-end.github.io/-Design-Patterns-Typescript/#/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  设计模式
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/omnipotent-front-end/Interview" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>计算机基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cp/algorithm.html" class="active sidebar-link">算法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/algorithm.html#应用" class="sidebar-link">应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/algorithm.html#什么叫排序的稳定性？" class="sidebar-link">什么叫排序的稳定性？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？" class="sidebar-link">各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#系统自带排序实现" class="sidebar-link">系统自带排序实现</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#快速排序相当于其他排序，效率高的原因？" class="sidebar-link">快速排序相当于其他排序，效率高的原因？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#二分查找的时间复杂度怎么求，是多少（todo）" class="sidebar-link">二分查找的时间复杂度怎么求，是多少（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#线性顺序存储结构和链式存储结构有什么区别？以及优缺点-todo" class="sidebar-link">线性顺序存储结构和链式存储结构有什么区别？以及优缺点(todo)</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#对大文件中的数据进行排序？" class="sidebar-link">对大文件中的数据进行排序？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#用两个栈来实现一个队列，完成队列的-push-和-pop-操作。" class="sidebar-link">用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#数组和链表的优缺点？" class="sidebar-link">数组和链表的优缺点？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#什么是贪心算法？" class="sidebar-link">什么是贪心算法？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#什么是动态规划？" class="sidebar-link">什么是动态规划？</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#背包问题" class="sidebar-link">背包问题</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#一个前端瀑布流，双列的，怎么保证图片高度最小？" class="sidebar-link">一个前端瀑布流，双列的，怎么保证图片高度最小？</a></li></ul></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#原理" class="sidebar-link">原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/algorithm.html#git的diff操作是基于什么算法的（myers）？简单说下原理。" class="sidebar-link">git的diff操作是基于什么算法的（Myers）？简单说下原理。</a></li></ul></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#编码" class="sidebar-link">编码</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cp/algorithm.html#冒泡排序" class="sidebar-link">冒泡排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#选择排序" class="sidebar-link">选择排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#插入排序" class="sidebar-link">插入排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#希尔排序" class="sidebar-link">希尔排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#归并排序" class="sidebar-link">归并排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#快速排序" class="sidebar-link">快速排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#堆排序" class="sidebar-link">堆排序</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#求解平方根（二分查找）（todo）" class="sidebar-link">求解平方根（二分查找）（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#实现二叉树的遍历，考虑非递归。" class="sidebar-link">实现二叉树的遍历，考虑非递归。</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#如何判断是不是完全二叉树？（todo）" class="sidebar-link">如何判断是不是完全二叉树？（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#实现一个二叉搜索树转链表的方法（todo）" class="sidebar-link">实现一个二叉搜索树转链表的方法（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#判断一个链表是否有环（todo）" class="sidebar-link">判断一个链表是否有环（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#反转单向链表" class="sidebar-link">反转单向链表</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#将一个嵌套的数组用深度遍历和广度遍历分别写出来-todo" class="sidebar-link">将一个嵌套的数组用深度遍历和广度遍历分别写出来(todo)</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#斐波那契数列（todo）" class="sidebar-link">斐波那契数列（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#合并两个有序数组（todo）" class="sidebar-link">合并两个有序数组（todo）</a></li><li class="sidebar-sub-header"><a href="/cp/algorithm.html#动态规划" class="sidebar-link">动态规划</a></li></ul></li></ul></li><li><a href="/cp/browser.html" class="sidebar-link">浏览器相关</a></li><li><a href="/cp/compiler.html" class="sidebar-link">编译原理</a></li><li><a href="/cp/network.html" class="sidebar-link">计算机网络</a></li><li><a href="/cp/os.html" class="sidebar-link">操作系统</a></li><li><a href="/cp/soft.html" class="sidebar-link">软件工程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>编程语言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Web工程</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>实践</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>企业</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="算法"><a href="#算法" aria-hidden="true" class="header-anchor">#</a> 算法</h1> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%93%8D%E4%BD%9C%E5%A4%A7%E5%85%A8.jpg"> <h2 id="应用"><a href="#应用" aria-hidden="true" class="header-anchor">#</a> 应用</h2> <h3 id="什么叫排序的稳定性？"><a href="#什么叫排序的稳定性？" aria-hidden="true" class="header-anchor">#</a> 什么叫排序的稳定性？</h3> <p>排序算法的稳定性大家应该都知道，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。</p> <h3 id="各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？"><a href="#各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？" aria-hidden="true" class="header-anchor">#</a> 各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？</h3> <p>首先了解<a href="/cp/algorithm.html#冒泡排序">冒泡排序</a>，<a href="/cp/algorithm.html#选择排序">选择排序</a>，<a href="/cp/algorithm.html#插入排序">插入排序</a>，<a href="/cp/algorithm.html#希尔排序">希尔排序</a>，<a href="/cp/algorithm.html#归并排序">归并排序</a>，<a href="/cp/algorithm.html#快速排序">快速排序</a>，<a href="/cp/algorithm.html#堆排序">堆排序</a>。</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20201126095106.png"> <h3 id="系统自带排序实现"><a href="#系统自带排序实现" aria-hidden="true" class="header-anchor">#</a> 系统自带排序实现</h3> <p>每个语言的排序内部实现都是不同的。</p> <p>对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。</p> <p>选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相 差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。</p> <h3 id="快速排序相当于其他排序，效率高的原因？"><a href="#快速排序相当于其他排序，效率高的原因？" aria-hidden="true" class="header-anchor">#</a> 快速排序相当于其他排序，效率高的原因？</h3> <p>首先了解<a href="/cp/algorithm.html#各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？">各类排序算法介绍，冒泡，快排，堆排，以及相应的算法复杂度？</a></p> <p>在实际使用中，应用最广泛的是快速排序。快 速排序相对于其他排序算法的优势在于在相同 数据量的情况下，它的运算效率最高，并且它额外所需空间最小。</p> <p>我们首先从时间复杂度来判断，由于前面几种方法的时间复杂度平均情况下基本 趋向于 O(n^2)，因此只从时间复杂度上来看 的话，显然归并排序、堆排序和快 速排序的时间复杂度最小。但是既然这几种方法的时间复杂度基本一致，并且快 速排序在最 坏情况下时间的复杂度还会变为 O(n^2)，那么为什么它的效率反而 更高呢?</p> <p>首先在对大数据量排序的时候，由于归并排序的空间复杂度为 O(n)，因此归并 排序在这种情况下会需要过多的额外内存，因 此归并排序首先就被排除掉了。</p> <p>接下来就剩下了堆排序和快速排序的比较。我认为堆排序相对于快速排序的效率 不高的原因有两个方面。</p> <p>第一个方面是对于比较操作的有效性来说。对于快速排序来说，每一次元素的比 较都会确定该元素在数组中的位置，也就是在 枢纽值的左边或者右边，快速排 序的每一次比较操作都是有意义的结果。而对于堆排序来说，在每一次重新调整 堆的时候，我 们在迭代时，已经知道上层的节点值一定比下层的节点值大，因 此当我们每次为了打乱堆结构而将最后一个元素与堆顶元素互 换时，互换后的 元素一定是比下层元素小的，因此我们知道比较结果却还要在堆结构调整时去进 行再一次的比较，这样的比较 是没有意义的，以此在堆排序中会产生大量的没 有意义的比较操作。</p> <p>第二个方面是对于缓存局部性原理的利用上来考虑的，我认为这应该是造成堆排 序的效率不如快速排序的主要原因。在计算机 中利用了多级缓存的机制，来解决 cpu 计算速度与存储器数据读取速度间差距过大的问题。缓存的原理主要是基于局部性原 理，局部性原理简单来说就是，当前被访问过的数据，很有可能 在一段时间内被再次访问，这被称为时间局部性。还有就是当 前访问的数据， 那么它相邻的数据，也有可能在一段时间内被访问到，这被称为空间局部性。计 算机缓存利用了局部性的原理 来对数据进行缓存，来尽可能少的减少磁盘的I/O 次数，以此来提高执行效率。对于堆排序来说，它最大的问题就是它对于 空 间局部性的违背，它在进行比较时，比较的并不是相邻的元素，而是与自己相隔 很远的元素，这对于利用空间局部性来进行 数据缓存的计算机来说，它的很多 缓存都是无效的。并且对于大数据量的排序来说，缓存的命中率就会变得很低，因此会明显 提高磁盘的 I/O 次数，并且由于堆排序的大量的无效比较，因此这样就造成了堆排序执行效率的低下。而相对来快速排序来 说，它的排序每一次 都是在相邻范围内的比较，并且比较的范围越来越小，它很好的利用了局部性原 理，因此它的执行效率更 高。简单来说就是在堆排序中获取一个元素的值所花 费的时间比在快速排序获取一个元素的值所花费的时间要大。因此我们可 以看 出，时间复杂度类似的算法，在计算机中实际执行可能会有很大的差别，因为决 定算法执行效率的还有内存读取这样的其 他的因素。</p> <p>参考：</p> <p><a href="https://blog.csdn.net/qq_36770641/article/details/82669788" target="_blank" rel="noopener noreferrer">为什么说快速排序是性能最好的排序算法？_chenmeiqi的博客-CSDN博客_最快的排序算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/pongba/article/details/2544933" target="_blank" rel="noopener noreferrer">数学之美番外篇：快排为什么那样快_刘未鹏|C++的罗浮宫-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="二分查找的时间复杂度怎么求，是多少（todo）"><a href="#二分查找的时间复杂度怎么求，是多少（todo）" aria-hidden="true" class="header-anchor">#</a> 二分查找的时间复杂度怎么求，是多少（todo）</h3> <h3 id="线性顺序存储结构和链式存储结构有什么区别？以及优缺点-todo"><a href="#线性顺序存储结构和链式存储结构有什么区别？以及优缺点-todo" aria-hidden="true" class="header-anchor">#</a> 线性顺序存储结构和链式存储结构有什么区别？以及优缺点(todo)</h3> <h3 id="对大文件中的数据进行排序？"><a href="#对大文件中的数据进行排序？" aria-hidden="true" class="header-anchor">#</a> 对大文件中的数据进行排序？</h3> <p>对于数据量不大的情况，将文件中的内容读取出来，并且通过逗号分割成一个
一个的数字，放到内存数组中，然后编写某种排序算法(比如快排)，或者直接使用编程语
言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p> <p>如果文件大过内存，内存有限，我们没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用外部排序算法。外排序通常采用的是一种“排序-归并”的策略。在排序阶段，先读入能放在内存中的数据量，将其排序输出到一个临时文件，依此进行，将待排序数据组织为多个有序的临时文件。而后在归并阶段将这些临时文件组合为一个大的有序文件，也即排序结果。</p> <p>如果文件更大，需要等待时间过长，我们为了利用 CPU 多核的优势，可以在外部排序的基础之上进行优化，加入多线程并发排序的功能，这就有点类似“单机版”的MapReduce。</p> <p>如果更大，即便是单机多线程排序，这也算很慢了。这个时候， 我们可以使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率。</p> <h3 id="用两个栈来实现一个队列，完成队列的-push-和-pop-操作。"><a href="#用两个栈来实现一个队列，完成队列的-push-和-pop-操作。" aria-hidden="true" class="header-anchor">#</a> 用两个栈来实现一个队列，完成队列的 Push 和 Pop 操作。</h3> <p>队列的一个基本特点是，元素先进先出。</p> <p>通过两个栈来模拟时，首先我们将两个栈分为栈 1 和 栈 2。</p> <p>当执行队列的 push 操作时，直接将元素 push 进栈 1 中。</p> <p>当队列执行 pop 操作时，首先判断栈 2 是否为空，如果不为空则直接 pop 元素。</p> <p>如果栈 2 为空，则将栈 1 中的所有元素 pop 然后 push 到栈 2 中，然后再执行栈 2 的 pop 操作。</p> <h3 id="数组和链表的优缺点？"><a href="#数组和链表的优缺点？" aria-hidden="true" class="header-anchor">#</a> 数组和链表的优缺点？</h3> <p>链表的用处是在特定应用场景下省时间。基本上链表不能省空间。</p> <p>数组可以提供O(1)的随机访问，链表可以提供O(1)的插入和删除操作。</p> <p>链表的优点除了「插入删除不需要移动其他元素」之外，还在于它是一个局部化结构。就是说当你拿到链表的一个 node 之后，不需要太多其它数据，就可以完成插入，删除的操作。而其它的数据结构不行。比如说 array，你只拿到一个 item 是断不敢做插入删除的。</p> <h3 id="什么是贪心算法？"><a href="#什么是贪心算法？" aria-hidden="true" class="header-anchor">#</a> 什么是贪心算法？</h3> <p>在对问题求解时，总是做出在当前看来是最好的选择。 也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择 。</p> <h3 id="什么是动态规划？"><a href="#什么是动态规划？" aria-hidden="true" class="header-anchor">#</a> 什么是动态规划？</h3> <p>动态规划(Dynamic programming，简称DP)是一种经过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p> <h3 id="背包问题"><a href="#背包问题" aria-hidden="true" class="header-anchor">#</a> 背包问题</h3> <p>题干：假设山洞里共有a,b,c,d ,e这5件宝物（不是5种宝物），它们的重量分别是2,2,6,5,4，它们的价值分别是6,3,5,4,6，现在给你个承重为10的背包, 怎么装背包，可以才能带走最多的财富。</p> <p>手动推导：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20220301135108.png"> <p>只要你能通过找规律手工填写出上面这张表就算理解了01背包的动态规划算法。</p> <p>首先要明确这张表是至底向上，从左到右生成的。</p> <p>为了叙述方便，用e2单元格表示e行2列的单元格，这个单元格的意义是用来表示只有物品e时，有个承重为2的背包，那么这个背包的最大价值是0，因为e物品的重量是4，背包装不了。</p> <p>对于d2单元格，表示只有物品e，d时,承重为2的背包,所能装入的最大价值，仍然是0，因为物品e,d都不是这个背包能装的</p> <p>对于承重为8的背包，a8=15,是怎么得出的呢？</p> <p>根据01背包的状态转换方程，需要考察两个值，</p> <p>一个是f[i-1,j],对于这个例子来说就是b8的值9，另一个是f[i-1,j-Wi]+Pi；</p> <p>在这里，</p> <p>f[i-1,j]表示我有一个承重为8的背包，当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值</p> <p>f[i-1,j-Wi]表示我有一个承重为6的背包（等于当前背包承重减去物品a的重量），当只有物品b,c,d,e四件可选时，这个背包能装入的最大价值</p> <p>f[i-1,j-Wi]就是指单元格b6,值为9，Pi指的是a物品的价值，即6</p> <p>由于f[i-1,j-Wi]+Pi = 9 + 6 = 15 大于f[i-1,j] = 9，所以物品a应该放入承重为8的背包</p> <p>其实还是找规律。</p> <p>参考：</p> <p><a href="https://blog.csdn.net/mu399/article/details/7722810" target="_blank" rel="noopener noreferrer">动态规划之01背包问题（最易理解的讲解）_mu399的专栏-CSDN博客_01背包问题动态规划<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="一个前端瀑布流，双列的，怎么保证图片高度最小？"><a href="#一个前端瀑布流，双列的，怎么保证图片高度最小？" aria-hidden="true" class="header-anchor">#</a> 一个前端瀑布流，双列的，怎么保证图片高度最小？</h3> <p>保存两个数组，分别是左列和右列的高度。</p> <p>第一种方式是用贪心算法。在每个图片加入时，计算两列中谁总合最小，加入到其中。</p> <p>贪心算法只寻求局部最优解（只在考虑当前图片的时候找到一个最优解），因此最后左右两边的高度差仍是相对较大的，局部最优解很难成为全局最优解。</p> <p>第二种方式就是动态规划。</p> <p>假设咱们有 <code>[1, 2, 3]</code> 这 3 个图片高度的数组，咱们要凑到的是图片总高度的一半，也就是 <code>(1 + 2 + 3) / 2 = 3</code>。</p> <p>那个这个问题就类比于背包问题了。</p> <p>参考：</p> <p><a href="http://www.noobyard.com/article/p-acpyrgyg-c.html" target="_blank" rel="noopener noreferrer">这个前端居然用动态规划写瀑布流布局？给我打死他！ - 菜鸟学院<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="原理"><a href="#原理" aria-hidden="true" class="header-anchor">#</a> 原理</h2> <h3 id="git的diff操作是基于什么算法的（myers）？简单说下原理。"><a href="#git的diff操作是基于什么算法的（myers）？简单说下原理。" aria-hidden="true" class="header-anchor">#</a> git的diff操作是基于什么算法的（Myers）？简单说下原理。</h3> <p>参考：</p> <p>git的diff是基于Myers算法，基于查找最短编辑脚本（shortest edit script, SES）的思想。最短编辑脚本查找问题可以被建模成图搜索问题。</p> <p>以文本a = ABCABBA和文本b = CBABAC来说明。</p> <p>构建图为：</p> <img src="https://raw.githubusercontent.com/brizer/graph-bed/master/img/20190819110409.png"> <p>在上面的坐标系中，当我们位于原点(0,0)时，表示我们现在有一个字符串a；</p> <p>当我们向右走，也就是增加x坐标的时候，对应的从a中删除一个字符，比如我们从(0,0) - &gt; (1,0)时，我们从a中删除字符A，这时候我们当前的文本就变成了BCABBA；</p> <p>而当我们向下走，也就是增加y坐标的时候，对应的从b中插入一个字符，比如我们从(1,0) -&gt; (1,1)的时候，对应的插入b中的字符C，这时候的文本变成了CBCABBA；</p> <p>在上面的某些位置上面还有斜向下的虚线，比如从(1,1) -&gt; (2,2)，这时候表示a[1]==b[1]，这时候保留该字符，并且同时增加x坐标和y坐标；</p> <p>而当我们沿某一条路线从(0,0)走到(7,6)，就代表字符串a经过一系列编辑操作之后转换成了字符串b。</p> <p>我们把上面的向右走记作del操作，向下走记为ins操作，沿虚线走记为mov操作，只有执行del操作和ins操作才会让字符串发生变更。我们可以看到，从(0,0)到(7,6)有很多条路径可达，最多需要7+6次del和ins操作，也就是执行全删全增操作。</p> <p>myers算法的思想很简单，就是<strong>要找出一条从(0,0)到(7,6)的路径，让这条路径中的del和ins操作尽量的少</strong>，这就要求要尽量执行mov操作，并且当出现分支选择的时候，del操作能够优先于ins操作。</p> <p><a href="http://mcll.top/2019/05/23/diff%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener noreferrer">一种diff算法：Myers <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="编码"><a href="#编码" aria-hidden="true" class="header-anchor">#</a> 编码</h2> <h3 id="冒泡排序"><a href="#冒泡排序" aria-hidden="true" class="header-anchor">#</a> 冒泡排序</h3> <p>冒泡排序的基本思想是，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端， 最终达到完全有序。</p> <p><img src="https://camo.githubusercontent.com/34e1e2a85f90e3d7c005ada9e1c7a5f57a7eb9a4d519fb369b276a0dd7f5aec9/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f632f63382f427562626c652d736f72742d6578616d706c652d33303070782e676966" alt=""></p> <p>实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 先确保最后一位是正确的，每塞一个，就占位一个，然后准备塞倒数第二位</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> outer <span class="token operator">=</span> len <span class="token punctuation">;</span> outer <span class="token operator">&gt;=</span> <span class="token number">2</span><span class="token punctuation">;</span> outer<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从第一个开始一个个比较</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> inner <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> inner <span class="token operator">&lt;=</span>outer <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> inner<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// 一个个比较，把最小的放到后面一位</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>inner<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>inner <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>inner<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>inner<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>inner<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>inner<span class="token punctuation">]</span><span class="token punctuation">]</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>当排序序列为已排序序列时，为最好的时间复杂度为 O(n)。 冒泡排序的平均时间复杂度为 O(n^2) ，最坏时间复杂度为 O(n^2) ，空间复杂度
为 O(1) ，是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/bubble-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/bubble-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903656865677326" target="_blank" rel="noopener noreferrer">前端笔试&amp;面试爬坑系列---算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="选择排序"><a href="#选择排序" aria-hidden="true" class="header-anchor">#</a> 选择排序</h3> <p>选择排序的基本思想为每一趟从待排序的数据元素中选择最小(或最大)的一个 元素作为首元素，直到所有元素排完为止。</p> <p><img src="https://camo.githubusercontent.com/fe834a61b6e60d9e46d124f8c5b90e73f7b44db1442371932aa069257654493a/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f392f39342f53656c656374696f6e2d536f72742d416e696d6174696f6e2e676966" alt=""></p> <p>实现很简单： 外层循环从0开始到length-1， 然后内层比较，最小的放开头</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">selectSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">//先把第一个选中</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 让他和其他的依次比较，小就直接换位</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token punctuation">;</span> j<span class="token operator">&lt;</span>len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>

</code></pre></div><p>选择排序的平均时间复杂度为 O(n^2) ，最好时间复杂度为 O(n^2)，最坏时间复杂度为 O(n^2) ，空间复杂度为 O(1) ，是不稳定排序。</p> <p>举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了，所以选择排序不是一个稳定的排序算法。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/selection-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/selection-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903656865677326" target="_blank" rel="noopener noreferrer">前端笔试&amp;面试爬坑系列---算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="插入排序"><a href="#插入排序" aria-hidden="true" class="header-anchor">#</a> 插入排序</h3> <p>直接插入排序基本思想是每一步将一个待排序的记录，插入到前面已经排好序的 有序序列中去，直到插完所有元素为止。</p> <p>插入排序核心--扑克牌思想: 就想着自己在打扑克牌，接起来一张，放哪里无 所谓，再接起来一张，比第一张小，放左边， 继续接，可能是中间数，就插在 中间....依次.</p> <p><img src="https://camo.githubusercontent.com/ac772dfad98df54c1658e98dcfeb11f76aa7e7f027558554067c9eeef219d852/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f302f30662f496e73657274696f6e2d736f72742d6578616d706c652d33303070782e676966" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">insertSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//外循环从1开始，默认arr[0]是有序段</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
        <span class="token comment">//j = i,将arr[j]依次插入有序段中</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
            <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当排序序列为已排序序列时，为最好的时间复杂度 O(n)。 插入排序的平均时间复杂度为 O(n^2) ，最坏时间复杂度为 O(n^2) ，空间复杂度为 O(1) ，是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/insertion-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/insertion-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903656865677326" target="_blank" rel="noopener noreferrer">前端笔试&amp;面试爬坑系列---算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="希尔排序"><a href="#希尔排序" aria-hidden="true" class="header-anchor">#</a> 希尔排序</h3> <p>希尔排序的基本思想是把数组按下标的一定增量分组，对每组使用直接插入排序 算法排序;随着增量逐渐减少，每组包含的元 素越来越多，当增量减至 1 时， 整个数组恰被分成一组，算法便终止。</p> <p><img src="https://camo.githubusercontent.com/a8b5da7d73d0e30f76846af1af6f4236426ab59b0f6433930198fabbb08b4285/68747470733a2f2f7777772e7475746f7269616c73706f696e742e636f6d2f646174615f737472756374757265735f616c676f726974686d732f696d616765732f7368656c6c5f736f72745f6761705f342e6a7067" alt=""></p> <p><img src="https://camo.githubusercontent.com/4d2bd8ce55a62a72d56f696900eb37d90a79941097d2a03a5baeadaba105db31/68747470733a2f2f7777772e7475746f7269616c73706f696e742e636f6d2f646174615f737472756374757265735f616c676f726974686d732f696d616765732f7368656c6c5f736f72745f6761705f322e6a7067" alt=""></p> <p>实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token parameter">arr<span class="token punctuation">,</span>gap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token comment">//为了方便观察过程，使用时去除</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>gap<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//最外层循环，一次取不同的步长，步长需要预先给出</span>
        <span class="token keyword">let</span> n <span class="token operator">=</span> gap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//步长为n</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> j <span class="token operator">=</span> i <span class="token operator">+</span> n<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//接下类和插入排序一样，j循环依次取后面的数</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token operator">=</span> j<span class="token punctuation">;</span> k <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">-=</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//k循环进行比较，和直接插入的唯一区别是1变为了n</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>k<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>k<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>arr<span class="token punctuation">[</span>k<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token punctuation">,</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">当前序列为[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arr<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">] \n 交换了</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arr<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">和</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>arr<span class="token punctuation">[</span>k<span class="token operator">-</span>n<span class="token punctuation">]</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token comment">//为了观察过程</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    <span class="token keyword">continue</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> arr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>希尔排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^s) ，空间复 杂度为 O(1) ，不是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/shell-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/shell-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903656865677326#heading-8" target="_blank" rel="noopener noreferrer">前端笔试&amp;面试爬坑系列---算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="归并排序"><a href="#归并排序" aria-hidden="true" class="header-anchor">#</a> 归并排序</h3> <p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略。递归的将数组两两分开直到只包含一个元素，然后将数组排序合并，最终合并为排序好的数组。</p> <p><img src="https://camo.githubusercontent.com/1d3f6508e07151f337fddc8e0e25b3f53fb1abd4cb3cebca16d8333544fc3d99/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f632f63632f4d657267652d736f72742d6578616d706c652d33303070782e676966" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token parameter">leftArr<span class="token punctuation">,</span> rightArr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  
    <span class="token keyword">while</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rightArr<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
      <span class="token keyword">if</span> <span class="token punctuation">(</span>leftArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> rightArr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//把最小的最先取出，放到结果集中   </span>
      <span class="token keyword">else</span>   
        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>rightArr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>   
    <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>leftArr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>rightArr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//剩下的就是合并，这样就排好序了  </span>
<span class="token punctuation">}</span>  

<span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  
    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> array<span class="token punctuation">;</span>  
    <span class="token keyword">var</span> middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//求出中点  </span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">//分割数组  </span>
    <span class="token keyword">var</span> right <span class="token operator">=</span> array<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归合并与排序  </span>
<span class="token punctuation">}</span>  

<span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">56</span><span class="token punctuation">,</span><span class="token number">78</span><span class="token punctuation">,</span><span class="token number">76</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// [12, 32, 36, 45, 56, 76, 78]</span>
</code></pre></div><p>归并排序将整个排序序列看成一个二叉树进行分解，首先将树分解到每一个子节 点，树的每一层都是一个归并排序的过程，每 一层归并的时间复杂度为 O(n)，
因为整个树的高度为 lgn，所以归并排序的时间复杂度不管在什么情况下都为 O(nlogn)。</p> <p>归并排序的空间复杂度取决于递归的深度和用于归并时的临时数组，所以递归的深度为 logn，临时数组的大小为 n，所以归 并排序的空间复杂度为 O(n)。</p> <p>归并排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间 复杂度为 O(n) ，是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/merge-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/merge-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/mevicky/article/details/46127553?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160628864919725225021262%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=160628864919725225021262&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-46127553.pc_v2_rank_blog_default&amp;utm_term=%E5%BD%92%E5%B9%B6&amp;spm=1018.2118.3001.4450" target="_blank" rel="noopener noreferrer">归并排序_brizer的博客-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="快速排序"><a href="#快速排序" aria-hidden="true" class="header-anchor">#</a> 快速排序</h3> <p>快速排序的基本思想是通过一趟排序将要排序的数据分割成独立的两部分，其中 一部分的所有数据都比另外一部分的所有数据 都要小，然后再按此方法对这两 部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变 成有序序列。</p> <p><img src="https://camo.githubusercontent.com/9d156a36ab19a3ae2dfbabc70daaaa074fddfaac233f6d0bfce45b8d07ad5289/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f362f36612f536f7274696e675f717569636b736f72745f616e696d2e676966" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>  <span class="token comment">//递归出口</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        right <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        current <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注意splice后，数组长度少了一个</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            left<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">//放在左边</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            right<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">//放在右边</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span><span class="token function">quickSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//递归</span>
<span class="token punctuation">}</span>

</code></pre></div><p>快速排序的空间复杂度取决于递归的深度，所以最好的时候为 O(logn)，最坏的时候为 O(n)。</p> <p>快速排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(n^2) ，空间复杂度为 O(logn) ，不是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/quick-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/quick-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903656865677326#heading-8" target="_blank" rel="noopener noreferrer">前端笔试&amp;面试爬坑系列---算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="堆排序"><a href="#堆排序" aria-hidden="true" class="header-anchor">#</a> 堆排序</h3> <p>堆排序的基本思想是:将待排序序列构造成一个大顶堆，此时，整个序列的最大 值就是堆顶的根节点。将其与末尾元素进行 交换，此时末尾就为最大值。然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。如此反 复执行， 便能得到一个有序序列了。</p> <p><img src="https://camo.githubusercontent.com/c8ee4c2d4b28615947bfde32ff810c8b81a151b91da1e44f917b426e3991315b/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f342f34642f48656170736f72742d6578616d706c652e676966" alt=""></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建堆，其实是对data数组做一个结构调整，使其具有堆的特性</span>
<span class="token keyword">function</span> <span class="token function">buildHeap</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">heapAjust</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 堆调整函数，即调整当前data为大根堆</span>
<span class="token keyword">function</span> <span class="token function">heapAjust</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token comment">// 如果有孩子结点，默认情况是左孩子</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>child <span class="token operator">&lt;=</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> temp <span class="token operator">=</span> data<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">// 如果右孩子存在且其值大于左孩子的值，则将child指向右孩子</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>child <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;=</span> len <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            child <span class="token operator">=</span> child <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 如果当前结点的值小于其孩子结点的值，则交换，直至循环结束</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> data<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            data<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data<span class="token punctuation">[</span>child<span class="token punctuation">]</span><span class="token punctuation">;</span>
            data<span class="token punctuation">[</span>child<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
            i <span class="token operator">=</span> child<span class="token punctuation">;</span>
            child <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">break</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 排序</span>
<span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> data <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>data <span class="token keyword">instanceof</span> <span class="token class-name">Array</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>data <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> data<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将data数组改造为“堆”的结构</span>
    <span class="token function">buildHeap</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">var</span> len <span class="token operator">=</span> data<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token comment">// 下面需要注意的时候参数的边界，参考文档里面程序中i的值是不对的</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">swap</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">heapAjust</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> data<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">62</span><span class="token punctuation">,</span> <span class="token number">88</span><span class="token punctuation">,</span> <span class="token number">58</span><span class="token punctuation">,</span> <span class="token number">47</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token number">73</span><span class="token punctuation">,</span> <span class="token number">51</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">,</span> <span class="token number">37</span><span class="token punctuation">,</span> <span class="token number">93</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> newArr <span class="token operator">=</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>newArr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// [35, 37, 47, 51, 58, 62, 73, 88, 93, 99]</span>


</code></pre></div><p>建立堆的时间复杂度为 O(n)，排序循环的次数为 n-1，每次调整堆的时间复杂 度为 O(logn)，因此堆排序的时间复杂度在 不管什么情况下都是 O(nlogn)。</p> <p>堆排序的平均时间复杂度为 O(nlogn) ，最坏时间复杂度为 O(nlogn) ，空间复 杂度为 O(1) ，不是稳定排序。</p> <p>参考：</p> <p><a href="https://github.com/trekhleb/javascript-algorithms/tree/master/src/algorithms/sorting/heap-sort" target="_blank" rel="noopener noreferrer">javascript-algorithms/src/algorithms/sorting/heap-sort at master · trekhleb/javascript-algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://blog.csdn.net/mevicky/article/details/46127541?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160629155819724836717735%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&amp;request_id=160629155819724836717735&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_blog_default-1-46127541.pc_v2_rank_blog_default&amp;utm_term=%E5%A0%86%E6%8E%92%E5%BA%8F&amp;spm=1018.2118.3001.4450" target="_blank" rel="noopener noreferrer">堆排序_brizer的博客-CSDN博客<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><a href="https://juejin.cn/post/6844903830258188296" target="_blank" rel="noopener noreferrer">搞定JavaScript算法系列--堆排序<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="求解平方根（二分查找）（todo）"><a href="#求解平方根（二分查找）（todo）" aria-hidden="true" class="header-anchor">#</a> 求解平方根（二分查找）（todo）</h3> <h3 id="实现二叉树的遍历，考虑非递归。"><a href="#实现二叉树的遍历，考虑非递归。" aria-hidden="true" class="header-anchor">#</a> 实现二叉树的遍历，考虑非递归。</h3> <p>思路：</p> <p>如果非递归的话利用栈来简化操作
如果数据规模不大的话，建议使用递归
递归的问题需要注意两点，一个是终止条件，一个如何缩小规模</p> <p>1、终止条件，自然是当前这个元素是 null（链表也是一样）</p> <p>2、由于二叉树本身就是一个递归结构， 每次处理一个子树其实就是缩小了规模， 难点在于<strong>如何合并结果</strong>，这里的合并结果其实就是<code>mid.concat(left).concat(right)</code>, mid 是一个具体的节点，left 和 right递归求出即可。</p> <p>先序遍历</p> <p>递归方式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. Recursive solution</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>非递归方式</p> <p>先<strong>将根节点入栈，然后 看有没有右节点，有则入栈，再看有没有左节点，有则入栈。 然后出栈一个元素，重复即可</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">preorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> t <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">while</span> <span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//先将根节点入栈</span>
    ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果有右节点则入栈</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//如果有左节点则入栈</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//然后出栈，直到栈内没内容为止</span>
    t <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>中序遍历</p> <p>递归方式</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//使用递归的方案</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token operator">?</span><span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token operator">?</span><span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> left<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>非递归方式：</p> <p>如果采用非递归，可以用栈(Stack)的思路来处理问题。
中序遍历的顺序为左-根-右，具体算法为：</p> <p>从根节点开始，<strong>先将根节点压入栈</strong></p> <p>然后再将其<strong>所有左子结点压入栈</strong>，取出栈顶节点，保存节点值</p> <p>再将<strong>当前指针移到其右子节点上，若存在右子节点，则在下次循环时又可将其所有左子结点压入栈中</strong>， 重复上步骤</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">inorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//使用递归的方案</span>
    <span class="token comment">// if(!root) return [];</span>
    <span class="token comment">// let left = root.left?inorderTraversal(root.left):[];</span>
    <span class="token comment">// let right = root.right?inorderTraversal(root.right):[];</span>
    <span class="token comment">// return left.concat(root.val).concat(right);</span>
    <span class="token comment">//使用栈的方案</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>

    <span class="token keyword">let</span> item <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// stack 中弹出的当前项</span>
    <span class="token comment">//先将左节点全部压入栈</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
        left <span class="token operator">=</span> left<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//首先处理所有加入栈的左节点们</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>item <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//取出栈内值</span>
        ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">let</span> t <span class="token operator">=</span> item<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
        <span class="token comment">//如果存在右节点，压入栈，并将其所有的左节点压入栈</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
            t <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">;</span>     
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>后序遍历</p> <p>递归方式</p> <div class="language-js extra-class"><pre class="language-js"><code> <span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> left <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token operator">?</span><span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> right <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token operator">?</span><span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> left<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>非递归方案</p> <p>如果采用非递归，可以用栈(Stack)的思路来处理问题。
相比于前序遍历，后续遍历思维上难度要大些，<strong>前序遍历是通过一个stack，首先压入父亲结点，然后弹出父亲结点，并输出它的value，之后压人其右儿子，左儿子</strong>即可。</p> <p>然而后序遍历结点的访问顺序是：左儿子 -&gt; 右儿子 -&gt; 自己。那么<strong>一个结点需要两种情况下才能够输出： 第一，它已经是叶子结点； 第二，它不是叶子结点，但是它的儿子已经输出过</strong>。</p> <p>那么基于此我们只需要<strong>记录一下当前输出的结点</strong>即可。对于一个新的结点，<strong>如果它不是叶子结点，儿子也没有访问，那么就需要将它的右儿子，左儿子压入</strong>。 如果它<strong>满足输出条件，则输出它，并记录下当前输出结点</strong>。输出在stack为空时结束。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */</span>
<span class="token comment">/**
 * @param {TreeNode} root
 * @return {number[]}
 */</span>
<span class="token keyword">var</span> <span class="token function-variable function">postorderTraversal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//使用栈的方案</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> ret <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> p <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token comment">// 标识元素，用来判断节点是否应该出栈</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//对栈尾元素进行判断</span>
    <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>
      top<span class="token punctuation">.</span>left <span class="token operator">===</span> p <span class="token operator">||</span>
      top<span class="token punctuation">.</span>right <span class="token operator">===</span> p <span class="token operator">||</span> <span class="token comment">// 子节点已经遍历过了</span>
      <span class="token punctuation">(</span>top<span class="token punctuation">.</span>left <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> top<span class="token punctuation">.</span>right <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment">// 叶子元素</span>
    <span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//满足条件则出栈，并存入结果列表</span>
      p <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      ret<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">//否则将其右节点和左节点依次入栈</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>top<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="如何判断是不是完全二叉树？（todo）"><a href="#如何判断是不是完全二叉树？（todo）" aria-hidden="true" class="header-anchor">#</a> 如何判断是不是完全二叉树？（todo）</h3> <h3 id="实现一个二叉搜索树转链表的方法（todo）"><a href="#实现一个二叉搜索树转链表的方法（todo）" aria-hidden="true" class="header-anchor">#</a> 实现一个二叉搜索树转链表的方法（todo）</h3> <h3 id="判断一个链表是否有环（todo）"><a href="#判断一个链表是否有环（todo）" aria-hidden="true" class="header-anchor">#</a> 判断一个链表是否有环（todo）</h3> <h3 id="反转单向链表"><a href="#反转单向链表" aria-hidden="true" class="header-anchor">#</a> 反转单向链表</h3> <p>需要将一个单向链表反转。思路很简单，使用三个变量分别表示当前节点和当前 节点的前后节点，虽然这题很简单，但是却是 一道面试常考题。</p> <p>思路是从头节点往后遍历，先获取下一个节点，然后将当前节点的 next 设置为 前一个节点，然后再继续循环。</p> <p>方法一：遍历</p> <p>先遍历到尾部</p> <p>在遍历过程中让节点新增属性 pre 使单向链表变成双向链表</p> <p>遍历到尾部时开始指向反转并删除节点的 pre 属性</p> <p>边界条件：</p> <p>在头部时，节点的 pre 属性为 null</p> <p>到尾部时，节点的 next 属性为 null</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token parameter">head</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 链表只有一个元素时</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> head<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token keyword">return</span> head<span class="token punctuation">;</span>
    <span class="token comment">// 否则</span>
    <span class="token keyword">let</span> current <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">,</span>
        preNode <span class="token operator">=</span> head<span class="token punctuation">;</span>
    <span class="token comment">// 链表反向后原来的头就变成尾了</span>
    preNode<span class="token punctuation">.</span>pre <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// 相当于 head.pre = null;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span> current<span class="token punctuation">.</span>next <span class="token punctuation">)</span><span class="token punctuation">{</span>
        current<span class="token punctuation">.</span>pre <span class="token operator">=</span> preNode<span class="token punctuation">;</span>  <span class="token comment">// 建立反向联系</span>
        <span class="token comment">// 指针后移</span>
        preNode <span class="token operator">=</span> current<span class="token punctuation">;</span>
        current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    current<span class="token punctuation">.</span>pre <span class="token operator">=</span> preNode<span class="token punctuation">;</span>  <span class="token comment">// 建立最后一个元素和倒数第二个元素的联系</span>

    <span class="token comment">// 至此，一个双向链表已经完成了</span>
    <span class="token comment">// 然后就要开始往前遍历了</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span> current<span class="token punctuation">.</span>pre <span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">// 指向反向</span>
        current<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>
        <span class="token comment">// 使&quot;先指针&quot;和&quot;后指针&quot;都指向当前对象</span>
        preNode <span class="token operator">=</span> current<span class="token punctuation">;</span>
        <span class="token comment">// &quot;先指针&quot;前移</span>
        current <span class="token operator">=</span> current<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>
        <span class="token comment">// 将初始从前向后遍历时新增的属性删掉</span>
        <span class="token keyword">delete</span> preNode<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 修正原链表第一个元素的指向</span>
    current<span class="token punctuation">.</span>next <span class="token operator">=</span> current<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>
    <span class="token keyword">delete</span> current<span class="token punctuation">.</span>pre<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法二：递归</p> <p>每次只对一个元素进行操作，如果当前元素的后一项不为空，则递归调用本函数，传入的值为当前元素的后一项</p> <p>在每次递归形成的作用域中使后面的元素指向当前元素，当前元素指向空</p> <p>边界条件：</p> <p>当传入参数的属性 next 为 null时，说明这个元素是链表的最后一个元素</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">reverseList</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 传入链表的头结点</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> node<span class="token punctuation">.</span>next <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/*
        * 能走到这里的有只有两种情况：
        *   1.链表只有一个元素
        *   2.链表不止一个元素同时已经遍历到链表的最后一个元素了
        * */</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> nextNode <span class="token operator">=</span> <span class="token function">reverseList</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>
        nextNode<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>
        node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>   <span class="token comment">// 如果不是原链表的第一个元素，则会在上一次递归的作用域中被修改</span>
        <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>参考：</p> <p><a href="https://github.com/sisterAn/JavaScript-Algorithms/issues/14" target="_blank" rel="noopener noreferrer">leetcode206：反转链表 · Issue #14 · sisterAn/JavaScript-Algorithms<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="将一个嵌套的数组用深度遍历和广度遍历分别写出来-todo"><a href="#将一个嵌套的数组用深度遍历和广度遍历分别写出来-todo" aria-hidden="true" class="header-anchor">#</a> 将一个嵌套的数组用深度遍历和广度遍历分别写出来(todo)</h3> <h3 id="斐波那契数列（todo）"><a href="#斐波那契数列（todo）" aria-hidden="true" class="header-anchor">#</a> 斐波那契数列（todo）</h3> <h3 id="合并两个有序数组（todo）"><a href="#合并两个有序数组（todo）" aria-hidden="true" class="header-anchor">#</a> 合并两个有序数组（todo）</h3> <h3 id="动态规划"><a href="#动态规划" aria-hidden="true" class="header-anchor">#</a> 动态规划</h3> <p>爬楼梯问题</p> <p>有一座高度是 10 级台阶的楼梯，从下往上走，每跨一步只能向上 1 级或者 2 级 台阶。要求用程序来求出一共有多少种走法?</p> <p>递归方法分析</p> <p>由分析可知，假设我们只差最后一步就能走上第 10 级阶梯，这个时候一共有两种情况，因为每一步只允许走 1 级或 2 级阶梯， 因此分别为从 8 级阶梯和从 9
九级阶梯走上去的情况。</p> <p>因此从 0 到 10 级阶梯的走法数量就等于从 0 到 9 级阶梯的走法数量加上 从 0 到 8 级阶梯的走法数量。</p> <p>依次类推，我们可以得到一个递归关系，递归结束的标志为从 0 到 1 级阶梯的走法数量和从 0 到 2 级阶梯的 走法数量。</p> <p>代码实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用这种方法时整个的递归过程是一个二叉树的结构，因此该方法的时间复杂度 可以近似的看为 O(2^n)，空间复杂度 为递归的深度 O(logn)。</p> <p>备忘录方法</p> <p>分析递归的方法我们可以发现，其实有很多的计算过程其实是重复的，因此我们 可以使用一个数组，将已经计算出的值给 保存下来，每次计算时，先判断计算 结果是否已经存在，如果已经存在就直接使用。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">function</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><p>通过这种方式，我们将算法的时间复杂度降低为 O(n)，但是增加空间复杂度为 O(n)。</p> <p>迭代法</p> <p>通过观察，我们可以发现每一个值其实都等于它的前面两个值的和，因此我们可 以使用自底向上的方式来实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getClimbingWays</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> temp <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    temp <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
    a <span class="token operator">=</span> b<span class="token punctuation">;</span>
    b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过这种方式我们可以将算法的时间复杂度降低为 O(n)，并且将算法的空间复 杂度降低为 O(1)。</p> <p>参考：</p> <p><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTIzMzI2MA==&amp;mid=2650561168&amp;idx=1&amp;sn=9d1c6f7ba6d651c75399c4aa5254a7d8&amp;chksm=f1feec13c6896505f7886d9455278ad39749d377a63908c59c1fdceb11241e577ff6d66931e4&amp;scene=21" target="_blank" rel="noopener noreferrer">漫画：什么是动态规划？（整合版）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/cp/browser.html">
          浏览器相关
        </a>
        →
      </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.d2cc9f89.js" defer></script><script src="/assets/js/2.397e6419.js" defer></script><script src="/assets/js/9.eca79ebb.js" defer></script>
  </body>
</html>
